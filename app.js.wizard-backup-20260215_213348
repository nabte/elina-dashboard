// app.js - Lógica principal del Dashboard

// CORRECCIÓN: Se importan todos los módulos necesarios para que el compilador (Vite) los reconozca.
import './auth.js'; // auth.js debe estar primero
import './bulk-sending.js';
import './chats.js';
import './contacts.js';
import './smart-promotions.js';
import './sales-context.js';
import './designer-ai.js';
import './follow-ups.js';
import './kanban.js';
import './products.js';
import './quotes.js';
import './settings.js';
import './smart-labels.js';
import './templates.js';
import './video-ai.js';
import './appointments.js';
import './auto-responses.js';
import './prompt-training.js';
import './personal-tasks.js';
import { initAffiliatePanel } from './affiliate-panel.js';
import { initSupportChat } from './support-chat.js';


// --- INICIO: CORRECCIÓN DE ESTILO GLOBAL ---
// Inyecta una regla CSS para asegurar que los paneles inactivos no ocupen espacio.
// Esto soluciona el problema del espacio en blanco causado por paneles con display:flex.
const style = document.createElement('style');
style.textContent = `.content-panel:not(.active) { display: none !important; }`;
document.head.appendChild(style);
// --- FIN: CORRECCIÓN DE ESTILO GLOBAL ---

document.addEventListener('DOMContentLoaded', () => {
    // El script auth.js ahora se encarga de la inicialización del cliente de Supabase
    // y de escuchar los cambios de autenticación.
    // Simplemente esperamos a que 'auth:ready' nos avise que podemos empezar.
    const initializeDashboard = (session) => {
        if (session && !window.appInstance) {
            window.appInstance = new DashboardApp(session);
            window.appInstance.init();
            initSupportChat(); // Inicializar chat de soporte
            // Exponer switchPanel globalmente para uso en otros módulos
            window.switchPanel = (targetId, options) => window.appInstance.switchPanel(targetId, options);
        }
    };

    // Escucha el evento 'auth:ready' que dispara auth.js.
    // Este es el método más seguro para sincronizar.
    document.addEventListener('auth:ready', ({ detail }) => initializeDashboard(detail.session));

    // Exponer función de visibilidad de citas globalmente
    window.updateAppointmentsMenuVisibility = (isEnabled) => {
        const menuItem = document.getElementById('appointments-menu-item');
        if (menuItem) {
            if (isEnabled) {
                menuItem.classList.remove('hidden');
            } else {
                menuItem.classList.add('hidden');
            }
        }
    };
});

(function initColumnMappingModalUtility() {
    if (window.openColumnMappingModal) return;

    const createAutomaticMapping = (headers, fieldDefinitions) => {
        const mapping = {};
        const usedIndexes = new Set();
        const lowerHeaders = headers.map(h => h.toLowerCase());

        const guessHeaderIndex = (aliases = []) => {
            for (const alias of aliases) {
                const idx = lowerHeaders.indexOf(alias.toLowerCase());
                if (idx !== -1 && !usedIndexes.has(idx)) return idx;
            }
            return -1;
        };

        for (const def of fieldDefinitions) {
            let index = guessHeaderIndex(def.aliases);
            if (index === -1) {
                index = headers.findIndex((_, i) => !usedIndexes.has(i));
            }

            if (index === -1) {
                if (def.required) {
                    console.warn(`No se pudo asignar automáticamente la columna para "${def.label}".`);
                    return null;
                }
                continue;
            }

            mapping[def.field] = index;
            usedIndexes.add(index);
        }

        return mapping;
    };

    window.openColumnMappingModal = async function (fieldDefinitions = [], rawHeaders = []) {
        const headers = rawHeaders.map(h => (typeof h === 'string' ? h.trim() : '')).filter(Boolean);
        const modal = document.getElementById('column-mapping-modal');
        const tableBody = document.getElementById('column-mapping-table-body');
        const errorEl = document.getElementById('column-mapping-error');
        const confirmBtn = document.getElementById('confirm-column-mapping-btn');
        const cancelBtn = document.getElementById('cancel-column-mapping-btn');
        const closeBtn = document.getElementById('close-column-mapping-btn');

        if (!modal || !tableBody || !errorEl || !confirmBtn || !cancelBtn || !closeBtn) {
            console.warn('No se encontró el modal de mapeo de columnas. Se intentará asignar automáticamente.');
            return createAutomaticMapping(headers, fieldDefinitions);
        }

        return await new Promise((resolve) => {
            const defByField = new Map(fieldDefinitions.map(def => [def.field, def]));
            let resolved = false;
            let selects = [];

            tableBody.innerHTML = '';

            const guessHeaderIndex = (aliases = []) => {
                const lowerHeaders = headers.map(h => h.toLowerCase());
                for (const alias of aliases) {
                    const idx = lowerHeaders.indexOf(alias.toLowerCase());
                    if (idx !== -1) return idx;
                }
                return -1;
            };

            fieldDefinitions.forEach(def => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td class="px-4 py-3">
                        <div class="flex flex-col">
                            <span class="font-medium text-slate-700">${def.label}</span>
                            <span class="mt-1 text-xs ${def.required ? 'text-red-500 font-semibold' : 'text-slate-400'}">${def.required ? 'Obligatorio' : 'Opcional'}</span>
                        </div>
                    </td>
                    <td class="px-4 py-3">
                        <select class="w-full rounded-lg border border-slate-300 bg-white px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                            <option value="">${def.required ? 'Selecciona una columna' : 'Dejar sin asignar'}</option>
                        </select>
                    </td>
                `;

                const select = row.querySelector('select');
                select.dataset.field = def.field;
                select.dataset.required = def.required ? 'true' : 'false';

                headers.forEach((header, index) => {
                    const option = document.createElement('option');
                    option.value = String(index);
                    option.textContent = header;
                    select.appendChild(option);
                });

                tableBody.appendChild(row);
            });

            selects = Array.from(tableBody.querySelectorAll('select'));

            const usedValues = new Set();
            selects.forEach(select => {
                const def = defByField.get(select.dataset.field);
                const guessIndex = guessHeaderIndex(def?.aliases || []);
                if (typeof guessIndex === 'number' && guessIndex >= 0 && !usedValues.has(String(guessIndex))) {
                    select.value = String(guessIndex);
                    usedValues.add(String(guessIndex));
                }
            });

            const updateAvailability = () => {
                const selectedValues = new Set(selects.map(select => select.value).filter(Boolean));
                selects.forEach(select => {
                    Array.from(select.options).forEach(option => {
                        if (!option.value) return;
                        option.disabled = select.value !== option.value && selectedValues.has(option.value);
                    });
                });
            };

            const showError = (message) => {
                errorEl.textContent = message;
                errorEl.classList.remove('hidden');
            };

            const clearError = () => {
                errorEl.textContent = '';
                errorEl.classList.add('hidden');
            };

            const handleChange = (event) => {
                event.target.classList.remove('border-red-500');
                clearError();
                updateAvailability();
            };

            const cleanup = () => {
                selects.forEach(select => select.removeEventListener('change', handleChange));
                confirmBtn.removeEventListener('click', handleConfirm);
                cancelBtn.removeEventListener('click', handleCancel);
                closeBtn.removeEventListener('click', handleCancel);
                modal.removeEventListener('click', handleBackdrop);
                document.removeEventListener('keydown', handleKeydown);
                tableBody.innerHTML = '';
                clearError();
                modal.classList.add('hidden');
                document.body.classList.remove('overflow-hidden');
            };

            const finish = (value) => {
                if (resolved) return;
                resolved = true;
                cleanup();
                resolve(value);
            };

            const handleConfirm = () => {
                const result = {};
                clearError();

                for (const select of selects) {
                    const field = select.dataset.field;
                    const def = defByField.get(field);
                    const value = select.value;

                    if (!value) {
                        if (def?.required) {
                            select.classList.add('border-red-500');
                            showError(`Selecciona una columna para "${def.label}".`);
                            select.focus();
                            return;
                        }
                        continue;
                    }

                    result[field] = Number(value);
                }

                finish(result);
            };

            const handleCancel = () => finish(null);

            const handleBackdrop = (event) => {
                if (event.target === modal) finish(null);
            };

            const handleKeydown = (event) => {
                if (event.key === 'Escape') {
                    event.preventDefault();
                    finish(null);
                }
            };

            selects.forEach(select => select.addEventListener('change', handleChange));
            confirmBtn.addEventListener('click', handleConfirm);
            cancelBtn.addEventListener('click', handleCancel);
            closeBtn.addEventListener('click', handleCancel);
            modal.addEventListener('click', handleBackdrop);
            document.addEventListener('keydown', handleKeydown);

            document.body.classList.add('overflow-hidden');
            modal.classList.remove('hidden');
            clearError();
            if (typeof lucide?.createIcons === 'function') {
                lucide.createIcons();
            }
            updateAvailability();
            selects[0]?.focus();
        });
    };

    window.escapeCsvValue = function (value) {
        if (value === null || value === undefined) return '';
        const stringValue = String(value);
        if (/[",\n]/.test(stringValue)) {
            return '"' + stringValue.replace(/"/g, '""') + '"';
        }
        return stringValue;
    };

    window.splitCsvLines = function (csvText) {
        if (typeof csvText !== 'string') return [];

        let text = csvText;
        if (text.length && text.charCodeAt(0) === 0xFEFF) {
            text = text.slice(1);
        }

        const rows = [];
        let current = '';
        let inQuotes = false;

        for (let i = 0; i < text.length; i++) {
            const char = text[i];

            if (char === '"') {
                if (inQuotes && text[i + 1] === '"') {
                    current += '"';
                    i++;
                } else {
                    inQuotes = !inQuotes;
                    current += char;
                }
                continue;
            }

            if ((char === '\n' || char === '\r') && !inQuotes) {
                if (char === '\r' && text[i + 1] === '\n') {
                    i++;
                }
                rows.push(current);
                current = '';
                continue;
            }

            current += char;
        }

        if (current.length > 0) {
            rows.push(current);
        }

        return rows
            .map(line => line.trim())
            .filter(line => line.length > 0);
    };

    window.convertFileToCsvText = async function (file) {
        const lowerName = (file.name || '').toLowerCase();

        if (lowerName.endsWith('.xlsx') || lowerName.endsWith('.xls')) {
            if (typeof XLSX === 'undefined') {
                throw new Error('No se pudo cargar el lector de hojas de cálculo (XLSX). Recarga la página e intenta nuevamente.');
            }

            const arrayBuffer = await file.arrayBuffer();
            const workbook = XLSX.read(arrayBuffer, { type: 'array' });
            if (!workbook.SheetNames.length) {
                throw new Error('El archivo de Excel no contiene hojas válidas.');
            }

            const worksheet = workbook.Sheets[workbook.SheetNames[0]];
            return XLSX.utils.sheet_to_csv(worksheet, { FS: ',', RS: '\n' });
        }

        return await file.text();
    };

    // --- INICIO: Funciones de utilidad CSV (movidas de contacts.js y products.js) ---
    window.parseCsvRow = function (row) {
        const result = [];
        let current = '';
        let inQuotes = false;
        for (let i = 0; i < row.length; i++) {
            const char = row[i];
            if (char === '"' && (i === 0 || row[i - 1] !== '"')) {
                if (inQuotes && row[i + 1] === '"') {
                    current += '"';
                    i++;
                } else {
                    inQuotes = !inQuotes;
                }
            } else if (char === ',' && !inQuotes) {
                result.push(current.trim());
                current = '';
            } else {
                current += char;
            }
        }
        result.push(current.trim());
        return result;
    };

    window.autoMapHeaders = function (headers, fieldDefinitions) {
        const mapping = {};
        const usedIndexes = new Set();
        const lowerHeaders = headers.map(h => h.toLowerCase());

        for (const def of fieldDefinitions) {
            let index = -1;
            for (const alias of def.aliases || []) {
                const idx = lowerHeaders.indexOf(alias.toLowerCase());
                if (idx !== -1 && !usedIndexes.has(idx)) {
                    index = idx;
                    break;
                }
            }

            if (index === -1) {
                index = headers.findIndex((_, idx) => !usedIndexes.has(idx));
            }

            if (index === -1) {
                if (def.required) return null;
                continue;
            }

            mapping[def.field] = index;
            usedIndexes.add(index);
        }

        return mapping;
    };

    window.getColumnValue = function (columns, index) {
        if (typeof index !== 'number' || index < 0 || index >= columns.length) return '';
        return columns[index];
    };

    window.cleanPhone = function (value) {
        if (!value) return '';
        const digits = String(value).replace(/\D+/g, '');
        if (digits.length < 10) return '';
        const nationalNumber = digits.slice(-10);
        return '+521' + nationalNumber;
    };
})();


class DashboardApp {
    constructor(session) {
        this.session = session;
        this.switchPanel = this.switchPanel.bind(this); // Asegurar que switchPanel esté vinculado
        this.user = session.user;
        this.teamInfo = null; // Para almacenar la info del equipo del usuario
        this.config = {
            N8N_URL: 'https://n8n-n8n.mcjhhb.easypanel.host', // Reemplazar con tu URL de n8n
            YOUTUBE_PLAYLIST_ID: 'PLfA32SmdFbHBdOXaPc_tdg28Kl2CFAXnz',
            CHATWOOT_BASE_URL: 'https://chat.elinaia.com.mx'
        };
        // Vincula los métodos para que 'this' funcione correctamente en los event listeners
        this.handlePromptSave = this.handlePromptSave.bind(this);
        this.checkWhatsappConnection = this.checkWhatsappConnection.bind(this);
        this.openChatwoot = this.openChatwoot.bind(this);
        this.openAiEnhanceModal = this.openAiEnhanceModal.bind(this);
        this.openPromptHistory = this.openPromptHistory.bind(this);
        this.closePromptHistory = this.closePromptHistory.bind(this);
    }

    init() {

        // CORRECCIÓN: Llamar a lucide.createIcons() aquí, una vez que el DOM está listo y los scripts cargados.
        lucide.createIcons();

        // Procesar parámetro de invitación en la URL
        this.processInvitationFromURL();

        // Modal de bienvenida para nuevos usuarios
        if (!localStorage.getItem('welcome_popup_shown')) {
            const welcomeModal = document.getElementById('welcome-modal');
            if (welcomeModal) {
                welcomeModal.classList.remove('hidden');
                document.getElementById('close-welcome-modal').addEventListener('click', () => {
                    welcomeModal.classList.add('hidden');
                    localStorage.setItem('welcome_popup_shown', 'true');
                });
            }
        }

        this.setupEventListeners();
        this.loadInitialData();
        // Recupera y muestra el último panel activo, o 'dashboard' por defecto
        this.checkImpersonation(); // <-- AÑADIDO: Verificar si estamos en modo suplantación
        const lastPanel = localStorage.getItem('activePanelId') || 'dashboard'; // CORRECCIÓN: No se necesita 'options' aquí
        this.switchPanel(lastPanel);
        this.listenForProfileChanges();
        this.wizard = new Wizard(this); // Inicializar el Wizard aquí

        // --- INICIO: Restaurar estado del sidebar ---
        this.setSidebarCollapsed(localStorage.getItem('sidebarCollapsed') === 'true');
        // --- FIN: Restaurar estado del sidebar ---

        // Verificar estado de appointment_settings y actualizar menú
        this.checkAppointmentsEnabled();

        // --- INICIO: Manejo de Hash para navegación directa ---
        const handleHash = () => {
            const hash = window.location.hash.substring(1);
            if (hash) {
                console.log(`[App] Navegando por hash a: ${hash}`);
                this.switchPanel(hash);
            }
        };
        window.addEventListener('hashchange', handleHash);
        // Ejecutar al inicio si hay hash
        if (window.location.hash) handleHash();
        // --- FIN: Manejo de Hash ---
    }

    async checkAppointmentsEnabled() {
        try {
            const userId = await window.getUserId();
            if (!userId) return;

            const { data: settings, error } = await window.auth.sb
                .from('appointment_settings')
                .select('is_enabled')
                .eq('user_id', userId)
                .maybeSingle();

            if (error && error.code !== 'PGRST116') {
                console.error('[App] Error al verificar estado de citas:', error);
                return;
            }

            // Si no existe la configuración o está deshabilitada, ocultamos el menú
            const isEnabled = settings ? settings.is_enabled : false;

            const menuItem = document.getElementById('appointments-menu-item');
            if (menuItem) {
                if (isEnabled) menuItem.classList.remove('hidden');
                else menuItem.classList.add('hidden');
            }

            // Mostrar/Ocultar card en el Dashboard
            const dashboardCard = document.getElementById('booking-link-card');
            if (dashboardCard) {
                if (isEnabled) {
                    dashboardCard.classList.remove('hidden');
                    this.renderDashboardBookingLink();
                } else {
                    dashboardCard.classList.add('hidden');
                }
            }
        } catch (error) {
            console.error('[App] Error al verificar estado de citas:', error);
        }
    }

    async renderDashboardBookingLink() {
        const linkInput = document.getElementById('dashboard-booking-link');
        const openLinkBtn = document.getElementById('open-dashboard-link-btn');
        const copyBtn = document.getElementById('copy-dashboard-link-btn');

        if (!linkInput) return;

        try {
            // Usar window.getUserId() para asegurar consistencia (especialmente en suplantación)
            const userId = await window.getUserId();
            if (!userId) return;

            const { data: profile } = await window.auth.sb
                .from('profiles')
                .select('slug, id')
                .eq('id', userId)
                .single();

            if (profile) {
                // Generar URL absoluta
                const linkSuffix = profile.slug || `booking.html?s=${profile.id}`;
                const baseUrl = window.location.origin.replace(/\/$/, '');
                const link = `${baseUrl}/${linkSuffix}`;

                if (linkInput) linkInput.value = link;
                if (openLinkBtn) openLinkBtn.setAttribute('href', link);

                if (copyBtn) {
                    copyBtn.onclick = (e) => {
                        e.preventDefault();
                        navigator.clipboard.writeText(link);
                        window.showToast?.('Link copiado', 'success');

                        const icon = copyBtn.querySelector('i');
                        if (icon) {
                            const original = icon.getAttribute('data-lucide');
                            icon.setAttribute('data-lucide', 'check');
                            lucide.createIcons({ nodes: [icon] });
                            setTimeout(() => {
                                icon.setAttribute('data-lucide', original);
                                lucide.createIcons({ nodes: [icon] });
                            }, 2000);
                        }
                    };
                }
            }
        } catch (e) {
            console.error('Error rendering dashboard booking link', e);
        }
    }

    setupEventListeners() {
        // Navegación principal
        document.querySelectorAll('.nav-link[data-target]').forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                this.switchPanel(link.dataset.target);
            });
        });

        // Event listeners para grupos (cuando se hace clic en el título del grupo)
        document.querySelectorAll('.nav-link[data-group]').forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const groupId = link.dataset.group;
                const defaultTab = link.dataset.groupDefault || this.getDefaultTabForGroup(groupId);
                if (defaultTab) {
                    this.switchPanel(defaultTab, { groupId, tabId: defaultTab });
                }
            });
        });

        // Event listeners para pestañas de grupos
        document.querySelectorAll('.group-tab[data-target]').forEach(tab => {
            tab.addEventListener('click', (e) => {
                e.preventDefault();
                const targetId = tab.dataset.target;
                const groupId = tab.closest('[data-group-container]')?.dataset.groupContainer;
                if (targetId && groupId) {
                    this.switchPanel(targetId, { groupId, tabId: tab.dataset.tab });
                }
            });
        });

        // Botón de logout
        document.getElementById('logout-btn')?.addEventListener('click', (e) => {
            e.preventDefault();
            auth.handleLogout();
        });

        // Formulario de Prompt
        document.getElementById('prompt-form')?.addEventListener('submit', this.handlePromptSave);

        // Botón de mejora de IA en el prompt principal
        document.getElementById('main-prompt-ai-enhance-btn')?.addEventListener('click', () => {
            const textarea = document.getElementById('ai-master-prompt');
            if (textarea.value) {
                // Usar contexto 'behavior_prompt' para prompts de comportamiento del asistente
                this.openAiEnhanceModal(textarea.value, (newText) => {
                    textarea.value = newText;
                }, 'behavior_prompt');
            }
        });
        document.getElementById('remake-prompt-btn')?.addEventListener('click', () => {
            this.wizard.start(true); // true para saltar al paso de Q&A
        });

        // Botón de historial de versiones
        document.getElementById('view-history-btn')?.addEventListener('click', this.openPromptHistory);
        document.getElementById('close-history-modal-btn')?.addEventListener('click', this.closePromptHistory);

        // Botón de QR de WhatsApp
        document.getElementById('request-qr-btn')?.addEventListener('click', this.checkWhatsappConnection);

        // Enlace a Chatwoot
        document.getElementById('chatwoot-link')?.addEventListener('click', this.openChatwoot);

        // Botón de menú móvil
        document.getElementById('mobile-menu-btn')?.addEventListener('click', () => {
            const sidebar = document.getElementById('main-sidebar');
            sidebar?.classList.add('open'); // CORRECCIÓN: Siempre abre, no alterna
        });

        // --- INICIO: Listener para el modal de ayuda del prompt ---
        document.getElementById('prompt-help-btn')?.addEventListener('click', () => document.getElementById('prompt-help-modal')?.classList.remove('hidden'));
        document.getElementById('close-prompt-help-btn')?.addEventListener('click', () => document.getElementById('prompt-help-modal')?.classList.add('hidden'));

        // --- INICIO: Listeners para el nuevo Wizard ---
        document.getElementById('start-wizard-btn')?.addEventListener('click', () => this.wizard.start());

        // --- CORRECCIÓN: Añadir listener para el nuevo botón de cerrar ---
        document.getElementById('close-sidebar-btn')?.addEventListener('click', () => {
            const sidebar = document.getElementById('main-sidebar');
            sidebar?.classList.remove('open');
        });

        document.getElementById('open-tutorials-btn')?.addEventListener('click', () => this.openTutorialsModal());
        // Carrusel de YouTube
        this.setupYoutubeCarousel();

        // --- CORRECCIÓN: Centralizar todos los listeners del modal de IA aquí ---
        document.getElementById('cancel-ai-btn')?.addEventListener('click', () => this.closeAiModal());
        document.getElementById('generate-ai-btn')?.addEventListener('click', () => this.handleGenerateAi());
        // --- INICIO: CORRECCIÓN para que el botón de regenerar funcione ---
        // El botón de regenerar debe llamar a la misma función que el de generar.
        const regenerateBtn = document.getElementById('regenerate-ai-btn');
        if (regenerateBtn) {
            regenerateBtn.addEventListener('click', () => this.handleGenerateAi(true)); // true para indicar que es una regeneración
        }
        // --- FIN: CORRECCIÓN ---
        document.getElementById('regenerate-ai-btn')?.addEventListener('click', () => this.handleGenerateAi());
        document.getElementById('apply-ai-btn')?.addEventListener('click', () => this.handleApplyAi());
        document.getElementById('toggle-sidebar-collapse-btn')?.addEventListener('click', () => this.toggleSidebarCollapsed());

        // --- INICIO: Listeners para el modal de pricing ---
        document.getElementById('cancel-pricing-modal-btn')?.addEventListener('click', () => this.closePricingModal());

        // Listener für die Pricing-Modal-Buttons (usando delegación de eventos)
        const pricingModal = document.getElementById('pricing-modal');
        if (pricingModal) {
            pricingModal.addEventListener('click', (e) => {
                const upgradeBtn = e.target.closest('.upgrade-btn');
                if (upgradeBtn) {
                    e.preventDefault();
                    const planId = upgradeBtn.dataset.plan;
                    if (planId) {
                        this.handleUpgradeClick(planId);
                    }
                }
            });
        }
        // --- FIN: Listeners para el modal de pricing ---

        // --- Listeners para Configuración Rápida de Citas (Nuevo) ---
        document.getElementById('close-appointments-config-modal-btn')?.addEventListener('click', () => {
            document.getElementById('appointments-quick-config-modal')?.classList.add('hidden');
        });
        document.getElementById('cancel-appointments-config-btn')?.addEventListener('click', () => {
            document.getElementById('appointments-quick-config-modal')?.classList.add('hidden');
        });
        document.getElementById('save-appointments-config-btn')?.addEventListener('click', () => this.handleSaveAppointmentsConfig());

        document.getElementById('open-full-settings-btn')?.addEventListener('click', () => {
            document.getElementById('appointments-quick-config-modal')?.classList.add('hidden');
            // Si existe un panel de configuración, cambiar a él
            if (document.getElementById('settings')) {
                this.switchPanel('settings');
            } else {
                // Fallback si no hay panel settings explícito
                window.showToast('Abriendo configuración completa...', 'info');
            }
        });

        document.getElementById('open-products-btn')?.addEventListener('click', () => {
            document.getElementById('appointments-quick-config-modal')?.classList.add('hidden');
            this.switchPanel('products');
        });

        document.getElementById('refresh-hours-btn')?.addEventListener('click', () => {
            // Aquí iría la lógica para recargar horas si fuera dinámico
            window.showToast('Horarios actualizados', 'success');
        });

    }

    checkImpersonation() {
        const impersonatedUserInfo = JSON.parse(localStorage.getItem('impersonated_user_info') || 'null');
        const superadminSessionData = localStorage.getItem('superadmin_session_tokens');

        if (!impersonatedUserInfo) {
            document.body.style.paddingTop = '0';
            return;
        }
        if (!superadminSessionData) {
            localStorage.removeItem('impersonated_user_info');
            document.body.style.paddingTop = '0';
            return;
        }

        if (document.getElementById('impersonation-bar')) {
            return; // Evita duplicados
        }

        if (impersonatedUserInfo) {
            const impersonationBar = document.createElement('div');
            impersonationBar.id = 'impersonation-bar';
            impersonationBar.className = 'fixed top-0 left-0 w-full bg-amber-500 text-black font-bold text-xs p-1 text-center z-[200] flex justify-center items-center gap-2';
            impersonationBar.innerHTML = `
                <span>Estás viendo como <strong>${impersonatedUserInfo.email}</strong>.</span>
                <button id="stop-impersonating-btn" class="bg-slate-800 text-white py-0.5 px-2 rounded hover:bg-slate-700 text-xs">Volver a Super Admin</button>
            `;
            document.body.prepend(impersonationBar);
            document.body.style.paddingTop = '0'; // No empujar el contenido

            document.getElementById('stop-impersonating-btn').addEventListener('click', async () => {
                try {
                    // Restaurar la sesión original del superadmin
                    const originalSession = JSON.parse(localStorage.getItem('superadmin_session_tokens') || 'null');
                    if (!originalSession?.access_token || !originalSession?.refresh_token) {
                        throw new Error('Sesión original inválida. Por favor, inicia sesión nuevamente.');
                    }
                    await window.auth.sb.auth.setSession(originalSession);

                    // Limpiar la información de suplantación y recargar
                    localStorage.removeItem('impersonated_user_info');
                    localStorage.removeItem('superadmin_session_tokens');

                    document.body.style.paddingTop = '0'; // Resetear el padding
                    window.location.reload(); // Recargar para limpiar el estado de suplantación
                } catch (e) {
                    console.error("Error al detener la suplantación:", e);
                    alert("No se pudo volver a la sesión de superadmin. Por favor, cierra sesión y vuelve a entrar.");
                }
            });
        }
    }

    loadInitialData() {
        this.fetchUserProfile();
        this.fetchMasterPrompt();
        this.loadDashboardMetrics(); // Cargar y renderizar métricas del dashboard
        this.loadFunnelMetrics();

        // Cargar datos de suscripción y equipo en paralelo
        Promise.all([
            this.loadUserSubscription(),
            this.loadTeamInfo()
        ]).then(([userPlan, teamInfo]) => {
            this.renderUserPlanBadge(userPlan);
            this.renderUpgradeButtons(userPlan);
            // --- INICIO: CORRECCIÓN - Desacoplar applyFeatureRestrictions ---
            // Ahora, en lugar de llamar a la función directamente, escuchamos el evento
            // 'panel:activated' para aplicar las restricciones solo cuando un panel se muestra.
            document.addEventListener('panel:activated', () => this.applyFeatureRestrictions(userPlan, teamInfo));
            // --- FIN: CORRECCIÓN ---
        });

        this.renderWhatsappConnection('initial');
    }

    openTutorialsModal() { // CORRECCIÓN: Mover la función dentro de la clase
        // Esta función podría abrir un modal más grande con la playlist de YouTube.
        // Por ahora, simplemente simula un clic en el enlace del dashboard anterior.
        const videoUrl = "https://www.youtube.com/embed/videoseries?list=PLDs44uukbe3FIDa9CttQLh8N-Nfdpo_hG&autoplay=1";
        const viewer = document.getElementById('image-viewer-modal');
        const content = document.getElementById('image-viewer-content');
        // CORRECCIÓN: Usar innerHTML para no reemplazar el contenedor y su botón de cierre.
        content.innerHTML = `<iframe class="w-full h-full" src="${videoUrl}" title="Tutoriales ELINA IA" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>`;
        viewer.classList.remove('hidden');
    }

    // --- Lógica para colapsar/expandir el sidebar ---
    toggleSidebarCollapsed() {
        const sidebar = document.getElementById('main-sidebar');
        if (!sidebar) return;

        const isCollapsed = sidebar.classList.toggle('sidebar-collapsed');
        this.setSidebarCollapsed(isCollapsed);
        localStorage.setItem('sidebarCollapsed', isCollapsed); // Guardar preferencia
    }

    setSidebarCollapsed(collapsed) {
        const sidebar = document.getElementById('main-sidebar');
        const mainContent = document.getElementById('main-content-area');
        const toggleBtn = document.getElementById('toggle-sidebar-collapse-btn');
        if (!sidebar || !mainContent || !toggleBtn) return;

        if (collapsed) {
            sidebar.classList.add('sidebar-collapsed');
            toggleBtn.classList.add('collapsed');
        } else {
            sidebar.classList.remove('sidebar-collapsed');
            toggleBtn.classList.remove('collapsed');
        }
        const icon = toggleBtn.querySelector('i');
        if (icon) icon.setAttribute('data-lucide', collapsed ? 'chevron-right' : 'chevron-left');
        lucide.createIcons({ nodes: [icon] });
    }

    async switchPanel(targetId, options = {}) { // CORRECCIÓN: Lógica para modo pantalla completa de Kanban
        const sidebar = document.getElementById('main-sidebar');
        const mainContent = document.getElementById('main-content-area');
        const toggleBtn = document.getElementById('toggle-sidebar-collapse-btn');

        // Cargar contenido dinámico si es necesario antes de activar el panel
        await this.loadPanelContent(targetId);

        const panel = document.getElementById(targetId);
        if (!panel) {
            console.error(`[Dashboard] Panel con ID '${targetId}' no encontrado en el DOM.`);
            return;
        }

        console.log(`[Dashboard] Cambiando a panel: ${targetId}`);

        // Ocultar todos los paneles
        document.querySelectorAll('.content-panel').forEach(p => p.classList.remove('active'));

        // Obtener información del grupo y pestaña si existe
        const activeLink = document.querySelector(`.nav-link[data-target="${targetId}"]`);
        const groupId = options.groupId || activeLink?.dataset.group;
        const tabId = options.tabId || activeLink?.dataset.tab;

        // --- INICIO: Integración del Panel de Afiliados ---
        if (targetId === 'affiliate-panel') {
            await initAffiliatePanel();
        }
        // --- FIN: Integración del Panel de Afiliados ---

        // Configuración de grupos
        const groupConfig = {
            'campaigns': {
                tabs: [
                    { id: 'bulk-sending', label: 'Envío Masivo', default: true },
                    { id: 'follow-ups', label: 'Seguimientos' },
                    { id: 'auto-responses', label: 'Respuestas Programadas' },
                    { id: 'templates', label: 'Plantillas' }
                ]
            },
            'clients': {
                tabs: [
                    { id: 'contacts', label: 'Contactos', default: true },
                    { id: 'kanban', label: 'Kanban' },
                    { id: 'quotes', label: 'Cotizaciones' }
                ]
            },
            'ai-behavior': {
                tabs: [
                    { id: 'prompt-training', label: 'Entrenamiento Prompt', default: true },
                    { id: 'ai-memory', label: 'Asistente IA' },
                    { id: 'ai-flows', label: 'Flujos Personalizados' },
                    { id: 'smart-promotions', label: 'Promos Inteligentes' },
                    { id: 'sales-context', label: 'Contexto de Ventas' }
                ]
            },
            'marketing': {
                tabs: [
                    { id: 'designer-ai', label: 'Diseñador Gráfico IA', default: true },
                    { id: 'video-ai', label: 'Video IA' },
                    { id: 'community-manager', label: 'Community Manager' }
                ]
            }
        };

        // Si pertenece a un grupo, crear pestañas dinámicamente
        if (groupId && groupConfig[groupId] && panel) {
            this.createGroupTabs(groupId, groupConfig[groupId], tabId || targetId, panel);
        }

        if (panel) {
            if (targetId === 'kanban') {
                // MODO PANTALLA COMPLETA PARA KANBAN
                sidebar.classList.add('hidden');
                toggleBtn.style.display = 'none';
            } else {
                // MODO NORMAL PARA OTROS PANELES
                sidebar.classList.remove('hidden');
                toggleBtn.style.display = '';
            }

            // El layout flex se encarga del posicionamiento automáticamente
            panel.classList.add('active');

            // Guarda el panel activo en localStorage
            localStorage.setItem('activePanelId', targetId);
            if (groupId) localStorage.setItem(`activeGroup_${groupId}`, tabId || targetId);

            // Disparar evento de activación
            document.dispatchEvent(new CustomEvent('panel:activated', { detail: { panelId: targetId, options, groupId, tabId } }));

            // Cerrar el menú lateral en móvil
            if (sidebar && sidebar.classList.contains('open')) {
                sidebar.classList.remove('open');
            }
        }

        // Actualizar estilos de navegación
        const activeClasses = ['bg-green-500', 'text-white'];
        document.querySelectorAll('.nav-link[data-target]').forEach(l => l.classList.remove(...activeClasses));
        document.querySelectorAll('.nav-link[data-group]').forEach(l => l.classList.remove(...activeClasses));

        // Si es un grupo, destacar el link del grupo en el menú
        if (groupId) {
            const groupLink = document.querySelector(`.nav-link[data-group="${groupId}"]`);
            if (groupLink) {
                groupLink.classList.add(...activeClasses);
            }
        } else if (activeLink) {
            activeLink.classList.add(...activeClasses);
        }

        // Actualizar pestañas activas si hay grupo
        if (groupId && panel) {
            const tabsContainer = panel.querySelector('.group-tabs-container');
            if (tabsContainer) {
                tabsContainer.querySelectorAll('.group-tab').forEach(tab => {
                    tab.classList.remove('active');
                    if (tab.dataset.tab === (tabId || targetId)) {
                        tab.classList.add('active');
                    }
                });
            }
        }
    }

    getDefaultTabForGroup(groupId) {
        const defaults = {
            'campaigns': 'bulk-sending',
            'clients': 'contacts',
            'ai-behavior': 'prompt-training',
            'marketing': 'designer-ai'
        };
        return defaults[groupId] || null;
    }

    createGroupTabs(groupId, config, activeTabId, panel) {
        // Eliminar pestañas anteriores si existen
        const existingTabs = panel.querySelector('.group-tabs-container');
        if (existingTabs) existingTabs.remove();

        // Crear contenedor de pestañas
        const tabsContainer = document.createElement('div');
        tabsContainer.className = 'group-tabs-container mb-6';

        const tabsDiv = document.createElement('div');
        tabsDiv.className = 'group-tabs';

        // Crear botones de pestañas
        config.tabs.forEach(tab => {
            const tabBtn = document.createElement('button');
            tabBtn.className = `group-tab ${tab.id === activeTabId ? 'active' : ''}`;
            tabBtn.textContent = tab.label;
            tabBtn.dataset.tab = tab.id;
            tabBtn.dataset.target = tab.id;
            tabBtn.addEventListener('click', (e) => {
                e.preventDefault();
                this.switchPanel(tab.id, { groupId, tabId: tab.id });
            });
            tabsDiv.appendChild(tabBtn);
        });

        tabsContainer.appendChild(tabsDiv);

        // Insertar pestañas al inicio del panel
        panel.insertBefore(tabsContainer, panel.firstChild);
    }

    async loadPanelContent(panelId) {
        const panel = document.getElementById(panelId);
        if (!panel) return;

        // Si el panel ya tiene contenido (no está vacío) y no tiene data-force-load, no cargamos nada
        const isActuallyEmpty = panel.innerHTML.trim().length === 0 || panel.dataset.placeholder === 'true';

        const panelFiles = {
            'settings': 'settings.html',
            // 'appointments': 'appointments.html', // Ya integrado en dashboard.html
            'designer-ai': 'designer-ai.html',
            'video-ai': 'video-ai.html',
            'products': 'products.html',
            'chats': 'chats.html',
            'kanban': 'kanban.html',
            'bulk-sending': 'bulk-sending.html',
            'templates': 'templates.html',
            'smart-labels': 'smart-labels.html'
        };

        const fileName = panelFiles[panelId];
        if (!fileName) return;

        if (isActuallyEmpty || panel.dataset.forceLoad === 'true') {
            try {
                console.log(`[Dashboard] Cargando contenido para ${panelId} desde ${fileName}...`);
                const response = await fetch(fileName);
                if (response.ok) {
                    const html = await response.text();
                    panel.innerHTML = html;
                    panel.dataset.placeholder = 'false';
                    panel.dataset.forceLoad = 'false';

                    if (window.lucide) {
                        window.lucide.createIcons({
                            attrs: { class: 'lucide-icon' },
                            nameAttr: 'data-lucide'
                        });
                    }
                    document.dispatchEvent(new CustomEvent('panel:loaded', { detail: { panelId } }));
                }
            } catch (error) {
                console.error(`[Dashboard] Error al cargar ${fileName}:`, error);
            }
        }
    }


    listenForProfileChanges() {
        const channel = auth.sb.channel(`profile-changes:${this.user.id}`)
            .on(
                'postgres_changes',
                { event: 'UPDATE', schema: 'public', table: 'profiles', filter: `id=eq.${this.user.id}` },
                (payload) => {
                    const { whatsapp_connected, sync_status } = payload.new;
                    document.dispatchEvent(new CustomEvent('profile:updated', { detail: { whatsapp_connected, sync_status } }));
                }
            )
            .subscribe();
    }

    async loadUserSubscription() {
        try {
            // Verificar acceso de cuenta primero (si la función existe)
            let accessCheck = null;
            try {
                const { data, error: accessError } = await auth.sb.rpc('check_account_access', {
                    p_user_id: this.user.id
                });
                if (accessError && accessError.code !== 'PGRST202') {
                    // Solo loguear errores que no sean "función no encontrada"
                    console.error("Error al verificar acceso de cuenta:", accessError);
                } else if (!accessError) {
                    accessCheck = data;
                }
            } catch (e) {
                // Si la función no existe, continuar sin verificación
                if (e.code !== 'PGRST202') {
                    console.error("Error al verificar acceso de cuenta:", e);
                }
            }

            if (accessCheck && accessCheck.blocked) {
                // Mostrar mensaje de bloqueo
                window.showToast(accessCheck.reason || 'Tu cuenta está bloqueada. Por favor, contacta con soporte.', 'error');
                // Retornar información de bloqueo
                return {
                    blocked: true,
                    reason: accessCheck.reason,
                    status: accessCheck.status,
                    plan_id: accessCheck.plan_id
                };
            }

            const { data: subscription, error: subError } = await auth.sb
                .from('subscriptions')
                .select('status, plan_id, plans:plan_id(*)')
                .eq('user_id', this.user.id)
                .limit(1)
                .single();

            if (subError && subError.code !== 'PGRST116') throw subError;

            if (subscription && subscription.plan_id === 'free_trial' && subscription.status === 'trialing') {
                const { data: profile } = await auth.sb.from('profiles').select('stripe_customer_id').eq('id', this.user.id).single();
                if (profile && profile.stripe_customer_id) {
                    const { data: stripeSub, error: functionError } = await window.auth.invokeFunction('get-stripe-subscription', { body: { customerId: profile.stripe_customer_id } });
                    if (functionError) throw functionError;
                    if (stripeSub && stripeSub.planId) {
                        subscription.plan_id = stripeSub.planId;
                        subscription.plans.name = stripeSub.planName;
                        subscription.plans.features = stripeSub.features;
                    }
                }
            }

            // Verificar bloqueo de cuenta
            try {
                const { data: accessCheck, error: accessError } = await auth.sb.rpc('check_account_access', { p_user_id: this.user.id });
                if (!accessError && accessCheck && accessCheck.blocked) {
                    subscription.blocked = true;
                    subscription.blockedReason = accessCheck.reason;
                    // Mostrar notificación de bloqueo
                    window.showToast(accessCheck.reason || 'Tu cuenta está bloqueada. Por favor, contacta con soporte.', 'error');
                }
            } catch (e) {
                // Si la función no existe aún, no hacer nada
                if (e.code !== 'PGRST202') {
                    console.warn('Error al verificar acceso de cuenta:', e);
                }
            }

            return subscription;
        } catch (e) {
            console.error("Error al cargar la suscripción del usuario:", e);
            return null;
        }
    }

    async loadTeamInfo() {
        try {
            const { data, error } = await auth.sb.rpc('get_user_team_info_with_permissions', { p_user_id: this.user.id });
            if (error) throw error;

            if (data && data.length > 0) {
                this.teamInfo = data[0];
            }
            return this.teamInfo;
        } catch (e) {
            console.error("Error al cargar la información del equipo:", e);
            return null;
        }
    }

    async processInvitationFromURL() {
        try {
            // Obtener parámetro invitation de la URL
            const urlParams = new URLSearchParams(window.location.search);
            const invitationId = urlParams.get('invitation');

            if (!invitationId) {
                return; // No hay invitación en la URL
            }

            console.log('[App] Procesando invitación desde URL:', invitationId);

            // Verificar que la invitación existe y está pendiente
            const { data: invitation, error: inviteError } = await auth.sb
                .from('team_invitations')
                .select('id, team_id, email, role, status, expires_at')
                .eq('id', invitationId)
                .eq('status', 'pending')
                .single();

            if (inviteError || !invitation) {
                console.warn('[App] Invitación no encontrada o ya procesada:', inviteError);
                // Limpiar parámetro de la URL
                urlParams.delete('invitation');
                window.history.replaceState({}, '', `${window.location.pathname}${urlParams.toString() ? '?' + urlParams.toString() : ''}`);
                return;
            }

            // Verificar que no haya expirado
            if (new Date(invitation.expires_at) < new Date()) {
                console.warn('[App] Invitación expirada');
                window.showToast?.('Esta invitación ha expirado. Contacta al administrador para una nueva invitación.', 'error');
                urlParams.delete('invitation');
                window.history.replaceState({}, '', `${window.location.pathname}${urlParams.toString() ? '?' + urlParams.toString() : ''}`);
                return;
            }

            // Verificar que el email del usuario coincida con el de la invitación
            const userEmail = this.user.email;
            if (userEmail.toLowerCase() !== invitation.email.toLowerCase()) {
                console.warn('[App] Email del usuario no coincide con la invitación');
                window.showToast?.('El correo de esta invitación no coincide con tu cuenta. Por favor, inicia sesión con el correo correcto.', 'error');
                urlParams.delete('invitation');
                window.history.replaceState({}, '', `${window.location.pathname}${urlParams.toString() ? '?' + urlParams.toString() : ''}`);
                return;
            }

            // Verificar si el usuario ya es miembro del equipo
            const { data: existingMember } = await auth.sb
                .from('team_members')
                .select('*')
                .eq('team_id', invitation.team_id)
                .eq('user_id', this.user.id)
                .single();

            if (existingMember) {
                // Ya es miembro, solo marcar invitación como aceptada
                console.log('[App] Usuario ya es miembro del equipo, marcando invitación como aceptada');
                await auth.sb
                    .from('team_invitations')
                    .update({
                        status: 'accepted',
                        accepted_at: new Date().toISOString()
                    })
                    .eq('id', invitationId);

                window.showToast?.('¡Bienvenido al equipo! Ya eres miembro.', 'success');
            } else {
                // Agregar usuario al equipo
                console.log('[App] Agregando usuario al equipo');
                const { error: addError } = await auth.sb
                    .from('team_members')
                    .insert({
                        team_id: invitation.team_id,
                        user_id: this.user.id,
                        role: invitation.role,
                        permissions: invitation.role === 'advisor' ? {
                            'chats': true,
                            'follow-ups': true,
                            'kanban': true,
                            'contacts': false,
                            'label_filters': {}
                        } : {}
                    });

                if (addError) {
                    console.error('[App] Error al agregar usuario al equipo:', addError);
                    window.showToast?.('Error al procesar la invitación. Por favor, contacta al administrador.', 'error');
                    return;
                }

                // Marcar invitación como aceptada
                await auth.sb
                    .from('team_invitations')
                    .update({
                        status: 'accepted',
                        accepted_at: new Date().toISOString()
                    })
                    .eq('id', invitationId);

                // Recargar información del equipo
                await this.loadTeamInfo();

                window.showToast?.('¡Bienvenido al equipo! Has sido agregado exitosamente.', 'success');
            }

            // Limpiar parámetro de la URL
            urlParams.delete('invitation');
            window.history.replaceState({}, '', `${window.location.pathname}${urlParams.toString() ? '?' + urlParams.toString() : ''}`);

        } catch (e) {
            console.error('[App] Error al procesar invitación:', e);
            window.showToast?.('Error al procesar la invitación. Por favor, contacta al administrador.', 'error');
        }
    }

    async loadUserUsage() {
        // --- CORRECCIÓN: La función ahora devuelve el uso en lugar de asignarlo a window ---
        try { // CORRECCIÓN: La función ahora devuelve el uso en lugar de asignarlo a window
            const { data, error } = await window.auth.sb
                .from('profiles')
                .select('ai_enhancements_used, image_generations_used, bulk_sends_used')
                .eq('id', this.user.id)
                .single();
            if (error) throw error;
            return data;
        } catch (e) {
            console.error("Error al cargar el uso del usuario:", e);
            return { ai_enhancements_used: 0, image_generations_used: 0, bulk_sends_used: 0 };
        }
    }

    async renderUsageAndLimits() {
        // CORRECCIÓN: Reescribir la función para ser robusta y no depender de variables globales
        const [userPlan, userUsage] = await Promise.all([this.loadUserSubscription(), this.loadUserUsage()]);

        if (userPlan) { // teamInfo ya está cargado en this.teamInfo
            this.renderUserPlanBadge(userPlan);
            this.renderUpgradeButtons(userPlan);
            this.applyFeatureRestrictions(userPlan, this.teamInfo);
        } else {
            // CORRECCIÓN: Si no hay suscripción, asignar plan gratuito por defecto
            console.warn('El usuario no tiene una suscripción registrada.');
        }

        const imageGenLimit = userPlan?.plans?.image_generations_limit || 0;
        const imageGenUsed = userUsage?.image_generations_used || 0;
        // --- CORRECCIÓN: Usar un evento para desacoplar la actualización ---
        // --- INICIO: Log para verificar datos de uso ---
        console.log('[Uso Verificado]', { imageGenerations: { used: imageGenUsed, limit: imageGenLimit } });
        // --- FIN: Log para verificar datos de uso ---

        // En lugar de buscar el elemento, disparamos un evento con los datos.
        // Otros módulos (como designer-ai.js) escucharán este evento y se actualizarán.
        document.dispatchEvent(new CustomEvent('usage:updated', {
            detail: {
                imageGenerations: {
                    remaining: imageGenLimit - imageGenUsed, // <-- CORRECCIÓN: Enviar los usos restantes
                    limit: imageGenLimit
                }
            }
        }));
    }

    renderUserPlanBadge(userPlan) {
        const badgeEl = document.getElementById('user-plan-badge');
        if (!badgeEl || !userPlan) return;

        const planId = userPlan.plan_id || 'unknown';
        // Usamos el nombre del plan desde la DB si existe, si no, formateamos el ID.
        const planName = userPlan.plans?.name || planId.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase());

        let bgColor = 'bg-slate-200';
        let textColor = 'text-slate-700';

        switch (planId) {
            case 'free_trial': bgColor = 'bg-blue-100'; textColor = 'text-blue-800'; break;
            case 'starter': bgColor = 'bg-green-100'; textColor = 'text-green-800'; break;
            case 'grow': bgColor = 'bg-purple-100'; textColor = 'text-purple-800'; break;
            case 'business': bgColor = 'bg-slate-200'; textColor = 'text-slate-800'; break;
        }
        badgeEl.textContent = planName;
        badgeEl.className = `inline-block text-xs font-bold px-2 py-0.5 rounded-md mt-1.5 ${bgColor} ${textColor}`;
    }

    applyFeatureRestrictions(userPlan, teamInfo) {
        if (!userPlan || !userPlan.plans) return;

        const features = userPlan.plans.features || {};
        const userRole = teamInfo?.user_role;

        // Restricción de Seguimientos (solo si el panel está activo)
        const followUpsPanel = document.getElementById('follow-ups');
        // La lógica se ejecuta solo si el panel está activo y tiene contenido.
        if (followUpsPanel?.classList.contains('active') && followUpsPanel.querySelector('#follow-ups-container')) {
            const followUpsContainer = followUpsPanel.querySelector('#follow-ups-container');
            const followUpsAccessDenied = followUpsPanel.querySelector('#follow-ups-access-denied');
            if (features.follow_ups) {
                if (followUpsContainer) followUpsContainer.classList.remove('hidden');
                if (followUpsAccessDenied) followUpsAccessDenied.classList.add('hidden');
            } else {
                if (followUpsContainer) followUpsContainer.classList.add('hidden');
                if (followUpsAccessDenied) followUpsAccessDenied.classList.remove('hidden');
                document.getElementById('upgrade-to-grow-from-followups').onclick = () => this.handleUpgradeClick('grow');
            }
        }

        // Restricción de Diseñador Gráfico IA (solo si el panel está activo)
        const designerPanel = document.getElementById('designer-ai');
        // La lógica se ejecuta solo si el panel está activo y tiene contenido.
        if (designerPanel?.classList.contains('active') && designerPanel.querySelector('#designer-ai-access-denied')) {
            const designerContainer = designerPanel.querySelector('.grid');
            const designerAccessDenied = designerPanel.querySelector('#designer-ai-access-denied');
            const isAllowed = features.designer_ai;
            if (designerContainer) designerContainer.classList.toggle('hidden', !isAllowed);
            if (designerAccessDenied) designerAccessDenied.classList.toggle('hidden', isAllowed);
            if (!isAllowed) document.getElementById('upgrade-to-grow-from-designer').onclick = () => this.handleUpgradeClick('grow');
        }

        // --- INICIO: Lógica de permisos por rol ---
        // Si el usuario es un 'advisor', ocultamos los paneles que no tiene permitidos.
        if (userRole === 'advisor') {
            const userPermissions = teamInfo?.permissions || {};

            document.querySelectorAll('.nav-link[data-target]').forEach(link => {
                const panelId = link.dataset.target;
                if (panelId !== 'dashboard' && !userPermissions[panelId]) {
                    link.parentElement.style.display = 'none';
                }
            });
        }
    }

    renderUpgradeButtons(userPlan) {
        const upgradeSection = document.getElementById('upgrade-plan-section');
        if (!upgradeSection || !userPlan) return; // CORRECCIÓN: Asegurarse de que el plan exista
        const starterToGrowBtn = document.getElementById('upgrade-grow-btn');
        const collapsedBtn = document.getElementById('upgrade-collapsed-btn');
        const trialBtn = document.getElementById('upgrade-trial-btn');
        // Ocultar todo por defecto
        if (starterToGrowBtn) starterToGrowBtn.classList.add('hidden');
        if (trialBtn) trialBtn.classList.add('hidden');
        if (upgradeSection) upgradeSection.classList.add('hidden');
        if (collapsedBtn) {
            collapsedBtn.classList.add('hidden');
        }

        const currentPlanId = userPlan.plan_id;

        if (currentPlanId === 'free_trial') {
            trialBtn.classList.remove('hidden');
            upgradeSection.classList.remove('hidden');
            trialBtn.onclick = () => this.openPricingModal();
            collapsedBtn.onclick = () => this.openPricingModal();
        } else if (currentPlanId === 'starter') {
            starterToGrowBtn.classList.remove('hidden');
            upgradeSection.classList.remove('hidden');
            starterToGrowBtn.onclick = () => this.handleUpgradeClick('grow');
            collapsedBtn.onclick = () => this.handleUpgradeClick('grow');
        }
        // Si es 'grow' o superior, la sección permanecerá oculta.
    }

    openPricingModal() {
        const pricingModal = document.getElementById('pricing-modal');
        if (pricingModal) {
            pricingModal.classList.remove('hidden');
        }
    }

    closePricingModal() {
        const pricingModal = document.getElementById('pricing-modal');
        if (pricingModal) {
            pricingModal.classList.add('hidden');
        }
    }

    async handleUpgradeClick(targetPlanId) {
        const button = document.querySelector(`.upgrade-btn[data-plan="${targetPlanId}"]`) || document.getElementById(`upgrade-${targetPlanId}-btn`);
        if (!button) return; // Si no encuentra el botón, no hace nada
        // CORRECCIÓN: Asegurarse de que el modal de precios se cierre
        // --- CORRECCIÓN: Asegurarse de que el modal de precios se cierre ---
        const pricingModal = document.getElementById('pricing-modal');
        if (pricingModal) {
            pricingModal.classList.add('hidden');
        }
        // --- FIN CORRECCIÓN ---

        const originalText = button.textContent;
        button.disabled = true;
        button.textContent = 'Redirigiendo a pago...';

        try {
            const { data, error } = await window.auth.invokeFunction('create-checkout-session', {
                body: {
                    planId: targetPlanId,
                    userId: this.user.id
                }
            });

            if (error) throw new Error(error.message);
            window.location.href = data.url; // Redirige al usuario a la página de pago de Stripe

        } catch (e) { // <-- CORRECCIÓN: Añadido el bloque catch que faltaba
            console.error('Error al iniciar el proceso de pago:', e);
            window.showToast('No se pudo iniciar el proceso de pago. Por favor, intenta de nuevo.', 'error');
            button.disabled = false;
            button.textContent = originalText;
        } // <-- CORRECCIÓN: Cierre del bloque catch
    }

    // --- Métodos de API y Lógica de Componentes ---

    async fetchUserProfile() {
        const nameEl = document.getElementById('user-business-name');
        const avatarEl = document.getElementById('user-avatar');
        try {
            const { data, error } = await window.auth.sb
                .from('profiles')
                .select('full_name, role, urlfoto')
                .eq('id', this.user.id)
                .single();
            if (error) throw error;

            const fallbackName = this.teamInfo?.team_name || data.full_name || 'Mi negocio';
            const displayName = fallbackName;
            if (nameEl) nameEl.textContent = displayName;

            if (avatarEl) {
                const photoUrl = (data.urlfoto || '').trim();
                avatarEl.src = photoUrl ? photoUrl : `https://ui-avatars.com/api/?background=0A3B66&color=fff&name=${encodeURIComponent(displayName)}`;
                avatarEl.alt = `Logo de ${displayName}`;
            }

            if (data.role === 'superadmin') {
                document.getElementById('superadmin-link')?.classList.remove('hidden');
                document.getElementById('mobile-superadmin-link')?.classList.remove('hidden');
            }
        } catch (error) {
            console.error('Error al cargar el perfil del usuario:', error);
            if (nameEl) nameEl.textContent = 'Mi negocio';
            if (avatarEl) avatarEl.src = 'https://ui-avatars.com/api/?background=0A3B66&color=fff&name=Elina';
        }
    }

    async fetchMasterPrompt() { // Este método ya existe, solo nos aseguramos de que esté bien
        try { // Este método ya existe, solo nos aseguramos de que esté bien
            const { data, error } = await auth.sb
                .from('prompts')
                .select('prompt_content')
                .eq('user_id', this.user.id)
                .single();

            if (error && error.code !== 'PGRST116') throw error; // Ignora el error "no rows found"

            document.getElementById('ai-master-prompt').value = data?.prompt_content || '';

            // Actualizar indicador de versión
            await this.updatePromptVersionIndicator();
        } catch (error) {
            console.error('Error al cargar el prompt:', error);
            document.getElementById('ai-master-prompt').value = 'No se pudo cargar el prompt.';
        }
    }

    async handlePromptSave(e) {
        e.preventDefault(); // Este método ya existe, solo nos aseguramos de que esté bien // CORRECCIÓN: El evento puede no venir de un formulario, buscar el botón de forma más robusta.
        // CORRECCIÓN: El evento puede no venir de un formulario, buscar el botón de forma más robusta.
        const form = document.getElementById('prompt-form');
        if (!form) return;
        const button = form.querySelector('button[type="submit"]');
        const promptText = document.getElementById('ai-master-prompt').value;
        if (!button) return;

        button.disabled = true;
        button.textContent = 'Guardando...';

        try {
            // Obtener prompt anterior para comparar
            const { data: oldPrompt } = await auth.sb
                .from('prompts')
                .select('prompt_content')
                .eq('user_id', this.user.id)
                .single();

            const hasChanged = !oldPrompt || oldPrompt.prompt_content !== promptText;

            // Guardar en tabla prompts (comportamiento original)
            const { error: promptError } = await auth.sb
                .from('prompts')
                .upsert({ user_id: this.user.id, prompt_content: promptText }, { onConflict: 'user_id' });

            if (promptError) throw promptError;

            // Si el prompt cambió O si no hay versiones aún, crear nueva versión
            let shouldCreateVersion = hasChanged;
            if (!shouldCreateVersion) {
                const { count, error: countErr } = await auth.sb
                    .from('prompt_versions')
                    .select('*', { count: 'exact', head: true })
                    .eq('user_id', this.user.id);

                if (count === 0 && !countErr) shouldCreateVersion = true;
            }

            if (shouldCreateVersion) {
                try {
                    const changeReason = document.getElementById('prompt-change-reason')?.value?.trim() || (hasChanged ? 'Cambio manual' : 'Versión inicial');

                    const { error: rpcErr } = await auth.sb.rpc('create_prompt_version', {
                        p_user_id: this.user.id,
                        p_prompt_content: promptText,
                        p_change_reason: changeReason
                    });

                    if (rpcErr) console.warn('Error RPC al crear versión:', rpcErr);
                } catch (versionErr) {
                    console.warn('Error al crear versión del prompt:', versionErr);
                }
            }



            window.showToast('Prompt guardado con éxito.', 'success');

            // Actualizar indicador de versión si existe
            this.updatePromptVersionIndicator();
        } catch (error) {
            console.error('Error al guardar el prompt:', error);
            window.showToast('Error al guardar el prompt. Revisa la consola.', 'error');
        } finally {
            button.disabled = false;
            button.textContent = 'Guardar';
        }
    }

    async updatePromptVersionIndicator() {
        try {
            // Obtener versión actual del prompt
            const { data: versionData, error } = await auth.sb
                .rpc('get_current_prompt_version', { p_user_id: this.user.id });

            if (error) {
                // Si la función no existe aún, no mostrar error
                if (error.code !== '42883') { // 42883 = function does not exist
                    console.warn('No se pudo obtener versión del prompt:', error);
                }
                return;
            }

            // Actualizar indicador en dashboard si existe
            const versionIndicator = document.getElementById('prompt-version-indicator');
            if (versionIndicator && versionData && versionData.length > 0) {
                const version = versionData[0];
                versionIndicator.textContent = `v${version.version_number}`;
                versionIndicator.title = `Versión ${version.version_number} - ${new Date(version.created_at).toLocaleDateString()}`;
            }
        } catch (err) {
            console.warn('Error al actualizar indicador de versión:', err);
        }
    }

    async handleSaveAppointmentsConfig() {
        // Implementación básica para guardar la configuración rápida
        const modal = document.getElementById('appointments-quick-config-modal');
        const bufferTime = document.getElementById('quick-config-buffer-time')?.value;
        const maxPerDay = document.getElementById('quick-config-max-per-day')?.value;
        const defaultDuration = document.getElementById('quick-config-default-duration')?.value;
        const timezone = document.getElementById('quick-config-timezone')?.value;

        try {
            const updates = {
                user_id: this.user.id,
                buffer_time_minutes: bufferTime ? parseInt(bufferTime) : 0,
                default_duration_minutes: defaultDuration ? parseInt(defaultDuration) : 60,
                timezone: timezone || 'America/Mexico_City',
                // max_per_day podría requerir una columna específica o configuración JSON
            };

            const { error } = await window.auth.sb
                .from('appointment_settings')
                .upsert(updates, { onConflict: 'user_id' });

            if (error) throw error;

            window.showToast('Configuración de citas guardada.', 'success');
            modal.classList.add('hidden');

            // Recargar configuración local si es necesario
            // this.loadAppointmentSettings(); 

        } catch (e) {
            console.error('Error guardando configuración de citas:', e);
            window.showToast('Error al guardar configuración.', 'error');
        }
    }

    /**
     * Sube un archivo a un almacenamiento temporal, lo transfiere a la CDN (Bunny.net)
     * a través de una Edge Function y devuelve la URL final de la CDN.
     * @param {File} file - El archivo a subir.
     * @param {string} folder - La carpeta de destino dentro del bucket del usuario (ej. 'logos', 'follow-ups').
     * @param {Function} onProgress - Callback opcional para reportar progreso (0-100).
     * @returns {Promise<string|null>} La URL pública de la CDN o null si falla.
     */
    /**
     * Sube un archivo a un almacenamiento temporal, lo transfiere a la CDN (Bunny.net)
     * a través de una Edge Function y devuelve la URL final de la CDN.
     * @param {File} file - El archivo a subir.
     * @param {string} folder - La carpeta de destino dentro del bucket del usuario (ej. 'logos', 'follow-ups').
     * @param {Function} onProgress - Callback opcional para reportar progreso (0-100).
     * @returns {Promise<string|null>} La URL pública de la CDN o null si falla.
     */
    async uploadAsset(file, folder, onProgress) { // CORRECCIÓN: Usar window.auth.sb para la instancia de Supabase
        if (!file) return null;

        // --- OPTIMIZACIÓN DE IMÁGENES ---
        // Si es una imagen, la comprimimos antes de subirla para ahorrar ancho de banda y almacenamiento
        if (file.type.startsWith('image/')) {
            try {
                if (onProgress) onProgress(5); // Indicar inicio de proceso
                console.log('[Upload] Optimizando imagen...', file.name);
                file = await this.compressImage(file);
                console.log('[Upload] Imagen optimizada.', { size: file.size, type: file.type });
            } catch (e) {
                console.warn('[Upload] Falló la compresión de imagen, se usará el original:', e);
            }
        }

        const userId = await window.getUserId();
        const userEmail = await window.getUserEmail();

        // Preservar la extensión original del archivo (o usar .webp si fue optimizado)
        const originalName = file.name;
        const lastDotIndex = originalName.lastIndexOf('.');
        let extension = lastDotIndex > 0 ? originalName.substring(lastDotIndex) : '';
        const nameWithoutExt = lastDotIndex > 0 ? originalName.substring(0, lastDotIndex) : originalName;

        // Si el archivo ahora es image/webp (por la compresión), aseguramos la extensión correcta
        if (file.type === 'image/webp' && extension !== '.webp') {
            extension = '.webp';
        }

        // Crear nombre seguro pero preservando la extensión
        const safeName = nameWithoutExt.replace(/[^a-zA-Z0-9._-]/g, '_') + extension;
        const tempPath = `temp-uploads/${userId}/${folder}/${Date.now()}-${safeName}`;

        try {
            // Reportar progreso inicial
            if (onProgress) onProgress(10);

            // 1. Subir a una carpeta temporal en Supabase Storage
            const { error: uploadError } = await window.auth.sb.storage.from('campaign_files').upload(tempPath, file, {
                onUploadProgress: (progress) => {
                    // El progreso de Supabase va de 0 a 100, lo mapeamos a 10-60% del total
                    if (onProgress) {
                        const mappedProgress = 10 + (progress.loaded / progress.total) * 50;
                        onProgress(Math.min(mappedProgress, 60));
                    }
                }
            }); // CORRECCIÓN: Usar window.auth.sb
            if (uploadError) throw new Error(`Error en subida temporal: ${uploadError.message}`);

            if (onProgress) onProgress(60);

            // 2. Obtener la URL pública del archivo temporal
            const { data: urlData } = window.auth.sb.storage.from('campaign_files').getPublicUrl(tempPath); // CORRECCIÓN: Usar window.auth.sb

            if (onProgress) onProgress(70);

            // 3. Llamar a la Edge Function 'smart-worker' para mover el archivo a Bunny.net
            // Pasamos el nombre del archivo para preservar la extensión
            const { data: bunnyData, error: functionError } = await window.auth.invokeFunction('smart-worker', { // CORRECCIÓN: Usar el helper window.auth.invokeFunction
                body: {
                    sourceUrl: urlData.publicUrl,
                    userId,
                    userEmail, // Pasar el email para usarlo en la ruta de Bunny
                    fileName: safeName, // Pasar el nombre del archivo con extensión correcta
                    folder: folder
                }
            });
            if (functionError) throw new Error(`Error al mover a CDN: ${functionError.message}`);

            if (onProgress) onProgress(90);

            // 4. (Opcional pero recomendado) Borrar el archivo temporal de Supabase (CORRECCIÓN: Usar window.auth.sb)
            const { error: removeError } = await window.auth.sb.storage.from('campaign_files').remove([tempPath]); // CORRECCIÓN: Usar window.auth.sb
            if (removeError) {
                // No detenemos el flujo, pero sí es bueno saber si falló la limpieza.
                console.warn(`[Limpieza] No se pudo borrar el archivo temporal ${tempPath}:`, removeError.message);
            }

            if (onProgress) onProgress(100);

            return bunnyData.cdnUrl; // Devuelve la URL final de Bunny.net
        } catch (error) {
            console.error('Falló el proceso completo de subida de asset:', error);
            // Si algo falla, no se borra el archivo temporal para poder investigarlo.
            throw error; // Relanzar el error para que el llamador lo maneje
        }
    }

    // Helper para comprimir imágenes (Método de clase)
    async compressImage(file, { quality = 0.8, maxWidth = 1920, maxHeight = 1920 } = {}) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            const objectUrl = URL.createObjectURL(file);
            img.src = objectUrl;

            img.onload = () => {
                URL.revokeObjectURL(objectUrl);
                let width = img.width;
                let height = img.height;

                // Calcular nuevas dimensiones manteniendo aspect ratio
                if (width > height) {
                    if (width > maxWidth) {
                        height = Math.round((height * maxWidth) / width);
                        width = maxWidth;
                    }
                } else {
                    if (height > maxHeight) {
                        width = Math.round((width * maxHeight) / height);
                        height = maxHeight;
                    }
                }

                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0, width, height);

                canvas.toBlob((blob) => {
                    if (!blob) {
                        reject(new Error('Canvas to Blob conversion failed'));
                        return;
                    }
                    // Crear un nuevo File con la imagen comprimida
                    const newFile = new File([blob], file.name.replace(/\.[^/.]+$/, "") + ".webp", {
                        type: 'image/webp',
                        lastModified: Date.now(),
                    });
                    console.log(`[Compress] Original: ${(file.size / 1024).toFixed(2)}KB, Optimizado: ${(newFile.size / 1024).toFixed(2)}KB`);
                    resolve(newFile);
                }, 'image/webp', quality);
            };

            img.onerror = (err) => {
                URL.revokeObjectURL(objectUrl);
                reject(err);
            };
        });
    }

    async loadDashboardMetrics() {
        try {
            const today = new Date();
            const thirtyDaysAgo = new Date(today);
            thirtyDaysAgo.setDate(today.getDate() - 30);

            const { data, error } = await auth.sb
                .from('daily_stats')
                .select('stat_date, ai_responses_count, time_saved_seconds')
                .eq('user_id', this.user.id)
                .gte('stat_date', thirtyDaysAgo.toISOString().split('T')[0])
                .order('stat_date', { ascending: true });

            if (error) throw error; // Lanzar error si la consulta falla

            this.renderMetricsCharts(data);
            // this.renderMoneySaved(); // Función desactivada en petición anterior.

        } catch (e) {
            console.error("Error al cargar métricas del dashboard:", e);
        }
    }

    renderMetricsCharts(stats) {
        const labels = stats.map(s => new Date(s.stat_date + 'T00:00:00').toLocaleDateString('es-MX', { day: 'numeric', month: 'short' }));
        const responsesData = stats.map(s => s.ai_responses_count);
        const timeData = stats.map(s => Math.round(s.time_saved_seconds / 60)); // en minutos

        const chartOptions = {
            responsive: true,
            maintainAspectRatio: false,
            scales: { y: { beginAtZero: true, ticks: { color: '#94a3b8' } }, x: { ticks: { color: '#94a3b8' } } },
            plugins: { legend: { display: false } },
        };

        // Gráfico de Respuestas (CORRECCIÓN: 'datasets' debe ser un array)
        const responsesCtx = document.getElementById('responses-chart')?.getContext('2d');
        if (responsesCtx) {
            new Chart(responsesCtx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{ // <-- CORRECCIÓN: 'datasets' debe ser un array
                        label: 'Mensajes Respondidos',
                        data: responsesData,
                        borderColor: 'rgb(59, 130, 246)',
                        backgroundColor: 'rgba(59, 130, 246, 0.1)',
                        fill: true,
                        tension: 0.3
                    }]
                },
                options: chartOptions
            });
        }

        // Gráfico de Tiempo Ahorrado (CORRECCIÓN: 'datasets' debe ser un array)
        const timeCtx = document.getElementById('time-saved-chart')?.getContext('2d');
        if (timeCtx) {
            new Chart(timeCtx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{ // <-- CORRECCIÓN: 'datasets' debe ser un array
                        label: 'Minutos Ahorrados',
                        data: timeData,
                        borderColor: 'rgb(139, 92, 246)',
                        backgroundColor: 'rgba(139, 92, 246, 0.1)',
                        fill: true,
                        tension: 0.3
                    }]
                },
                options: chartOptions
            });
        }
    }

    async loadFunnelMetrics() {
        try {
            const thirtyDaysAgo = new Date();
            thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

            const { data: contacts, error } = await auth.sb
                .from('contacts')
                .select('labels, created_at')
                .eq('user_id', this.user.id)
                .gte('created_at', thirtyDaysAgo.toISOString());

            if (error) throw error;

            let leads = 0;
            let interested = 0;
            let won = 0;

            contacts.forEach(contact => {
                const labels = new Set(contact.labels || []);
                leads++;
                if (labels.has('Interesado')) {
                    interested++;
                }
                if (labels.has('nuevo cliente')) {
                    won++;
                }
            });

            const conversionRate = leads > 0 ? ((won / leads) * 100).toFixed(1) : 0;

            document.getElementById('funnel-leads-stat').textContent = leads;
            document.getElementById('funnel-interested-stat').textContent = interested;
            document.getElementById('funnel-won-stat').textContent = won;
            document.getElementById('funnel-conversion-stat').textContent = `${conversionRate}%`;

        } catch (e) {
            console.error("Error al cargar métricas del embudo:", e);
        }
    }

    async checkWhatsappConnection() {
        this.renderWhatsappConnection('loading');
        const url = `${this.config.N8N_URL}/webhook/generate-whatsapp-qr-Elina`;

        try {
            const response = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ email: this.user.email })
            });

            if (!response.ok) throw new Error('El servidor N8N no responde correctamente.');

            const raw = await response.text();
            const trimmed = raw.trim();
            if (!trimmed) {
                this.renderWhatsappConnection('connected');
                return;
            }

            let data;
            try {
                data = JSON.parse(trimmed);
            } catch (parseError) {
                console.warn('Respuesta QR inesperada, se esperaba JSON.', parseError, raw);
                this.renderWhatsappConnection('error');
                return;
            }

            const result = Array.isArray(data) ? data[0] : data;

            if (result?.qr_image_data) {
                this.renderWhatsappConnection('qr', result.qr_image_data);
            } else {
                this.renderWhatsappConnection('connected');
            }
        } catch (error) {
            console.error("Error al solicitar QR:", error);
            this.renderWhatsappConnection('error');
        }
    }

    openChatwoot(e) {
        e.preventDefault(); // Prevenir la navegación por defecto del enlace
        // Por ahora, abre la URL base. La lógica de SSO se puede añadir aquí después.
        window.open(`${this.config.CHATWOOT_BASE_URL}/app/login`, '_blank');
    }

    setupYoutubeCarousel() {
        const player = document.getElementById('yt-player');
        const items = document.querySelectorAll('#yt-carousel [data-vid]');
        const playlistId = this.config.YOUTUBE_PLAYLIST_ID;

        items.forEach(el => {
            el.addEventListener('click', (e) => {
                e.preventDefault();
                const videoId = el.dataset.vid;
                if (videoId && player) {
                    player.src = `https://www.youtube.com/embed/${videoId}?list=${playlistId}&rel=0&autoplay=1`;
                }
            });
        });
    }

    // --- Métodos de Renderizado (CORRECCIÓN: Se restaura la lógica de renderizado) ---

    renderWhatsappConnection(status, qrCodeBase64 = null) {
        const container = document.getElementById('whatsapp-connection-container');
        const button = document.getElementById('request-qr-btn');
        let html = '';

        switch (status) {
            case 'connected':
                html = `
                    <div class="flex flex-col items-center justify-center h-48 text-green-600">
                        <i data-lucide="check-circle" class="w-16 h-16"></i>
                        <p class="font-bold mt-2">¡Conectado!</p>
                        <p class="text-sm text-slate-500">Tu sesión de WhatsApp está activa.</p>
                    </div>`;
                button.style.display = 'none';
                break;
            case 'loading':
                html = `
                    <div class="flex justify-center items-center h-48">
                        <div class="animate-spin rounded-full h-16 w-16 border-b-2 border-slate-900"></div>
                    </div>`;
                button.style.display = 'block';
                break;
            case 'qr':
                html = `<img src="data:image/png;base64,${qrCodeBase64}" alt="Escanea para conectar WhatsApp" class="mx-auto max-w-xs rounded-lg">`;
                button.style.display = 'block';
                break;
            case 'error':
                html = `
                    <div class="flex flex-col items-center justify-center h-48 text-red-500">
                         <i data-lucide="alert-triangle" class="w-16 h-16"></i>
                         <p class="font-bold mt-2">Error de Conexión</p>
                    </div>`;
                button.style.display = 'block';
                break;
            case 'initial':
            default:
                html = `
                    <div class="flex flex-col items-center justify-center h-48 text-slate-400">
                         <i data-lucide="qr-code" class="w-16 h-16"></i>
                         <p class="font-bold mt-2">Solicita el QR para vincular</p>
                    </div>`;
                button.style.display = 'block';
                break;
        }
        container.innerHTML = html;
        lucide.createIcons();
    }

    // --- LÓGICA GLOBAL DEL MODAL DE IA ---
    async openAiEnhanceModal(originalText, onApplyCallback, context = 'default') {
        const modal = document.getElementById('ai-enhance-modal');
        if (!modal) return;
        const generateBtn = document.getElementById('generate-ai-btn');
        // CORRECCIÓN: Cargar plan y uso directamente, sin depender de variables globales
        try {
            this.aiModalContext = context;

            // --- CORRECCIÓN: Cargar plan y uso directamente, sin depender de variables globales ---
            const [userPlan, userUsage] = await Promise.all([
                this.loadUserSubscription(),
                this.loadUserUsage()
            ]);
            // CORRECCIÓN: Cargar plan y uso directamente, sin depender de variables globales
            if (!userPlan) throw new Error("No se pudo cargar la información del plan.");

            const aiLimit = userPlan.plans?.ai_enhancements_limit || 0;
            const aiUsed = userUsage?.ai_enhancements_used || 0;
            const usesLeft = aiLimit - aiUsed;

            document.getElementById('ai-uses-left').textContent = `${usesLeft}/${aiLimit}`;
            generateBtn.disabled = usesLeft <= 0;

            if (usesLeft <= 0) {
                window.showToast('Has alcanzado tu límite de mejoras con IA este mes.', 'info');
            }

            this.aiModalCallback = onApplyCallback;
            document.getElementById('ai-original-text').value = originalText;
            document.getElementById('ai-prompt-input').value = '';
            document.getElementById('ai-result-container').innerHTML = '';
            document.getElementById('ai-result-container').classList.add('hidden');
            generateBtn.classList.remove('hidden');
            document.getElementById('apply-ai-btn').classList.add('hidden');
            document.getElementById('regenerate-ai-btn').classList.add('hidden');

            modal.classList.remove('hidden');

        } catch (error) {
            window.showToast(error.message, 'error');
            return;
        }
    }

    closeAiModal() {
        document.getElementById('ai-enhance-modal').classList.add('hidden');
        this.aiModalCallback = null;
    }

    async handleGenerateAi(isRegenerating = false) {
        const button = isRegenerating ? document.getElementById('regenerate-ai-btn') : document.getElementById('generate-ai-btn');
        const mainGenerateBtn = document.getElementById('generate-ai-btn');
        button.disabled = true;
        button.textContent = 'Generando...';
        // CORRECCIÓN: Usar la Edge Function
        const originalText = document.getElementById('ai-original-text').value;

        const userPrompt = document.getElementById('ai-prompt-input').value;
        let systemPrompt;

        if (this.aiModalContext === 'designer') {
            systemPrompt = `Eres un asistente de diseño experto. Mejora la siguiente descripción para un prompt de generación de imágenes. Sé creativo y visual.
            - NO uses placeholders como '%nombre%'.
            - Devuelve ÚNICAMENTE la descripción mejorada.
            ${userPrompt ? `Considera esta instrucción adicional del usuario: '${userPrompt}'.` : ''}`;
        } else if (this.aiModalContext === 'behavior_prompt') {
            // Contexto específico para prompts de comportamiento del asistente
            systemPrompt = `Eres un experto en optimización de prompts de comportamiento para asistentes de IA conversacionales.

Tu tarea es MEJORAR el prompt de comportamiento proporcionado, NO reemplazarlo completamente.

**REGLAS CRÍTICAS:**
1. DEBES mantener TODA la estructura original del prompt (secciones, formato, ejemplos, etc.)
2. DEBES conservar TODO el contenido existente (identidad, reglas, procesos, ejemplos)
3. SOLO debes hacer mejoras incrementales basadas en las instrucciones del usuario
4. NO elimines secciones, ejemplos o información importante
5. NO cambies el formato o estructura a menos que el usuario lo solicite explícitamente
6. Si el usuario pide algo específico, incorpóralo sin eliminar el resto del contenido
7. Mantén la misma extensión y nivel de detalle del prompt original
8. Conserva todos los ejemplos (FEW-SHOT_LEARNING) y casos de uso

**INSTRUCCIONES DEL USUARIO:**
${userPrompt ? `El usuario quiere: "${userPrompt}"` : 'Mejora general del prompt manteniendo todo el contenido.'}

**PROMPT ORIGINAL A MEJORAR:**
[El prompt completo se enviará a continuación]

**IMPORTANTE:** 
- Devuelve el prompt COMPLETO mejorado, no solo las partes que cambiaste
- Mantén todas las secciones: CORE_IDENTITY, KNOWLEDGE_BASE, RULES, PROCESS, OUTPUT_FORMAT, FEW-SHOT_LEARNING
- Si agregas algo nuevo, intégralo en la sección correspondiente sin eliminar lo existente
- Si el prompt original tiene 1000 palabras, el mejorado debe tener al menos 900-1100 palabras
- Si el usuario solo pide un cambio pequeño, haz ese cambio específico pero mantén TODO lo demás intacto
- NUNCA devuelvas solo un resumen o versión corta del prompt original
- El resultado debe ser un prompt completo y funcional, no un resumen`;
        } else { // Contexto por defecto para marketing, plantillas, etc.
            systemPrompt = `Eres un asistente de marketing experto en WhatsApp. Reescribe el siguiente texto para que sea más efectivo y profesional, manteniendo el tono y la intención original.
            - El único placeholder permitido es '%nombre%'. Mantenlo exactamente como está. NO inventes otros placeholders como '%empresa%'.
            - NO añadas saludos, despedidas, ni firmes con "[Tu Nombre]", etc. Devuelve ÚNICamente el texto mejorado.
            ${userPrompt ? `Considera esta instrucción adicional del usuario: '${userPrompt}'.` : ''}`;
        }

        try { // CORRECCIÓN: Usar la Edge Function
            // Verificar acceso de cuenta primero (si la función existe)
            let accessCheck = null;
            try {
                const { data, error: accessError } = await window.auth.sb.rpc('check_account_access', { p_user_id: this.user.id });
                if (accessError && accessError.code !== 'PGRST202') {
                    throw new Error('Error al verificar el acceso de tu cuenta.');
                } else if (!accessError) {
                    accessCheck = data;
                }
            } catch (e) {
                if (e.code !== 'PGRST202') {
                    throw new Error('Error al verificar el acceso de tu cuenta.');
                }
            }
            if (accessCheck && accessCheck.blocked) {
                throw new Error(accessCheck.reason || 'Tu cuenta está bloqueada. Por favor, contacta con soporte.');
            }

            // --- CORRECCIÓN: Usar la Edge Function ---
            const { data, error } = await window.auth.invokeFunction('openai-proxy', {
                body: {
                    type: 'text',
                    prompt: systemPrompt,
                    text: originalText,
                    userId: this.user.id // Enviamos el ID para registrar el uso
                }
            });
            if (error) throw error; // Actualizar el contador de usos en la UI

            // Actualizar el contador de usos en la UI
            // Recargamos el uso desde la DB para tener el dato más fresco y lo mostramos.
            const updatedUsage = await this.loadUserUsage();
            const aiLimit = (await this.loadUserSubscription()).plans?.ai_enhancements_limit || 0;
            const aiUsed = updatedUsage?.ai_enhancements_used || 0;
            document.getElementById('ai-uses-left').textContent = `${aiLimit - aiUsed}/${aiLimit}`;

            const resultContainer = document.getElementById('ai-result-container');
            resultContainer.textContent = data.result || "La IA no devolvió un resultado válido.";
            resultContainer.classList.remove('hidden');

            mainGenerateBtn.classList.add('hidden');
            document.getElementById('apply-ai-btn').classList.remove('hidden');
            document.getElementById('regenerate-ai-btn').classList.remove('hidden');
        } catch (e) {
            // Si el error es por límite de uso, la función ya muestra un mensaje claro.
            if (!/limit/i.test(e.message)) window.showToast('No se pudo generar la mejora. Revisa la consola.', 'error');
        } finally {
            button.disabled = false; // Habilitar el botón que se usó
            button.textContent = isRegenerating ? 'Reintentar' : 'Mejorar Texto';
        }
    }

    handleApplyAi() {
        const newText = document.getElementById('ai-result-container').textContent;
        if (this.aiModalCallback) this.aiModalCallback(newText);
        this.closeAiModal();
    }
}

// =================================================================================
// CLASE PARA EL ASISTENTE DE CONFIGURACIÓN (WIZARD)
// =================================================================================
class Wizard {
    constructor(appInstance) {
        this.app = appInstance;
        this.iti = null;
        this.currentStep = 1; // El paso actual
        this.totalSteps = 4; // WhatsApp, Sync, Company Info, AI Q&A
        this.modal = document.getElementById('wizard-modal');
        this.prevBtn = document.getElementById('wizard-prev-btn');
        this.nextBtn = document.getElementById('wizard-next-btn');
        this.finishBtn = document.getElementById('wizard-finish-btn');
        this.closeBtn = document.getElementById('close-wizard-btn');
        this.stepIndicator = document.getElementById('wizard-step-indicator');
        this.companyForm = document.getElementById('wizard-company-form');
        this.qaForm = this.modal?.querySelector('#wizard-qa-form') || null;
        this.qrContainer = document.getElementById('wizard-qr-container');
        this.requestQrBtn = document.getElementById('wizard-request-qr-btn');
        this.syncContactsBtn = document.getElementById('wizard-sync-contacts-btn');
        this.companySnapshot = null;

        this.setupListeners();
    }

    setupListeners() {
        this.prevBtn.addEventListener('click', () => this.changeStep(-1));
        this.nextBtn.addEventListener('click', () => this.changeStep(1));
        this.finishBtn.addEventListener('click', () => this.finish());
        this.closeBtn.addEventListener('click', () => this.hide());
        this.requestQrBtn?.addEventListener('click', () => this.app.checkWhatsappConnection(true));
        this.syncContactsBtn?.addEventListener('click', () => this.handleSyncClick());

        // Listeners para el nuevo paso de info de la empresa
        this.modal.querySelector('#wizard-upload-logo-btn')?.addEventListener('click', () => this.modal.querySelector('#wizard-logo-input').click());
        this.modal.querySelector('#wizard-logo-input')?.addEventListener('change', (e) => this.previewLogo(e.target.files[0]));

        // Listener para mostrar/ocultar configuración de citas
        const appointmentsCheckbox = this.modal.querySelector('#wizard-appointments-enabled');
        const appointmentsConfig = this.modal.querySelector('#wizard-appointments-config');
        if (appointmentsCheckbox && appointmentsConfig) {
            appointmentsCheckbox.addEventListener('change', (e) => {
                if (e.target.checked) {
                    appointmentsConfig.classList.remove('hidden');
                } else {
                    appointmentsConfig.classList.add('hidden');
                }
            });
        }

        // Nuevo Listener para Smart Promo en el Wizard
        const promoCheckbox = this.modal.querySelector('#wizard-has-promo');
        const promoFields = this.modal.querySelector('#wizard-promo-fields');
        if (promoCheckbox && promoFields) {
            promoCheckbox.addEventListener('change', (e) => {
                if (e.target.checked) {
                    promoFields.classList.remove('hidden');
                    // Focus al primer input
                    setTimeout(() => promoFields.querySelector('input')?.focus(), 100);
                } else {
                    promoFields.classList.add('hidden');
                }
            });
        }
    }

    // ... (Métodos intermedios sin cambios: start, hide, changeStep, updateStepUI, previewLogo, loadExistingCompanySettings, handleSettingsSave, handleSyncClick)

    async finish() {
        this.toggleLoading(true);

        try {
            const qaForm = this.qaForm || this.modal?.querySelector('#wizard-qa-form');
            if (!qaForm) throw new Error('No se encontró el formulario de preguntas.');

            const formData = new FormData(qaForm);
            const answers = Object.fromEntries(formData.entries());

            // 1. Smart Promotion Logic
            const hasPromo = this.modal.querySelector('#wizard-has-promo')?.checked;
            if (hasPromo && answers.promo_title) {
                await this.upsertSmartPromotion(answers);
            }

            // 2. Critical Rules Logic (Escalate Anger)
            if (this.modal.querySelector('[name="escalate_anger"]')?.checked) {
                await this.upsertCriticalRule({
                    rule_name: 'Detector de Enojo (Wizard)',
                    trigger_pattern: '(enojado|molesto|insulto|basura|estafa|imbecil|idiota|mierda)',
                    response_template: 'Entiendo tu molestia. Voy a conectar inmeditamente con un humano para resolver esto.',
                    action_type: 'escalate'
                });
            } else {
                // Si el usuario desmarcó la opción, intentamos desactivar la regla creada por el wizard
                // (Opcional: implementar lógica de limpieza si se desea)
            }

            // 3. Prompt Construction (Clean & LITE)
            const finalPrompt = this.buildPromptFromAnswers(answers);

            // 4. Save
            const promptTextarea = document.getElementById('ai-master-prompt');
            promptTextarea.value = finalPrompt;
            await this.app.handlePromptSave(new Event('submit', { cancelable: true }));

            this.toggleLoading(false, true); // Success state
            setTimeout(() => this.hide(), 3000);

        } catch (e) {
            console.error("Error al finalizar el wizard:", e);
            window.showToast('No se pudo generar el prompt. Inténtalo de nuevo.', 'error');
            this.toggleLoading(false, false);
        }
    }

    async upsertSmartPromotion(answers) {
        try {
            // Desactivar promos anteriores del wizard para evitar colisiones excesivas
            await window.auth.sb
                .from('smart_promotions')
                .update({ is_active: false })
                .eq('user_id', this.app.user.id)
                .eq('title', answers.promo_title.trim()); // Simple check

            const promoPayload = {
                user_id: this.app.user.id,
                title: answers.promo_title.trim(),
                description: answers.promo_description?.trim() || '',
                is_active: true,
                auto_insert: true,
                no_schedule: true,
                created_at: new Date().toISOString()
            };

            const { error } = await window.auth.sb.from('smart_promotions').insert(promoPayload);
            if (error) console.warn('[Wizard] Error promo:', error);
            else document.dispatchEvent(new CustomEvent('panel:activated', { detail: { panelId: 'smart-promotions' } }));
        } catch (err) { console.error(err); }
    }

    async upsertCriticalRule(ruleData) {
        try {
            // Verificar si ya existe una regla con ese nombre para actualizarla o dejarla
            const { data: existing } = await window.auth.sb
                .from('critical_rules')
                .select('id')
                .eq('user_id', this.app.user.id)
                .eq('rule_name', ruleData.rule_name)
                .maybeSingle();

            if (existing) {
                await window.auth.sb.from('critical_rules').update({
                    pattern_or_keyword: ruleData.trigger_pattern,
                    action_type: ruleData.action_type || 'notify', // Default to notify
                    is_active: true
                }).eq('id', existing.id);
            } else {
                await window.auth.sb.from('critical_rules').insert({
                    user_id: this.app.user.id,
                    rule_name: ruleData.rule_name,
                    rule_type: 'pattern',
                    pattern_or_keyword: ruleData.trigger_pattern,
                    detection_type: 'custom',
                    action_type: ruleData.action_type || 'notify', // Propagar action_type
                    is_active: true,
                    is_predefined: false,
                    priority: 100
                });
            }
            console.log('[Wizard] Critical Rule configurada.');
        } catch (err) { console.error('Error configurando Critical Rule:', err); }
    }

    toggleLoading(isLoading, isSuccess = false) {
        if (isLoading) {
            this.modal.querySelectorAll('.wizard-step').forEach(step => step.classList.add('hidden'));
            document.getElementById('wizard-step-5').classList.remove('hidden');
            document.getElementById('wizard-loading').classList.remove('hidden');
            document.getElementById('wizard-success').classList.add('hidden');
            this.prevBtn.parentElement.classList.add('hidden');
        } else {
            if (isSuccess) {
                document.getElementById('wizard-loading').classList.add('hidden');
                document.getElementById('wizard-success').classList.remove('hidden');
            } else {
                // Revertir a paso 4
                this.currentStep = 4;
                this.updateStepUI();
                this.prevBtn.parentElement.classList.remove('hidden');
            }
        }
    }

    buildPromptFromAnswers(answers) {
        const clean = (val) => (val || '').trim();
        const personas = {
            friendly: { role: 'un asistente virtual muy cercano y amigable', tone: 'cálido, empático y usas emojis moderados.', style: 'Conversacional y relajado.' },
            professional: { role: 'un consultor experto y profesional', tone: 'formal, preciso y educado.', style: 'Ejecutivo y directo.' },
            sales: { role: 'un asesor comercial dinámico', tone: 'energético, persuasivo y proactivo.', style: 'Persuasivo y ágil.' }
        };
        const persona = personas[answers.persona] || personas.friendly;

        let priceRule = '';
        switch (answers.pricing_policy) {
            case 'direct': priceRule = 'Si tienes el precio, dalo directamente. Se transparente.'; break;
            case 'qualify': priceRule = 'Antes de dar precio, califica brevemente la necesidad.'; break;
            case 'contact': priceRule = 'No des precios exactos. Tu objetivo es agendar una cita.'; break;
            default: priceRule = 'Responde sobre precios según información disponible.';
        }

        const businessName = clean(answers.negocio) || 'nuestra empresa';
        const differentiator = clean(answers.diferenciador);
        const collectLead = this.modal.querySelector('[name="collect_lead"]')?.checked;

        const lines = [];
        lines.push('# SISTEMA DE CONTROL DE IA - LITE VERSION');
        lines.push('');
        lines.push('## 1. IDENTIDAD (CORE)');
        lines.push(`Eres Elina, ${persona.role} para ${businessName}.`);
        lines.push(`Tu tono es ${persona.tone}`);
        if (differentiator) lines.push(`Propuesta de Valor: ${differentiator}`);
        lines.push('');
        lines.push('## 2. DIRECTIVAS PRINCIPALES');
        lines.push('- **Objetivo:** Resolver dudas y guiar al usuario.');
        lines.push('- **Estilo:** Corto y directo (max 2 párrafos).');
        lines.push('- **Veracidad:** Solo usa información del contexto.');
        lines.push('');
        lines.push('## 3. REGLAS DE NEGOCIO');
        lines.push(`- **Precios:** ${priceRule}`);
        if (collectLead) lines.push('- **Leads:** Si hay interés, intenta obtener Nombre y Correo sutilmente.');
        // NOTA: Anger Rule eliminada del prompt de texto porque ahora es una Critical Rule del sistema.

        return lines.join('\n');
    }

    // Método para cargar datos existentes (Promos activas y Reglas Críticas) en el Wizard
    async loadExistingData() {
        try {
            // 1. Cargar Promo Activa más reciente
            const { data: promo } = await window.auth.sb
                .from('smart_promotions')
                .select('*')
                .eq('user_id', this.app.user.id)
                .eq('is_active', true)
                .order('created_at', { ascending: false })
                .limit(1)
                .maybeSingle();

            if (promo) {
                const promoCheck = this.modal.querySelector('#wizard-has-promo');
                const titleInput = this.modal.querySelector('[name="promo_title"]');
                const descInput = this.modal.querySelector('[name="promo_description"]');

                if (promoCheck) {
                    promoCheck.checked = true;
                    this.modal.querySelector('#wizard-promo-fields')?.classList.remove('hidden');
                    if (titleInput) titleInput.value = promo.title;
                    if (descInput) descInput.value = promo.description;
                }
            }

            // 2. Cargar Estado de Regla de Enojo
            const { data: angerRule } = await window.auth.sb
                .from('critical_rules')
                .select('id')
                .eq('user_id', this.app.user.id)
                .eq('rule_name', 'Detector de Enojo (Wizard)') // Debe coincidir con el nombre usado en upsertCriticalRule
                .eq('is_active', true)
                .maybeSingle();

            const angerCheck = this.modal.querySelector('[name="escalate_anger"]');
            if (angerCheck) {
                // Si existe la regla activa, marcamos el checkbox. Si no, lo desmarcamos (o dejamos el default si preferimos)
                // Para consistencia con "personalización", reflejamos el estado real.
                angerCheck.checked = !!angerRule;
            }

        } catch (e) {
            console.warn('[Wizard] Error loading existing data:', e);
        }
    }

    start(jumpToQA = false) {
        this.currentStep = jumpToQA ? 4 : 1;
        this.updateStepUI();
        if (!jumpToQA) { // CORRECCIÓN: Cargar datos al iniciar.
            this.loadExistingCompanySettings(); // CORRECCIÓN: Cargar datos al iniciar.
        }
        // Cargar datos extra para el paso 4
        this.loadExistingData();

        this.modal.classList.remove('hidden');
        document.body.classList.add('overflow-hidden');
    }

    hide() {
        this.modal.classList.add('hidden');
        document.body.classList.remove('overflow-hidden');
    }

    changeStep(direction) {
        // Si estamos en el paso 3 y vamos al 4, primero guardamos los datos de la empresa
        if (this.currentStep === 3 && direction > 0) {
            this.handleSettingsSave(); // Guardar y continuar
            return; // handleSettingsSave se encargará de llamar a changeStep
        }

        const newStep = this.currentStep + direction;
        if (newStep >= 1 && newStep <= this.totalSteps) {
            this.currentStep = newStep;
            this.updateStepUI();
        }
    }

    updateStepUI() {
        // Ocultar todos los pasos
        this.modal.querySelectorAll('.wizard-step').forEach(step => step.classList.add('hidden')); // CORRECCIÓN: Asegurarse de que el formulario exista

        // Mostrar el paso actual
        const currentStepEl = document.getElementById(`wizard-step-${this.currentStep}`);
        if (currentStepEl) {
            currentStepEl.classList.remove('hidden');
        }

        // Actualizar botones
        this.prevBtn.disabled = this.currentStep === 1;
        this.nextBtn.classList.toggle('hidden', this.currentStep >= this.totalSteps); // Ocultar en el último paso
        this.finishBtn.classList.toggle('hidden', this.currentStep !== this.totalSteps); // Mostrar solo en el último paso

        // Actualizar texto del botón "Siguiente"
        if (this.currentStep === 3) {
            this.nextBtn.innerHTML = 'Guardar y Seguir';
        } else {
            this.nextBtn.innerHTML = 'Siguiente';
        }

        // Actualizar indicador de paso (ahora es 4 pasos)
        this.stepIndicator.textContent = `Paso ${this.currentStep} de ${this.totalSteps}`;
    }

    previewLogo(file) {
        if (!file || !this.modal) return;
        const preview = this.modal.querySelector('#wizard-logo-preview');
        const reader = new FileReader();
        reader.onload = (e) => { preview.src = e.target.result; };
        reader.readAsDataURL(file);
    }

    async loadExistingCompanySettings() {
        try { // CORRECCIÓN: Verificar si el formulario existe
            if (!this.companyForm) return; // CORRECCIÓN: Verificar si el formulario existe
            const { data, error } = await window.auth.sb.from('profiles')
                .select('work_start_hour, work_end_hour, company_description, website, social_media, branding_settings, contact_phone, organization_id')
                .eq('id', this.app.user.id)
                .single();
            if (error && error.code !== 'PGRST116') throw error;
            if (!data) return;

            // Cargar nombre de empresa de organizations
            if (data.organization_id) {
                const { data: orgData, error: orgError } = await window.auth.sb
                    .from('organizations')
                    .select('name')
                    .eq('id', data.organization_id)
                    .single();

                if (!orgError && orgData && orgData.name) {
                    const companyNameInput = this.companyForm.querySelector('#wizard-company-name');
                    if (companyNameInput) {
                        companyNameInput.value = orgData.name;
                    }
                }
            }

            this.companySnapshot = {
                work_start_hour: data.work_start_hour ?? null,
                work_end_hour: data.work_end_hour ?? null,
                company_description: data.company_description ?? '',
                website: data.website ?? '',
                social_media: data.social_media ?? {},
                branding_settings: data.branding_settings ?? {},
                contact_phone: data.contact_phone ?? null,
            };

            if (data.work_start_hour) this.companyForm.querySelector('#wizard-work-start-hour').value = `${String(data.work_start_hour).padStart(2, '0')}:00`;
            if (data.work_end_hour) this.companyForm.querySelector('#wizard-work-end-hour').value = `${String(data.work_end_hour).padStart(2, '0')}:00`;
            if (data.company_description) this.companyForm.querySelector('#wizard-company-description').value = data.company_description;
            if (data.website) this.companyForm.querySelector('#wizard-website').value = data.website;
            if (data.social_media) {
                this.companyForm.querySelector('#wizard-social-instagram').value = data.social_media.instagram || '';
                this.companyForm.querySelector('#wizard-social-facebook').value = data.social_media.facebook || '';
            }
            if (data.branding_settings?.logo_url) this.companyForm.querySelector('#wizard-logo-preview').src = data.branding_settings.logo_url;
            if (data.branding_settings?.colors) data.branding_settings.colors.forEach((c, i) => {
                const colorInput = this.companyForm.querySelector(`#wizard-brand-color-${i + 1}`);
                if (colorInput) colorInput.value = c;
            });
            if (data.contact_phone && this.iti) this.iti.setNumber(data.contact_phone);

            // Cargar configuración de citas (appointment_settings) para sincronizar con Settings
            try {
                const { data: appointmentSettings, error: appointmentError } = await window.auth.sb
                    .from('appointment_settings')
                    .select('business_type, is_enabled, timezone, default_duration_minutes, buffer_time_minutes, advance_booking_days')
                    .eq('user_id', this.app.user.id)
                    .maybeSingle();

                if (!appointmentError && appointmentSettings) {
                    // Cargar business_type
                    const businessTypeSelect = this.companyForm.querySelector('#wizard-business-type');
                    if (businessTypeSelect && appointmentSettings.business_type) {
                        businessTypeSelect.value = appointmentSettings.business_type;
                    } else if (businessTypeSelect) {
                        businessTypeSelect.value = 'both'; // Valor por defecto
                    }

                    // Cargar configuración de citas si está habilitada
                    const appointmentsEnabled = this.companyForm.querySelector('#wizard-appointments-enabled');
                    if (appointmentsEnabled) {
                        appointmentsEnabled.checked = appointmentSettings.is_enabled || false;
                        // Mostrar/ocultar configuración según el estado
                        const appointmentsConfig = this.companyForm.querySelector('#wizard-appointments-config');
                        if (appointmentsConfig) {
                            if (appointmentSettings.is_enabled) {
                                appointmentsConfig.classList.remove('hidden');
                            } else {
                                appointmentsConfig.classList.add('hidden');
                            }
                        }
                    }

                    // Cargar valores de configuración de citas si están disponibles
                    if (appointmentSettings.is_enabled) {
                        const timezoneSelect = this.companyForm.querySelector('#wizard-appointment-timezone');
                        if (timezoneSelect && appointmentSettings.timezone) {
                            timezoneSelect.value = appointmentSettings.timezone;
                        }

                        const defaultDurationInput = this.companyForm.querySelector('#wizard-appointment-default-duration');
                        if (defaultDurationInput && appointmentSettings.default_duration_minutes) {
                            defaultDurationInput.value = appointmentSettings.default_duration_minutes;
                        }
                    }
                } else if (appointmentError && appointmentError.code !== 'PGRST116') {
                    console.warn('[Wizard] Error al cargar configuración de citas:', appointmentError);
                }
            } catch (appointmentLoadError) {
                console.warn('[Wizard] Error al cargar appointment_settings:', appointmentLoadError);
            }
        } catch (e) {
            console.error("Error al precargar datos de la empresa en el wizard:", e);
        }
    }

    async handleSettingsSave() {
        // CORRECCIÓN: Lógica de guardado y avance (CORRECCIÓN: Guardar para el usuario correcto)
        this.nextBtn.disabled = true;
        this.nextBtn.innerHTML = `<div class="animate-spin rounded-full h-5 w-5 border-b-2 border-white mx-auto"></div>`;

        try {
            const logoFile = this.companyForm.querySelector('#wizard-logo-input').files[0];
            let logoUrl = this.companyForm.querySelector('#wizard-logo-preview')?.src;
            if (logoFile) {
                logoUrl = await this.app.uploadAsset(logoFile, 'logos');
            }

            const brandingSettings = {
                logo_url: logoUrl.startsWith('https') ? logoUrl : null,
                colors: Array.from({ length: 4 }, (_, i) => this.companyForm.querySelector(`#wizard-brand-color-${i + 1}`).value),
            };

            const startHourInput = this.companyForm.querySelector('#wizard-work-start-hour').value;
            const endHourInput = this.companyForm.querySelector('#wizard-work-end-hour').value;
            const adminPhone = this.companyForm.querySelector('#wizard-admin-phone-input').value.trim() || null;
            const companyName = this.companyForm.querySelector('#wizard-company-name')?.value.trim() || null;

            // Guardar nombre de empresa en organizations
            const { data: profile, error: profileError } = await window.auth.sb
                .from('profiles')
                .select('organization_id')
                .eq('id', this.app.user.id)
                .single();

            if (profileError) {
                console.error('[Wizard] Error al obtener perfil:', profileError);
            }

            if (companyName && profile && profile.organization_id) {
                const { error: orgError } = await window.auth.sb
                    .from('organizations')
                    .update({ name: companyName })
                    .eq('id', profile.organization_id);

                if (orgError) {
                    console.warn('[Wizard] Error al actualizar nombre de empresa:', orgError);
                } else {
                    console.log('[Wizard] Nombre de empresa actualizado en organizations');
                }
            }

            const settingsData = {
                work_start_hour: startHourInput ? parseInt(startHourInput.split(':')[0]) : null,
                work_end_hour: endHourInput ? parseInt(endHourInput.split(':')[0]) : null,
                company_description: this.companyForm.querySelector('#wizard-company-description').value,
                website: this.companyForm.querySelector('#wizard-website').value,
                social_media: {
                    instagram: this.companyForm.querySelector('#wizard-social-instagram').value,
                    facebook: this.companyForm.querySelector('#wizard-social-facebook').value,
                },
                contact_phone: adminPhone,
                branding_settings: brandingSettings,
            };

            const { error } = await window.auth.sb.from('profiles').update(settingsData).eq('id', this.app.user.id);
            if (error) throw error;

            // Guardar tipo de negocio y configuración de citas
            const businessType = this.companyForm.querySelector('#wizard-business-type')?.value || 'both';

            // Siempre guardar/actualizar appointment_settings con business_type
            const appointmentSettings = {
                user_id: this.app.user.id,
                business_type: businessType,
            };

            // Si las citas están activadas, agregar configuración adicional
            const appointmentsEnabled = this.companyForm.querySelector('#wizard-appointments-enabled')?.checked || false;
            if (appointmentsEnabled) {
                const timezone = this.companyForm.querySelector('#wizard-appointment-timezone')?.value || 'America/Mexico_City';
                const defaultDuration = parseInt(this.companyForm.querySelector('#wizard-appointment-default-duration')?.value) || 60;

                appointmentSettings.is_enabled = true;
                appointmentSettings.calendar_type = 'internal';
                appointmentSettings.timezone = timezone;
                appointmentSettings.default_duration_minutes = defaultDuration;
                appointmentSettings.buffer_time_minutes = 0; // Cambiado de 15 a 0 para coincidir con Settings
                appointmentSettings.advance_booking_days = 30;
            } else {
                appointmentSettings.is_enabled = false;
            }

            const { error: appointmentError } = await window.auth.sb
                .from('appointment_settings')
                .upsert(appointmentSettings, { onConflict: 'user_id' });

            if (appointmentError) {
                console.warn('[Wizard] Error al guardar configuración de citas:', appointmentError);
            } else {
                console.log('[Wizard] Configuración de citas y tipo de negocio guardada');
            }

            this.companySnapshot = {
                ...settingsData,
                branding_settings: brandingSettings,
            };

            // ACTUALIZACIÓN DE UI EN TIEMPO REAL (Settings Panel)
            // Para asegurar consistencia si el usuario revisa la configuración inmediatamente
            const settingsForm = document.getElementById('settings-form');
            if (settingsForm) {
                const setVal = (id, val) => {
                    const el = document.getElementById(id);
                    if (el) el.value = val || '';
                };

                setVal('company-name', companyName);
                setVal('company-description', settingsData.company_description);
                setVal('website', settingsData.website);
                setVal('social-instagram', settingsData.social_media?.instagram);
                setVal('social-facebook', settingsData.social_media?.facebook);
                setVal('admin-phone-input', settingsData.contact_phone);
                setVal('work-start-hour', startHourInput);
                setVal('work-end-hour', endHourInput);
                setVal('business-type', businessType);

                // Actualizar colores
                brandingSettings.colors.forEach((c, i) => {
                    const el = document.getElementById(`brand-color-${i + 1}`);
                    if (el) el.value = c;
                });

                // Actualizar logo
                const logoPreview = document.getElementById('logo-preview');
                if (logoPreview && brandingSettings.logo_url) {
                    logoPreview.src = brandingSettings.logo_url;
                }

                // Actualizar configuración de citas
                const apptEnabled = document.getElementById('appointments-enabled');
                const apptConfigPanel = document.getElementById('appointments-config');

                if (apptEnabled) {
                    apptEnabled.checked = appointmentsEnabled;
                    if (appointmentsEnabled) {
                        apptConfigPanel?.classList.remove('hidden');
                    } else {
                        apptConfigPanel?.classList.add('hidden');
                    }
                }

                // Actualizar campos de citas
                if (appointmentsEnabled) {
                    const wizTz = this.companyForm.querySelector('#wizard-appointment-timezone')?.value;
                    const wizDur = this.companyForm.querySelector('#wizard-appointment-default-duration')?.value;
                    setVal('appointment-timezone', wizTz);
                    setVal('appointment-default-duration', wizDur);
                }
            }

            window.showToast('Información de la empresa guardada.', 'success');
            this.currentStep++; // Avanza manualmente
            this.updateStepUI();

        } catch (e) {
            console.error('Error al guardar configuración desde el wizard:', e);
            window.showToast('No se pudo guardar la información de la empresa.', 'error');
        } finally {
            this.nextBtn.disabled = false;
            this.nextBtn.innerHTML = 'Guardar y Seguir';
        }
    }

    async handleSyncClick() {
        const button = this.syncContactsBtn;
        if (!button || button.disabled) return; // CORRECCIÓN: Usar this.app.user.id

        const originalHtml = button.innerHTML;
        button.disabled = true;
        button.innerHTML = `<div class="animate-spin rounded-full h-5 w-5 border-b-2 border-white"></div>`;

        try {
            const userId = this.app.user.id;
            const webhookUrl = 'https://n8n-n8n.mcjhhb.easypanel.host/webhook/sync-labels-final';
            const response = await fetch(webhookUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ user_id: userId }),
            });

            if (!response.ok) throw new Error('La solicitud al webhook de sincronización falló.');

            window.showToast('Sincronización iniciada. Esto puede tardar unos minutos.', 'info');
            // El botón se quedará en estado de carga. El usuario puede continuar.
            // Opcional: podrías añadir lógica para volver al estado original después de un tiempo.
            setTimeout(() => {
                button.disabled = false;
                button.innerHTML = originalHtml;
            }, 60000); // Reactivar después de 1 minuto

        } catch (e) {
            console.error('Error al iniciar la sincronización desde el wizard:', e);
            window.showToast('No se pudo iniciar la sincronización.', 'error');
            button.disabled = false;
            button.innerHTML = originalHtml;
        }
    }

    async finish() {
        // Cambiar a la vista de carga
        this.modal.querySelectorAll('.wizard-step').forEach(step => step.classList.add('hidden')); // CORRECCIÓN: Faltaba el userId
        document.getElementById('wizard-step-5').classList.remove('hidden');
        document.getElementById('wizard-loading').classList.remove('hidden');
        document.getElementById('wizard-success').classList.add('hidden');
        this.prevBtn.parentElement.classList.add('hidden'); // Ocultar pie de página

        try {
            const qaForm = this.qaForm || this.modal?.querySelector('#wizard-qa-form');
            if (!qaForm) {
                throw new Error('No se encontro el formulario de preguntas del wizard.');
            }

            const formData = new FormData(qaForm);
            const answers = Object.fromEntries(formData.entries());

            const finalPrompt = this.buildPromptFromAnswers(answers);

            // Guardar el prompt en el dashboard y en la base de datos
            const promptTextarea = document.getElementById('ai-master-prompt');
            promptTextarea.value = finalPrompt;

            // Simular el guardado del formulario principal del prompt
            await this.app.handlePromptSave(new Event('submit', { cancelable: true })); // CORRECCIÓN: Usar this.app

            // Mostrar mensaje de éxito
            document.getElementById('wizard-loading').classList.add('hidden');
            document.getElementById('wizard-success').classList.remove('hidden');

            // Cerrar el modal después de unos segundos
            setTimeout(() => this.hide(), 4000);

        } catch (e) {
            console.error("Error al finalizar el wizard:", e);
            window.showToast('No se pudo generar el prompt. Inténtalo de nuevo.', 'error');
            // Revertir a la vista del formulario en caso de error
            this.currentStep = 4;
            this.updateStepUI();
            this.prevBtn.parentElement.classList.remove('hidden');
        }
    }

    buildPromptFromAnswers(answers) {
        const clean = (value) => (value || '').trim();
        const businessSummary = clean(answers.negocio);
        const clientProfile = clean(answers.cliente);
        const coreProblem = clean(answers.problema);
        const differentiator = clean(answers.diferenciador);
        const tone = clean(answers.tono) || 'amigable, profesional y proactivo';
        const forbiddenRaw = clean(answers.no_hacer);
        const priceGuideline = clean(answers.precios);
        const leadInfo = clean(answers.info_prospecto);
        const extraInfo = clean(answers.info_adicional);

        const company = this.companySnapshot || {};
        const companyDescription = clean(company.company_description);
        const website = clean(company.website);
        const contactPhone = clean(company.contact_phone);
        const instagram = clean(company.social_media?.instagram);
        const facebook = clean(company.social_media?.facebook);

        const workStart = typeof company.work_start_hour === 'number' ? company.work_start_hour : null;
        const workEnd = typeof company.work_end_hour === 'number' ? company.work_end_hour : null;

        const businessFocus = businessSummary || companyDescription || 'tu negocio';
        const roleLine = businessSummary
            ? `Eres el asistente principal de WhatsApp para ${businessSummary}.`
            : 'Eres un asistente virtual de WhatsApp enfocado en ventas, soporte y retencion.';
        const purposeLine = coreProblem
            ? `Tu objetivo es resolver la necesidad principal del cliente: ${coreProblem}.`
            : 'Tu objetivo es guiar, asesorar y convertir conversaciones de WhatsApp en oportunidades de negocio.';

        const toneLine = `Tu tono debe ser ${tone}.`;

        const knowledgeLine = extraInfo
            ? 'Basa tus respuestas en el contexto proporcionado por el negocio y en los datos que recibas en la conversacion. Si algo no esta en el contexto, puedes apoyarte en tu conocimiento general, pero debes indicarlo explicitamente.'
            : 'Debes basar TODAS tus respuestas unicamente en la informacion proporcionada por el usuario y en los datos recopilados durante la conversacion. Si no tienes un dato, solicita confirmacion.';

        const doRules = [
            'Redacta mensajes breves, claros y pensados para WhatsApp; separa ideas con lineas en blanco.',
            tone ? `Manten el tono descrito en CORE_IDENTITY en cada mensaje (${tone}).` : 'Manten un tono profesional y cercano en cada mensaje.',
        ];

        if (leadInfo) {
            doRules.push(`Cuando hables con nuevos prospectos, intenta obtener: ${leadInfo}.`);
        } else {
            doRules.push('Cuando recibas un posible prospecto, formula preguntas para conocer necesidad, presupuesto y forma de contacto.');
        }

        if (priceGuideline) {
            doRules.push(`Sigue estas pautas cuando consulten precios: ${priceGuideline}.`);
        }

        if (workStart !== null && workEnd !== null) {
            doRules.push(`Respeta el horario de atencion: ${workStart}:00 a ${workEnd}:00 hora local. Si escriben fuera de horario, agenda seguimiento.`);
        }

        if (contactPhone) {
            doRules.push(`Cuando sea necesario escalar, ofrece el numero directo ${contactPhone} o agenda una llamada.`);
        }

        const dontRules = [
            'No inventes precios, promociones ni compromisos si no fueron confirmados.',
            'No compartas informacion confidencial o interna que el negocio no haya autorizado.',
            'No olvides indicar cuando necesitas que un humano continúe la conversacion.',
        ];

        if (forbiddenRaw) {
            const parsed = forbiddenRaw
                .split(/[\n.;]+/g)
                .map((item) => clean(item))
                .filter(Boolean);
            parsed.forEach((item) => {
                const normalized = item.toLowerCase().startsWith('no') ? item : `No ${item}`;
                dontRules.push(normalized);
            });
        }

        const processSteps = [
            'Analizar: identifica la intencion principal del mensaje (venta, soporte, seguimiento o small talk).',
            'Consultar: repasa la base de conocimiento interna del negocio y la informacion recopilada en la conversacion.',
        ];

        if (priceGuideline) {
            processSteps.push('Formular: responde siguiendo las reglas de tono, precios y objetivos del negocio. Ofrece valor y menciona diferenciales cuando sea oportuno.');
        } else {
            processSteps.push('Formular: responde siguiendo las reglas de tono y objetivos del negocio. Ofrece valor y menciona diferenciales cuando sea oportuno.');
        }

        processSteps.push('Verificar: antes de enviar, confirma que cumples todas las reglas DO y DON\'T, y agrega una pregunta de seguimiento cuando corresponda.');

        const outputFormat = [
            'Usa texto plano con parrafos de maximo 2 oraciones cada uno. Separa parrafos con una linea en blanco.',
            'Incluye bullets simples (-) solo cuando enumeres opciones o pasos.',
            'Cierra con una pregunta o un siguiente paso claro para mantener la conversacion viva.',
            'Utiliza emojis solo cuando aporten cercania sin afectar la claridad.',
        ];

        const exampleUser1 = 'Hola, vi su anuncio y quiero saber en que pueden ayudarme.';
        const exampleAssistant1Parts = [];
        exampleAssistant1Parts.push('Hola, gracias por escribirnos. ' + (businessSummary || 'Estamos aqui para ayudarte a obtener resultados concretos.'));
        if (differentiator) {
            exampleAssistant1Parts.push(`Nos destacamos porque ${differentiator}.`);
        }
        exampleAssistant1Parts.push(leadInfo
            ? `Te parece si me cuentas ${leadInfo.toLowerCase()}?`
            : 'Te parece si me cuentas que servicio buscas y que objetivo tienes?');
        const exampleAssistant1 = exampleAssistant1Parts.join(' ');

        const exampleUser2 = 'Cuanto cuesta su servicio principal?';
        const exampleAssistant2Parts = [];
        if (priceGuideline) {
            exampleAssistant2Parts.push(priceGuideline);
        } else {
            exampleAssistant2Parts.push('Nuestros precios varian segun el alcance. Prefiero entender tu caso para darte una propuesta justa.');
        }
        exampleAssistant2Parts.push(leadInfo
            ? `Podrias compartir ${leadInfo.toLowerCase()}?`
            : 'Me cuentas que necesitas y en que plazo para prepararte una propuesta?');
        const exampleAssistant2 = exampleAssistant2Parts.join(' ');

        const badUser = 'Necesito un descuento grande, hazlo ya.';
        const badAssistantWrong = 'Claro, te doy 50% de descuento ahora mismo.';
        const badAssistantCorrect = forbiddenRaw
            ? `Quiero apoyarte, pero ${forbiddenRaw}. Puedo revisar alternativas con nuestro equipo si me das tus datos.`
            : 'Quiero apoyarte, pero no puedo aprobar descuentos sin validar internamente. Puedo llevar tu caso con un asesor si me compartes tus datos.';

        const lines = [];
        lines.push('# INICIO DE INSTRUCCIONES DE SISTEMA');
        lines.push('');
        lines.push('## 1. CORE_IDENTITY (Identidad y Rol)');
        lines.push(`**Rol:** ${roleLine}`);
        lines.push(`**Proposito Principal:** ${purposeLine}`);
        lines.push(`**Personalidad/Tono:** ${toneLine}`);
        lines.push('');
        lines.push('## 2. KNOWLEDGE_BASE (Base de Conocimiento)');
        lines.push(`**Alcance:** ${knowledgeLine}`);
        if (website || instagram || facebook) {
            const sources = [];
            if (website) sources.push(`Sitio web: ${website}`);
            if (instagram) sources.push(`Instagram: ${instagram}`);
            if (facebook) sources.push(`Facebook: ${facebook}`);
            lines.push(`**Fuentes de referencia disponibles:** ${sources.join(' | ')}`);
        }
        lines.push('');
        lines.push('## 3. RULES (Reglas y Restricciones)');
        lines.push('**Reglas Obligatorias (DO):**');
        doRules.forEach((rule) => lines.push(`* ${rule}`));
        lines.push('**Restricciones (DON\'T):**');
        dontRules.forEach((rule) => lines.push(`* ${rule}`));
        lines.push('');
        lines.push('## 4. PROCESS (Pasos a Seguir)');
        lines.push('**Al recibir una consulta del usuario, sigue estos pasos:**');
        processSteps.forEach((step, index) => lines.push(`${index + 1}. ${step}`));
        lines.push('');
        lines.push('## 5. OUTPUT_FORMAT (Formato de Salida)');
        lines.push('**Estructura de Respuesta:**');
        outputFormat.forEach((item) => lines.push(`* ${item}`));
        lines.push('');
        lines.push('## 6. FEW-SHOT_LEARNING (Ejemplos de Comportamiento)');
        lines.push('**Ejemplo 1 (Bueno):**');
        lines.push(`* **Usuario:** "${exampleUser1}"`);
        lines.push(`* **Asistente:** "${exampleAssistant1}"`);
        lines.push('');
        lines.push('**Ejemplo 2 (Bueno):**');
        lines.push(`* **Usuario:** "${exampleUser2}"`);
        lines.push(`* **Asistente:** "${exampleAssistant2}"`);
        lines.push('');
        lines.push('**Ejemplo 3 (Malo - Que evitar):**');
        lines.push(`* **Usuario:** "${badUser}"`);
        lines.push(`* **Asistente (Incorrecto):** "${badAssistantWrong}"`);
        lines.push(`* **Asistente (Correcto):** "${badAssistantCorrect}"`);
        lines.push('');
        lines.push('## 7. CONTEXT_AWARENESS (Conciencia de Contexto)');
        lines.push('**Reglas de Memoria Conversacional:**');
        lines.push('');
        lines.push('1. **NO REPITAS PREGUNTAS:**');
        lines.push('   - Si el cliente ya mencionó una cantidad, NO preguntes de nuevo');
        lines.push('   - Si el cliente ya mencionó una marca, NO preguntes de nuevo');
        lines.push('   - Si el cliente ya mencionó un modelo, NO preguntes de nuevo');
        lines.push('   - Si el cliente ya mencionó un producto, NO preguntes "¿qué producto necesitas?"');
        lines.push('');
        lines.push('2. **REVISA EL HISTORIAL COMPLETO:**');
        lines.push('   - Antes de hacer cualquier pregunta, revisa TODO el historial de la conversación');
        lines.push('   - Identifica qué información YA tienes');
        lines.push('   - Identifica qué información FALTA');
        lines.push('   - Usa la información del historial para evitar redundancias');
        lines.push('');
        lines.push('3. **PREGUNTA SOLO LO NECESARIO:**');
        lines.push('   - Si tienes producto + cantidad + marca → Procede directamente');
        lines.push('   - Si falta información crítica → Pregunta SOLO por lo que falta');
        lines.push('   - Si tienes suficiente → Ofrece agregar al carrito o generar cotización');
        lines.push('');
        lines.push('4. **CONFIRMACIÓN INTELIGENTE:**');
        lines.push('   - En lugar de preguntar de nuevo, confirma lo que entendiste:');
        lines.push('   - ❌ "¿Cuántas piezas necesitas?" (si ya lo dijo)');
        lines.push('   - ✅ "Perfecto, 3 piezas de CE285A para HP. ¿Algo más?"');
        lines.push('');
        lines.push('5. **PROACTIVIDAD:**');
        lines.push('   - Si detectas intención de compra clara, ofrece directamente:');
        lines.push('   - "¿Quieres que prepare tu cotización ahora?"');
        lines.push('   - "¿Te agrego esto a tu pedido?"');
        lines.push('');
        lines.push('6. **MENSAJES CONCISOS:**');
        lines.push('   - Evita escribir párrafos largos cuando una frase corta es suficiente');
        lines.push('   - Si el cliente pregunta "precio", responde directamente con el precio, no con un párrafo explicativo');
        lines.push('   - Mantén las respuestas relevantes y al punto');

        return lines.join('\n');
    }
}

/**
 * Renderiza el estado de la conexión de WhatsApp en uno o dos contenedores.
 * Siempre actualiza el contenedor principal del dashboard.
 * Opcionalmente, actualiza un segundo contenedor (ej. en un modal).
 * @param {string} status - 'initial', 'loading', 'qr', 'connected', 'error'.
 * @param {string|null} qrCodeBase64 - El código QR en base64 si el estado es 'qr'.
 * @param {string|null} secondaryContainerId - El ID de un segundo contenedor para actualizar.
 */
DashboardApp.prototype.renderWhatsappConnection = function (status, qrCodeBase64 = null, secondaryContainerId = null) {
    // CORRECCIÓN: Lógica de renderizado robusta para múltiples contenedores.
    const mainContainer = { el: document.getElementById('whatsapp-connection-container'), btn: document.getElementById('request-qr-btn') };
    const wizardContainer = { el: document.getElementById('wizard-qr-container'), btn: document.getElementById('wizard-request-qr-btn') };

    const containersToUpdate = [mainContainer];
    // Solo actualiza el contenedor del wizard si el modal está visible.
    if (wizardContainer.el && !document.getElementById('wizard-modal').classList.contains('hidden')) {
        containersToUpdate.push(wizardContainer);
    }

    containersToUpdate.forEach(container => {
        if (!container.el) return;
        let html = '';
        switch (status) {
            case 'connected':
                html = `<div class="flex flex-col items-center justify-center text-green-600 py-4"><i data-lucide="check-circle" class="w-16 h-16"></i><p class="font-bold mt-2">¡Conectado!</p></div>`;
                if (container.btn) container.btn.style.display = 'none';
                break;
            case 'loading':
                html = `<div class="flex justify-center items-center min-h-[200px]"><div class="animate-spin rounded-full h-16 w-16 border-b-2 border-slate-900"></div></div>`;
                if (container.btn) container.btn.style.display = 'block';
                break;
            case 'qr':
                html = `<img src="data:image/png;base64,${qrCodeBase64}" alt="Escanea para conectar WhatsApp" class="mx-auto max-w-full h-auto rounded-lg">`;
                if (container.btn) container.btn.style.display = 'block';
                break;
            case 'error':
                html = `<div class="flex flex-col items-center justify-center text-red-500 py-4"><i data-lucide="alert-triangle" class="w-16 h-16"></i><p class="font-bold mt-2">Error de Conexión</p></div>`;
                if (container.btn) container.btn.style.display = 'block';
                break;
            case 'initial':
            default:
                html = `<div class="flex flex-col items-center justify-center text-slate-400 py-4"><i data-lucide="qr-code" class="w-16 h-16"></i><p class="font-bold mt-2">Solicita el QR para vincular</p></div>`;
                if (container.btn) container.btn.style.display = 'block';
                break;
        }
        container.el.innerHTML = html;
    });
    lucide.createIcons();
}

DashboardApp.prototype.checkWhatsappConnection = async function (fromWizard = false, secondaryContainerId = null) {
    // CORRECCIÓN: Determinar si el modal del wizard está visible para saber si actualizarlo.
    const wizardModal = document.getElementById('wizard-modal');
    const isWizardVisible = wizardModal && !wizardModal.classList.contains('hidden');
    const finalSecondaryContainerId = isWizardVisible ? 'wizard-qr-container' : null;

    this.renderWhatsappConnection('loading', null, finalSecondaryContainerId);
    const url = `${this.config.N8N_URL}/webhook/generate-whatsapp-qr-Elina`;

    try {
        const response = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ email: this.user.email })
        });

        if (!response.ok) throw new Error('El servidor N8N no responde correctamente.');

        // CORRECCIÓN: Manejar respuesta vacía antes de parsear JSON
        const raw = await response.text();
        const trimmed = raw.trim();

        if (!trimmed) {
            this.renderWhatsappConnection('connected', null, finalSecondaryContainerId);
            return;
        }

        let data;
        try {
            data = JSON.parse(trimmed);
        } catch (parseError) {
            console.warn('Respuesta QR inesperada, se esperaba JSON.', parseError, raw);
            this.renderWhatsappConnection('error', null, finalSecondaryContainerId);
            return;
        }

        const result = Array.isArray(data) ? data[0] : data;
        const status = result?.qr_image_data ? 'qr' : 'connected';
        this.renderWhatsappConnection(status, result?.qr_image_data, finalSecondaryContainerId);
    } catch (error) {
        console.error("Error al solicitar QR:", error);
        this.renderWhatsappConnection('error', null, finalSecondaryContainerId);
    }
}

DashboardApp.prototype.openPromptHistory = async function () {
    const modal = document.getElementById('prompt-history-modal');
    const listContainer = document.getElementById('prompt-history-list');
    if (!modal || !listContainer) return;

    modal.classList.remove('hidden');
    listContainer.innerHTML = `
        <div class="flex flex-col items-center justify-center py-12">
            <div class="w-8 h-8 border-4 border-blue-200 border-t-blue-600 rounded-full animate-spin mb-4"></div>
            <p class="text-slate-500 font-medium">Cargando tu historial...</p>
        </div>
    `;

    try {
        const userId = await window.getUserId();
        if (!userId) {
            listContainer.innerHTML = '<p class="text-center text-red-500 py-8">Error: No se pudo identificar al usuario</p>';
            return;
        }

        const { data: versions, error } = await auth.sb
            .from('prompt_versions')
            .select('*')
            .eq('user_id', userId)
            .order('version_number', { ascending: false });

        if (error) throw error;

        let versionList = versions || [];

        // Si no hay versiones pero hay contenido en la tabla prompts, crear la v1 automáticamente
        if (versionList.length === 0) {
            const { data: currentPromptData } = await auth.sb
                .from('prompts')
                .select('prompt_content')
                .eq('user_id', userId)
                .single();

            if (currentPromptData?.prompt_content) {
                listContainer.innerHTML = '<p class="text-center text-slate-500 py-4 italic">Creando versión inicial...</p>';
                await auth.sb.rpc('create_prompt_version', {
                    p_user_id: userId,
                    p_prompt_content: currentPromptData.prompt_content,
                    p_change_reason: 'Respaldo automático inicial'
                });

                // Fetch simple instead of recursive call
                const { data: retry } = await auth.sb
                    .from('prompt_versions')
                    .select('*')
                    .eq('user_id', userId)
                    .order('version_number', { ascending: false });

                if (retry && retry.length > 0) {
                    // Update versions and continue to normal rendering
                    versionList = retry;
                }
            }

            if (versionList.length === 0) {
                listContainer.innerHTML = `
                    <div class="text-center py-12">
                        <div class="bg-slate-50 w-16 h-16 rounded-full flex items-center justify-center mx-auto mb-4">
                            <i data-lucide="history" class="w-8 h-8 text-slate-300"></i>
                        </div>
                        <p class="text-slate-500 font-medium">No hay versiones guardadas aún.</p>
                        <p class="text-xs text-slate-400 mt-1">Se crean cada vez que publicas un nuevo prompt oficial.</p>
                    </div>
                `;
                if (window.lucide) lucide.createIcons({ props: { element: listContainer } });
                return;
            }
        }


        listContainer.innerHTML = '';
        versionList.forEach(version => {
            const date = new Date(version.created_at);
            const formattedDate = date.toLocaleDateString('es-ES', { day: '2-digit', month: 'short', year: 'numeric', hour: '2-digit', minute: '2-digit' });

            const item = document.createElement('div');
            item.className = 'group bg-white border border-slate-200 rounded-xl overflow-hidden hover:border-blue-300 hover:shadow-md transition-all duration-200';
            item.innerHTML = `
                <div class="p-4 cursor-pointer flex items-center justify-between bg-slate-50/50 group-hover:bg-white transition-colors" onclick="this.nextElementSibling.classList.toggle('hidden')">
                    <div class="flex items-center gap-4">
                        <div class="bg-blue-100 text-blue-700 font-bold px-3 py-1 rounded-lg text-sm">v${version.version_number}</div>
                        <div>
                            <div class="text-sm font-bold text-slate-800">${formattedDate}</div>
                            ${version.change_reason ? `<div class="text-xs text-slate-500 line-clamp-1 italic">${escapeHtmlHelper(version.change_reason)}</div>` : '<div class="text-xs text-slate-400 italic font-mono">Sin descripción</div>'}
                        </div>
                    </div>
                    <i data-lucide="chevron-down" class="w-4 h-4 text-slate-400 group-hover:text-blue-500 transition-colors"></i>
                </div>
                <div class="hidden border-t border-slate-100 p-4 space-y-4">
                    <div class="relative">
                        <pre class="bg-slate-900 text-slate-300 p-4 rounded-lg text-xs font-mono overflow-auto max-h-60 leading-relaxed">${escapeHtmlHelper(version.prompt_content)}</pre>
                        <button class="copy-ver-btn absolute top-2 right-2 p-2 bg-slate-800/80 hover:bg-slate-700 text-white rounded-md transition-all opacity-0 group-hover:opacity-100" title="Copiar contenido">
                            <i data-lucide="copy" class="w-3 h-3"></i>
                        </button>
                    </div>
                    <div class="flex gap-2">
                        <button class="restore-ver-btn flex-1 bg-blue-600 text-white font-bold py-2 rounded-lg hover:bg-blue-700 transition-all flex items-center justify-center gap-2 text-sm shadow-sm">
                            <i data-lucide="rotate-ccw" class="w-4 h-4"></i> Restaurar esta Versión
                        </button>
                        <button class="view-ver-btn flex-1 bg-white border border-slate-200 text-slate-700 font-bold py-2 rounded-lg hover:bg-slate-50 transition-all flex items-center justify-center gap-2 text-sm">
                            <i data-lucide="eye" class="w-4 h-4"></i> Usar en Editor
                        </button>
                    </div>
                </div>
            `;

            // Tooltips e iconos
            if (window.lucide) lucide.createIcons({ props: { element: item } });

            // Event Listeners
            item.querySelector('.copy-ver-btn').onclick = (e) => {
                e.stopPropagation();
                navigator.clipboard.writeText(version.prompt_content);
                window.showToast?.('Contenido copiado al portapapeles', 'info');
            };

            item.querySelector('.restore-ver-btn').onclick = (e) => {
                e.stopPropagation();
                this.restorePromptVersion(version);
            };

            item.querySelector('.view-ver-btn').onclick = (e) => {
                e.stopPropagation();
                const textarea = document.getElementById('ai-master-prompt') || document.getElementById('prompt-editor');
                if (textarea) {
                    textarea.value = version.prompt_content;
                    this.closePromptHistory();
                    window.showToast?.(`Contenido de v${version.version_number} cargado en el editor.`, 'info');
                    // Scroll al textarea si no es visible
                    textarea.scrollIntoView({ behavior: 'smooth' });
                }
            };

            listContainer.appendChild(item);
        });

    } catch (error) {
        console.error('Error al cargar historial:', error);
        listContainer.innerHTML = `
            <div class="text-center py-12">
                <div class="bg-red-50 w-16 h-16 rounded-full flex items-center justify-center mx-auto mb-4">
                    <i data-lucide="alert-circle" class="w-8 h-8 text-red-500"></i>
                </div>
                <p class="text-red-500 font-bold">Error al cargar historial</p>
                <p class="text-xs text-slate-400 mt-1">${error.message || 'Error de conexión'}</p>
            </div>
        `;
        if (window.lucide) lucide.createIcons({ props: { element: listContainer } });
    }
};


DashboardApp.prototype.closePromptHistory = function () {
    const modal = document.getElementById('prompt-history-modal');
    if (modal) modal.classList.add('hidden');
};

DashboardApp.prototype.restorePromptVersion = async function (version) {
    if (!confirm(`¿Estás seguro de restaurar definitivamente la versión ${version.version_number}? Se publicará como el contenido oficial actual.`)) {
        return;
    }

    try {
        window.showToast?.('Restaurando versión...', 'info');

        // 1. Actualizar tabla prompts
        const { error: promptError } = await auth.sb
            .from('prompts')
            .upsert({
                user_id: this.user.id,
                prompt_content: version.prompt_content,
                updated_at: new Date().toISOString()
            }, { onConflict: 'user_id' });

        if (promptError) throw promptError;

        // 2. Crear nueva entrada en el historial para esta restauración
        await auth.sb.rpc('create_prompt_version', {
            p_user_id: this.user.id,
            p_prompt_content: version.prompt_content,
            p_change_reason: `Restaurada versión v${version.version_number}`
        });

        // 3. Actualizar UI
        const mainTextarea = document.getElementById('ai-master-prompt');
        const trainingTextarea = document.getElementById('prompt-editor');

        if (mainTextarea) mainTextarea.value = version.prompt_content;
        if (trainingTextarea) trainingTextarea.value = version.prompt_content;

        this.closePromptHistory();
        window.showToast?.(`Versión v${version.version_number} restaurada y publicada con éxito.`, 'success');

        await this.updatePromptVersionIndicator();
        if (typeof updatePromptVersionIndicator === 'function') {
            await updatePromptVersionIndicator(this.user.id);
        }
    } catch (err) {
        console.error('Error al restaurar:', err);
        window.showToast?.('Error al restaurar la versión', 'error');
    }
};


function escapeHtmlHelper(text) {
    if (!text) return '';
    return text
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
}

