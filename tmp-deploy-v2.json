[{"name":"agents/conversational.ts","content":"/**\r\n * ELINA V5 - Conversational Agent\r\n * \r\n * Agente conversacional principal usando OpenRouter con GPT-5-nano\r\n */\r\n\r\nimport type { SupabaseClient } from 'https://esm.sh/@supabase/supabase-js@2'\r\nimport type { AccountConfig, IntentDetectionResult, ConversationContext, AgentResponse, Message, ToolResult, ToolCall } from '../config/types.ts'\r\nimport { DEFAULT_MODEL, DEFAULT_TEMPERATURE, DEFAULT_MAX_TOKENS, OPENROUTER_API_URL } from '../config/constants.ts'\r\n\r\n/**\r\n * Ejecuta el agente conversacional\r\n */\r\nexport async function runConversationalAgent(\r\n    supabase: SupabaseClient,\r\n    config: AccountConfig,\r\n    userMessage: string,\r\n    intent: IntentDetectionResult,\r\n    context: ConversationContext,\r\n    toolCalls?: ToolCall[],     // ‚Üê Tool calls originales del assistant\r\n    toolResults?: ToolResult[]  // ‚Üê Resultados de herramientas ejecutadas\r\n): Promise<AgentResponse> {\r\n    console.log(`ü§ñ [AGENT] Running conversational agent`)\r\n    console.log(`   - Intent: ${intent.primary}`)\r\n    console.log(`   - Sentiment: ${intent.sentiment.polarity} (${intent.sentiment.score})`)\r\n\r\n    const startTime = performance.now()\r\n\r\n    // 1. Construir system prompt\r\n    const systemPrompt = await buildSystemPrompt(config, intent, context)\r\n\r\n    // 2. Preparar mensajes\r\n    const messages: any[] = [\r\n        { role: 'system', content: systemPrompt },\r\n        ...context.recentMessages.slice(-15), // √öltimos 15 mensajes para mantener contexto de conversaci√≥n\r\n        { role: 'user', content: userMessage }\r\n    ]\r\n\r\n    // Si hay tool calls y results, construir el flujo completo\r\n    if (toolCalls && toolCalls.length > 0 && toolResults && toolResults.length > 0) {\r\n        // Agregar el mensaje del assistant con tool_calls\r\n        messages.push({\r\n            role: 'assistant',\r\n            content: null,\r\n            tool_calls: toolCalls\r\n        })\r\n        // Agregar los resultados de las herramientas\r\n        messages.push(...toolResults)\r\n    }\r\n\r\n    // 3. Llamar a OpenRouter\r\n    const openrouterKey = Deno.env.get('OPENROUTER_API_KEY')\r\n    if (!openrouterKey) {\r\n        throw new Error('OPENROUTER_API_KEY not found in environment')\r\n    }\r\n\r\n    try {\r\n        const response = await fetch(OPENROUTER_API_URL, {\r\n            method: 'POST',\r\n            headers: {\r\n                'Authorization': `Bearer ${openrouterKey}`,\r\n                'HTTP-Referer': 'https://elina.ai',\r\n                'X-Title': 'ELINA V5',\r\n                'Content-Type': 'application/json'\r\n            },\r\n            body: JSON.stringify({\r\n                model: config.model || DEFAULT_MODEL,\r\n                messages,  // Ya incluye tool results si existen\r\n                temperature: config.temperature || DEFAULT_TEMPERATURE,\r\n                max_tokens: config.maxTokens || DEFAULT_MAX_TOKENS,\r\n                // Tools solo en la primera llamada (cuando no hay toolResults)\r\n                ...(toolResults && toolResults.length > 0 ? {} : {\r\n                    tools: getAvailableTools(config, intent),\r\n                    tool_choice: 'auto'\r\n                })\r\n            })\r\n        })\r\n\r\n        if (!response.ok) {\r\n            const errorText = await response.text()\r\n            throw new Error(`OpenRouter API error: ${response.status} ${response.statusText} - ${errorText}`)\r\n        }\r\n\r\n        const data = await response.json()\r\n        const duration = performance.now() - startTime\r\n\r\n        console.log(`‚úÖ [AGENT] Response generated in ${duration.toFixed(0)}ms`)\r\n        console.log(`   - Model: ${data.model || config.model}`)\r\n        console.log(`   - Tokens: ${data.usage?.total_tokens || 'unknown'}`)\r\n\r\n        // 4. Procesar respuesta\r\n        const choice = data.choices[0]\r\n\r\n        return {\r\n            text: choice.message.content || '',\r\n            toolCalls: choice.message.tool_calls || [],\r\n            metadata: {\r\n                model: data.model || config.model,\r\n                tokensUsed: data.usage?.total_tokens || 0,\r\n                finishReason: choice.finish_reason || 'stop',\r\n                duration\r\n            }\r\n        }\r\n    } catch (error) {\r\n        console.error(`‚ùå [AGENT] Error calling OpenRouter: ${error.message}`)\r\n        throw error\r\n    }\r\n}\r\n\r\n/**\r\n * Construye el system prompt din√°micamente\r\n */\r\nasync function buildSystemPrompt(\r\n    config: AccountConfig,\r\n    intent: IntentDetectionResult,\r\n    context: ConversationContext\r\n): Promise<string> {\r\n    let prompt = `Eres el asistente virtual de ${config.companyName}, un chatbot de ventas y atenci√≥n al cliente ${config.tone} y profesional.\r\n\r\n## Informaci√≥n de la Empresa\r\n${config.website ? `Sitio web: ${config.website}` : ''}\r\n${config.businessPhone ? `\\nTel√©fono: ${config.businessPhone}` : ''}\r\n${config.businessAddress ? `\\nDirecci√≥n: ${config.businessAddress}` : ''}\r\n`\r\n\r\n    // CR√çTICO: Solo incluir descripci√≥n de empresa si NO es consulta de productos\r\n    // Esto evita que el LLM invente productos bas√°ndose en la descripci√≥n\r\n    if (intent.primary !== 'product_inquiry') {\r\n        prompt += `\\n${config.companyDescription || 'Empresa dedicada a ofrecer productos y servicios de calidad.'}\r\n`\r\n    }\r\n\r\n    prompt += `\r\n## Tu Misi√≥n\r\n- Responder de forma natural y conversacional, como un humano por WhatsApp\r\n- Ser BREVE: m√°ximo 2-3 l√≠neas por mensaje (como un mensaje de texto real)\r\n- Ir directo al grano, sin rodeos ni explicaciones largas\r\n- Detectar las necesidades del cliente y ofrecer soluciones\r\n- Mantener un tono ${config.tone} pero casual\r\n- Usar emojis ocasionalmente (1-2 por mensaje m√°ximo) üòä\r\n- Si hay mucha info, dividir en mensajes cortos en lugar de un mensaje largo\r\n- Responder como si estuvieras chateando, no escribiendo un email\r\n\r\n## Capacidades Disponibles\r\n\r\n**IMPORTANTE: FECHA ACTUAL**\r\nHoy es: ${new Date().toLocaleString('es-MX', { timeZone: config.timezone || 'America/Mexico_City', weekday: 'long', year: 'numeric', month: 'long', day: 'numeric', hour: '2-digit', minute: '2-digit' })}.\r\nUsa esta fecha como referencia absoluta para \"ma√±ana\", \"lunes\", etc.\r\n`\r\n\r\n    // REGLAS CR√çTICAS SOBRE PRODUCTOS\r\n    prompt += `\\nüö® **REGLAS CR√çTICAS SOBRE PRODUCTOS** üö®\\n`\r\n    prompt += `1. NUNCA respondas sobre productos sin usar la herramienta buscar_productos primero.\\n`\r\n    prompt += `2. NUNCA inventes productos, servicios o caracter√≠sticas bas√°ndote en la descripci√≥n de la empresa.\\n`\r\n    prompt += `3. Si el usuario pregunta \"qu√© vendes?\", \"qu√© productos tienes?\", \"qu√© manejas?\", etc., DEBES usar buscar_productos con query vac√≠a (\"\") para obtener el cat√°logo real.\\n`\r\n    prompt += `4. Si buscar_productos devuelve 0 resultados, significa que NO lo tenemos. Di: \"No manejo esa marca/modelo actualmente.\"\\n`\r\n    prompt += `5. NUNCA digas \"tengo otros modelos\" o \"puedo buscar otros\" si la b√∫squeda fall√≥.\\n`\r\n    prompt += `6. Solo menciona productos que REALMENTE encontraste con la herramienta.\\n`\r\n    prompt += `7. PROHIBIDO asumir que vendes algo solo porque est√° en la descripci√≥n de la empresa.\\n`\r\n\r\n    if (config.appointmentsEnabled) {\r\n        prompt += `‚úÖ **Citas**: Puedes consultar disponibilidad y agendar citas.\\n`\r\n    }\r\n\r\n    if (config.quotesEnabled) {\r\n        prompt += `‚úÖ **Cotizaciones**: Puedes generar cotizaciones en PDF cuando el cliente lo solicite.\\n`\r\n    }\r\n\r\n    if (config.hasShipping) {\r\n        prompt += `‚úÖ **Env√≠os**: Ofrecemos servicio de env√≠o a domicilio.\\n`\r\n    }\r\n\r\n    // Agregar contexto RAG si existe\r\n    if (context.ragContext) {\r\n        prompt += `\\n## Informaci√≥n Relevante de la Base de Conocimientos\\n${context.ragContext}\\n`\r\n    }\r\n\r\n    // Agregar aprendizajes de largo plazo\r\n    if (context.accountLearnings && context.accountLearnings.length > 0) {\r\n        prompt += `\\n## Aprendizajes Previos\\n`\r\n        context.accountLearnings.forEach(learning => {\r\n            prompt += `- ${learning.content}\\n`\r\n        })\r\n    }\r\n\r\n    // Agregar preferencias del usuario\r\n    if (context.userPreferences && context.userPreferences.length > 0) {\r\n        prompt += `\\n## Preferencias del Cliente\\n`\r\n        context.userPreferences.forEach(pref => {\r\n            prompt += `- ${pref.key}: ${pref.value}\\n`\r\n        })\r\n    }\r\n\r\n    // Agregar promociones activas\r\n    if (context.activePromotions && context.activePromotions.length > 0) {\r\n        prompt += `\\n## Promociones Activas\\n`\r\n        context.activePromotions.forEach(promo => {\r\n            prompt += `- **${promo.title}**: ${promo.description || ''}\\n`\r\n            if (promo.discount) prompt += `  Descuento: ${promo.discount}\\n`\r\n        })\r\n    }\r\n\r\n    // üî• PRODUCTOS MENCIONADOS RECIENTEMENTE (con FAQs para follow-up questions)\r\n    if (context.recentlyMentionedProducts && context.recentlyMentionedProducts.length > 0) {\r\n        const { formatCachedProductsForPrompt } = await import('../utils/product-cache.ts')\r\n        prompt += formatCachedProductsForPrompt(context.recentlyMentionedProducts)\r\n        prompt += `\\n**IMPORTANTE:** Si el cliente hace preguntas sobre estos productos (ej: \"¬øc√≥mo funciona?\", \"¬øes compatible?\"), usa la informaci√≥n de FAQs arriba. NO necesitas buscar de nuevo.\\n`\r\n    }\r\n\r\n    // Instrucciones espec√≠ficas seg√∫n intenci√≥n\r\n    if (intent.primary === 'product_inquiry') {\r\n        prompt += `\\n## üéØ ACCI√ìN REQUERIDA: CONSULTA DE PRODUCTOS\r\n\r\n**PASO 1 - OBLIGATORIO:** Usa la herramienta buscar_productos AHORA.\r\n- Si el usuario pregunta \"qu√© vendes?\", \"qu√© productos?\", \"qu√© tienes?\": usa query=\"\" (vac√≠o) para ver TODO el cat√°logo\r\n- Si pregunta por algo espec√≠fico (ej: \"migra√±a\", \"665\", \"105X\"): usa ese t√©rmino como query\r\n\r\n**PASO 2:** Bas√°ndote SOLO en los resultados de la herramienta:\r\n- Si encontraste productos: menciona usando placeholders (OPCIONAL):\r\n  * Nombre: [PRODUCT_NAME:ID] o el nombre directamente\r\n  * Precio: [PRODUCT_PRICE:ID] o el precio directamente\r\n  * Stock: [PRODUCT_STOCK:ID]\r\n  * Descripci√≥n: [PRODUCT_DESC:ID]\r\n- Si NO encontraste nada (0 resultados): di \"No manejo esa marca/modelo actualmente.\"\r\n- **üñºÔ∏è MEDIA**: NO necesitas mencionar [PRODUCT_MEDIA:ID] - el sistema env√≠a im√°genes/videos autom√°ticamente si el producto las tiene\r\n\r\n**EJEMPLOS:**\r\n- \"S√≠, tengo el [PRODUCT_NAME:123] por [PRODUCT_PRICE:123]\"\r\n- O simplemente: \"S√≠, tengo el HP 665 por $350. Hay 10 en stock\"\r\n\r\n‚Üí Si el producto tiene media_url, se enviar√° autom√°ticamente como imagen con tu texto como caption\r\n\r\n**üîé USO DE FAQs DE PRODUCTOS:**\r\n- La herramienta buscar_productos devuelve FAQs (preguntas frecuentes) para cada producto\r\n- Las FAQs contienen respuestas verificadas y espec√≠ficas sobre caracter√≠sticas, compatibilidad, uso, etc.\r\n- Si el cliente pregunta algo que est√° en las FAQs del producto, usa esa informaci√≥n para responder\r\n- Las FAQs son informaci√≥n CONFIABLE y REAL del producto\r\n- Ejemplo: Cliente: \"¬øEs compatible con Windows?\" ‚Üí Si hay FAQ que lo responde, √∫sala\r\n\r\n**PROHIBIDO:**\r\n‚ùå Responder sin usar la herramienta primero\r\n‚ùå Inventar productos bas√°ndote en la descripci√≥n de la empresa\r\n‚ùå Decir \"ofrecemos servicios en...\" sin verificar productos reales\r\n‚ùå Asumir que vendes algo solo porque suena l√≥gico\r\n‚ùå Enviar URLs de im√°genes manualmente (el sistema las env√≠a autom√°ticamente)\r\n`\r\n    }\r\n\r\n    if (intent.primary === 'appointment_request') {\r\n        prompt += `\\n## Contexto Actual\r\nEl cliente quiere agendar una cita.\r\nIMPORTANTE: \r\n1. PRIMERO usa consultar_disponibilidad para ver horarios disponibles.\r\n2. Si hay slots disponibles, mu√©stralos.\r\n3. CR√çTICO: Si el usuario elige un horario (ej: \"a las 3\", \"el de las 5\"), AGENDA INMEDIATAMENTE usando agendar_cita.\r\n4. NO preguntes \"¬øte gustar√≠a agendar?\" o \"¬øconfirmamos?\". HAZLO DIRECTAMENTE. Simplemente di: \"Listo, ha quedado agendada...\".\r\n5. Solo si el horario no es claro o no hay disponibilidad, pregunta.\r\n${context.appointmentSlots && context.appointmentSlots.length > 0 ? `\r\nHorarios disponibles:\r\n${context.appointmentSlots.map(s => `- ${s.date} a las ${s.time}`).join('\\n')}\r\n` : ''}\r\n`\r\n    }\r\n\r\n    if (intent.primary === 'complaint' || intent.primary === 'urgent_issue') {\r\n        prompt += `\\n## ALERTA: Intenci√≥n Cr√≠tica Detectada\r\nEl cliente tiene una queja o problema urgente. Responde con:\r\n1. Empat√≠a y disculpas sinceras\r\n2. Reconocimiento del problema\r\n3. Ofrecimiento de soluci√≥n inmediata\r\n4. Escalamiento a un humano si es necesario\r\n\r\nEjemplo: \"Lamento mucho escuchar eso üòî Entiendo tu frustraci√≥n y quiero ayudarte a resolver esto de inmediato. ¬øPodr√≠as darme m√°s detalles para poder asistirte mejor?\"\r\n`\r\n    }\r\n\r\n    // Prompt personalizado del usuario\r\n    if (config.customPrompt) {\r\n        prompt += `\\n## Instrucciones Adicionales del Negocio\\n${config.customPrompt}\\n`\r\n    }\r\n\r\n    // Reglas generales\r\n    prompt += `\\n## Reglas Importantes\r\n1. S√â BREVE: M√°ximo 2-3 l√≠neas, como un mensaje de WhatsApp real\r\n2. NUNCA inventes informaci√≥n que no tengas\r\n3. Si no sabes algo, adm√≠telo brevemente y ofrece alternativas\r\n4. Usa placeholders [PRODUCT_NAME:ID] para productos\r\n5. Responde como humano casual, no como robot formal\r\n6. Usa emojis con moderaci√≥n (1-2 m√°ximo)\r\n7. Si detectas venta, cierra con CTA breve y claro\r\n8. EVITA p√°rrafos largos - divide en mensajes cortos si es necesario\r\n`\r\n\r\n    // CONTINUIDAD DE CONVERSACI√ìN\r\n    // Generar un resumen de los √∫ltimos mensajes para que SIEMPRE sepas de qu√© se habla\r\n    if (context.recentMessages && context.recentMessages.length > 0) {\r\n        const lastMessages = context.recentMessages.slice(-6)\r\n        const summaryLines = lastMessages.map(m => {\r\n            const role = m.role === 'user' ? 'Cliente' : 'T√∫'\r\n            // Truncar mensajes largos para el resumen\r\n            const content = m.content.length > 120 ? m.content.substring(0, 120) + '...' : m.content\r\n            return `${role}: ${content}`\r\n        })\r\n\r\n        prompt += `\\n## üß† Resumen de Conversaci√≥n Reciente\r\nIMPORTANTE: Estos son los √∫ltimos mensajes de esta conversaci√≥n. SIEMPRE mant√©n el hilo del tema.\r\nSi el cliente hace una pregunta de seguimiento (ej: \"c√≥mo?\", \"cu√°nto?\", \"y eso?\"), CONECTA con lo que se habl√≥ antes. NUNCA respondas \"¬øa qu√© te refieres?\" si el contexto es claro.\r\n\r\n${summaryLines.join('\\n')}\r\n`\r\n    }\r\n\r\n    return prompt\r\n}\r\n\r\n/**\r\n * Obtiene las herramientas disponibles seg√∫n configuraci√≥n\r\n */\r\nfunction getAvailableTools(config: AccountConfig, intent: IntentDetectionResult): any[] {\r\n    const tools: any[] = []\r\n\r\n    // Herramienta de b√∫squeda de productos\r\n    // SIEMPRE disponible si el usuario tiene productos, sin importar el intent\r\n    // El LLM decidir√° cu√°ndo usarla\r\n    if (config.hasProducts) {\r\n        tools.push({\r\n            type: 'function',\r\n            function: {\r\n                name: 'buscar_productos',\r\n                description: 'Busca productos en el cat√°logo bas√°ndose en una consulta de texto. √ösala cuando el cliente pregunte por productos, precios, SKUs, o qu√© vendes.',\r\n                parameters: {\r\n                    type: 'object',\r\n                    properties: {\r\n                        query: {\r\n                            type: 'string',\r\n                            description: 'Consulta de b√∫squeda (ej: \"zapatos deportivos\", \"laptop gaming\", \"105X\", \"migra√±a\")'\r\n                        },\r\n                        limit: {\r\n                            type: 'number',\r\n                            description: 'N√∫mero m√°ximo de resultados (default: 5)'\r\n                        }\r\n                    },\r\n                    required: ['query']\r\n                }\r\n            }\r\n        })\r\n    }\r\n\r\n    // Herramienta de agendamiento de citas\r\n    if (config.appointmentsEnabled && intent.primary === 'appointment_request') {\r\n        tools.push({\r\n            type: 'function',\r\n            function: {\r\n                name: 'agendar_cita',\r\n                description: 'Agenda una cita para el cliente',\r\n                parameters: {\r\n                    type: 'object',\r\n                    properties: {\r\n                        date: {\r\n                            type: 'string',\r\n                            description: 'Fecha de la cita (formato: YYYY-MM-DD)'\r\n                        },\r\n                        time: {\r\n                            type: 'string',\r\n                            description: 'Hora de la cita (formato: HH:MM)'\r\n                        },\r\n                        service_id: {\r\n                            type: 'number',\r\n                            description: 'ID del servicio (opcional)'\r\n                        },\r\n                        notes: {\r\n                            type: 'string',\r\n                            description: 'Notas adicionales (opcional)'\r\n                        }\r\n                    },\r\n                    required: ['date', 'time']\r\n                }\r\n            }\r\n        })\r\n\r\n        // Tool para consultar disponibilidad\r\n        tools.push({\r\n            type: 'function',\r\n            function: {\r\n                name: 'consultar_disponibilidad',\r\n                description: 'Consulta los horarios disponibles para una fecha espec√≠fica',\r\n                parameters: {\r\n                    type: 'object',\r\n                    properties: {\r\n                        date: {\r\n                            type: 'string',\r\n                            description: 'Fecha a consultar (formato: YYYY-MM-DD)'\r\n                        }\r\n                    },\r\n                    required: ['date']\r\n                }\r\n            }\r\n        })\r\n    }\r\n\r\n    return tools\r\n}\r\n"},{"name":"config/account-config.ts","content":"/**\n * ELINA V5 - Account Configuration Loader\n * \n * Carga toda la configuraci√≥n de una cuenta desde m√∫ltiples tablas de Supabase\n */\n\nimport type { SupabaseClient } from 'https://esm.sh/@supabase/supabase-js@2'\nimport type { AccountConfig, CriticalRule, AutoResponse, Profile } from './types.ts'\nimport { DEFAULT_MODEL, DEFAULT_TEMPERATURE, DEFAULT_MAX_TOKENS } from './constants.ts'\n\n/**\n * Carga la configuraci√≥n completa de una cuenta\n */\n/**\n * Carga la configuraci√≥n completa de una cuenta\n */\nexport async function loadAccountConfig(\n    supabase: SupabaseClient,\n    userId: string\n): Promise<AccountConfig> {\n    console.log(`üìã [CONFIG] Loading account configuration for user: ${userId}`)\n\n    // 1. Cargar datos en paralelo (New Schema)\n    const [\n        profileResult,\n        teamResult,\n        rulesResult\n    ] = await Promise.all([\n        supabase.from('profiles').select('*').eq('id', userId).single(),\n        supabase.from('teams').select('ignored_labels').eq('owner_id', userId).maybeSingle(),\n        supabase.from('automation_rules').select('*').eq('user_id', userId).eq('is_active', true)\n    ])\n\n    if (profileResult.error || !profileResult.data) {\n        throw new Error(`Profile not found for user ${userId}: ${profileResult.error?.message}`)\n    }\n\n    const profile = profileResult.data as Profile\n    const team = teamResult.data\n    const allRules = (rulesResult.data || []) as any[] // Start as any to handle mapping\n\n    // 2. Map Automation Rules to Legacy Structures (for compatibility)\n    const criticalRules = allRules\n        .filter(r => r.type === 'critical')\n        .map(r => ({\n            id: r.id,\n            ruleName: r.name,\n            ruleType: r.trigger_type === 'pattern' ? 'pattern' : 'keyword',\n            patternOrKeyword: r.trigger_config?.pattern || r.trigger_config?.keyword || '',\n            detectionType: r.trigger_config?.detection_type || 'contains',\n            isActive: r.is_active,\n            priority: r.priority,\n            caseSensitive: false // Default\n        }))\n\n    const autoResponses = allRules\n        .filter(r => r.type === 'auto_response')\n        .map(r => ({\n            id: r.id,\n            triggerText: r.trigger_config?.keyword || '',\n            responseText: r.action_config?.response_text || '',\n            isActive: r.is_active,\n            matchType: r.trigger_config?.match_type || 'exact',\n            mediaUrl: r.action_config?.media_url,\n            mediaType: r.action_config?.media_type || 'text'\n        }))\n\n    // Extract settings from JSONB columns\n    const aptConfig = profile.appointment_config || {}\n    const quoteConfig = profile.quote_config || {}\n\n    // 3. Construir objeto de configuraci√≥n\n    const config: AccountConfig = {\n        // Identification\n        userId,\n        instanceName: profile.evolution_instance_name || '',\n        serverUrl: profile.evolution_api_url || 'https://evolutionapi-evolution-api.mcjhhb.easypanel.host', // Default as fallback\n\n        // AI Configuration\n        model: DEFAULT_MODEL,\n        temperature: DEFAULT_TEMPERATURE,\n        maxTokens: DEFAULT_MAX_TOKENS,\n\n        // Company Info\n        companyName: profile.full_name || 'Asistente',\n        companyDescription: profile.company_description || '',\n        website: profile.website,\n        businessAddress: profile.business_address,\n        businessPhone: profile.business_phone,\n        timezone: profile.timezone || 'America/Mexico_City',\n        slug: profile.slug,\n\n        // Personality\n        tone: 'profesional',\n        customPrompt: profile.system_prompt || undefined, // New Field\n\n        // Business Capabilities\n        businessType: (profile.business_type as any) || 'hybrid',\n        hasProducts: true, // Siempre permitir b√∫squeda de productos\n        hasServices: true, // Siempre permitir servicios\n        hasAppointments: !!(aptConfig.is_enabled),\n        hasQuotes: profile.quotes_enabled || false,\n        hasShipping: profile.has_shipping_system || false,\n        productCount: 0, // Deprecated - se calcula din√°micamente\n        serviceCount: 0, // Deprecated - se calcula din√°micamente\n\n        // Filters and Rules\n        ignoredLabels: team?.ignored_labels || [],\n        criticalRules: criticalRules as any[], // Explicit cast to avoid literal type mismatch\n        autoResponses,\n\n        // Integrations\n        evolutionApiKey: profile.evolution_api_key || '',\n        evolutionApiUrl: profile.evolution_api_url || 'https://evolutionapi-evolution-api.mcjhhb.easypanel.host',\n        elevenLabsVoiceId: undefined,\n\n        // Working Hours\n        workStartHour: profile.work_start_hour || 9,\n        workEndHour: profile.work_end_hour || 18,\n\n        // Limits\n        maxMessagesPerDay: undefined,\n\n        // Features\n        quotesEnabled: profile.quotes_enabled || false,\n        appointmentsEnabled: !!(aptConfig.is_enabled),\n        remindersEnabled: false\n    }\n\n    console.log(`‚úÖ [CONFIG] Configuration loaded successfully (New Schema)`)\n    console.log(`   - Company: ${config.companyName}`)\n    console.log(`   - Instance: ${config.instanceName}`)\n    console.log(`   - API Key Present: ${config.evolutionApiKey ? 'YES' : 'NO'} (${config.evolutionApiKey.substring(0, 4)}...)`)\n    return config\n}\n\n/**\n * Valida que la configuraci√≥n de la cuenta sea v√°lida\n */\nexport function validateAccountConfig(config: AccountConfig): { valid: boolean; errors: string[] } {\n    const errors: string[] = []\n\n    if (!config.userId) {\n        errors.push('Missing userId')\n    }\n\n    if (!config.instanceName) {\n        errors.push('Missing instanceName')\n    }\n\n    if (!config.evolutionApiKey) {\n        errors.push('Missing evolutionApiKey')\n    }\n\n    if (!config.companyName) {\n        errors.push('Missing companyName')\n    }\n\n    if (config.workStartHour < 0 || config.workStartHour > 23) {\n        errors.push('Invalid workStartHour (must be 0-23)')\n    }\n\n    if (config.workEndHour < 0 || config.workEndHour > 23) {\n        errors.push('Invalid workEndHour (must be 0-23)')\n    }\n\n    if (config.workStartHour >= config.workEndHour) {\n        errors.push('workStartHour must be less than workEndHour')\n    }\n\n    return {\n        valid: errors.length === 0,\n        errors\n    }\n}\n\n\n"},{"name":"config/constants.ts","content":"/**\n * ELINA V5 - Constants and Configuration\n * \n * Voy a usar supabase-ELINA\n * Confirmo: project_ref = mytvwfbijlgbihlegmfg\n */\n\n// API Configuration\nexport const OPENROUTER_API_URL = 'https://openrouter.ai/api/v1/chat/completions'\nexport const DEFAULT_MODEL = 'openai/gpt-4.1-mini'\nexport const FALLBACK_MODEL = 'openai/gpt-3.5-turbo'\n\n// Model Parameters\nexport const DEFAULT_TEMPERATURE = 0.7\nexport const DEFAULT_MAX_TOKENS = 1000\nexport const MAX_CONTEXT_MESSAGES = 10\n\n// Memory Configuration\nexport const REDIS_MESSAGE_BUFFER_TTL = 300 // 5 minutes\nexport const REDIS_MESSAGE_BUFFER_MAX = 10\nexport const CONVERSATION_SUMMARY_THRESHOLD = 20 // messages\n\n// Intent Detection\nexport const INTENT_CONFIDENCE_THRESHOLD = 0.7\nexport const CRITICAL_INTENT_THRESHOLD = 0.8\n\n// Delays (simulate human typing)\nexport const MIN_TYPING_DELAY = 500 // ms\nexport const MAX_TYPING_DELAY = 3000 // ms\nexport const CHARS_PER_SECOND = 50\n\n// Quote Generation\nexport const MIN_PRODUCTS_FOR_AUTO_QUOTE = 3\nexport const QUOTE_VALUE_THRESHOLD = 5000 // MXN\n\n// Embeddings\nexport const EMBEDDING_MODEL = 'text-embedding-3-small'\nexport const EMBEDDING_DIMENSIONS = 1536\nexport const RAG_SIMILARITY_THRESHOLD = 0.7\nexport const RAG_MAX_RESULTS = 5\n\n// Long-term Memory\nexport const LEARNING_CONFIDENCE_THRESHOLD = 0.6\nexport const LEARNING_USAGE_DECAY_DAYS = 30\n\n// Rate Limiting\nexport const MAX_MESSAGES_PER_MINUTE = 30\nexport const MAX_MESSAGES_PER_HOUR = 500\n\n// Evolution API\nexport const EVOLUTION_API_TIMEOUT = 10000 // ms\n\n// Bunny CDN\nexport const BUNNY_STORAGE_ZONE = 'elina-media'\nexport const BUNNY_CDN_URL = 'https://elina-media.b-cdn.net'\n\n// Feature Flags\nexport const ENABLE_LONG_TERM_MEMORY = true\nexport const ENABLE_SENTIMENT_ANALYSIS = true\nexport const ENABLE_OBJECTION_DETECTION = true\nexport const ENABLE_AUTO_LEARNING = true\n"},{"name":"config/types.ts","content":"/**\n * ELINA V5 - Type Definitions\n */\n\nimport type { SupabaseClient } from 'https://esm.sh/@supabase/supabase-js@2'\n\n// ============================================================================\n// Account Configuration\n// ============================================================================\n\nexport interface AccountConfig {\n    // Identification\n    userId: string\n    instanceName: string\n    serverUrl: string\n\n    // AI Configuration\n    model: string\n    temperature: number\n    maxTokens: number\n\n    // Company Info\n    companyName: string\n    companyDescription: string\n    website?: string\n    businessAddress?: string\n    businessPhone?: string\n    timezone: string\n    slug?: string // Company unique slug for profile link\n\n    // Personality\n    tone: 'profesional' | 'casual' | 'amigable' | 'formal'\n    customPrompt?: string\n\n    // Business Capabilities\n    businessType: 'ecommerce' | 'services' | 'hybrid' | 'appointments'\n    hasProducts: boolean\n    hasServices: boolean\n    hasAppointments: boolean\n    hasQuotes: boolean\n    hasShipping: boolean\n    productCount: number\n    serviceCount: number\n\n    // Filters and Rules\n    ignoredLabels: string[]\n    criticalRules: CriticalRule[]\n    autoResponses: AutoResponse[]\n\n    // Integrations\n    evolutionApiKey: string\n    evolutionApiUrl: string\n    elevenLabsVoiceId?: string\n\n    // Working Hours\n    workStartHour: number\n    workEndHour: number\n\n    // Limits\n    maxMessagesPerDay?: number\n\n    // Features\n    quotesEnabled: boolean\n    appointmentsEnabled: boolean\n    remindersEnabled: boolean\n}\n\n// ============================================================================\n// Rules and Responses\n// ============================================================================\n\nexport interface CriticalRule {\n    id: number\n    ruleName: string\n    ruleType: 'keyword' | 'pattern'\n    patternOrKeyword: string\n    detectionType: string\n    isActive: boolean\n    priority: number\n    caseSensitive: boolean\n}\n\nexport interface AutoResponse {\n    id: number\n    triggerText: string\n    responseText: string\n    isActive: boolean\n    matchType: 'exact' | 'contains'\n    mediaUrl?: string\n    mediaType: 'text' | 'image' | 'video' | 'audio' | 'document'\n}\n\n// ============================================================================\n// Intent Detection\n// ============================================================================\n\nexport enum Intent {\n    // Basic\n    GREETING = 'greeting',\n    FAREWELL = 'farewell',\n    GENERAL_QUESTION = 'general_question',\n\n    // Business\n    PRODUCT_INQUIRY = 'product_inquiry',\n    SERVICE_INQUIRY = 'service_inquiry',\n    PRICE_INQUIRY = 'price_inquiry',\n    STOCK_INQUIRY = 'stock_inquiry',\n    APPOINTMENT_REQUEST = 'appointment_request',\n    QUOTE_REQUEST = 'quote_request',\n    ORDER_STATUS = 'order_status',\n\n    // Critical\n    COMPLAINT = 'complaint',\n    URGENT_ISSUE = 'urgent_issue',\n    CANCELLATION = 'cancellation',\n    REFUND_REQUEST = 'refund_request',\n\n    // Conversational\n    SMALL_TALK = 'small_talk',\n    CLARIFICATION = 'clarification',\n    CONFIRMATION = 'confirmation',\n    OBJECTION = 'objection',\n\n    // Other\n    UNKNOWN = 'unknown'\n}\n\nexport interface IntentDetectionResult {\n    primary: Intent\n    secondary?: Intent[]\n    confidence: number\n    sentiment: SentimentAnalysis\n    entities: {\n        products?: string[]\n        services?: string[]\n        dates?: string[]\n        prices?: number[]\n        phoneNumbers?: string[]\n    }\n}\n\nexport interface SentimentAnalysis {\n    polarity: 'positive' | 'neutral' | 'negative'\n    score: number // -1 to 1\n    emotions?: string[]\n}\n\n// ============================================================================\n// Memory\n// ============================================================================\n\nexport interface ConversationContext {\n    // Recent Messages\n    recentMessages: Message[]\n\n    // Conversation Summary\n    summary?: string\n\n    // RAG Context\n    ragContext?: string\n\n    // Business Context\n    businessCapabilities?: BusinessCapabilities\n    topProducts?: Product[]\n    activePromotions?: Promotion[]\n    appointmentSlots?: AppointmentSlot[]\n    appointmentContext?: string\n\n    // User Preferences\n    userPreferences?: UserPreference[]\n\n    // Account Learnings\n    accountLearnings?: AccountLearning[]\n\n    // Conversation State (for contextual references)\n    conversationState?: ConversationContextState | null\n}\n\nexport interface MentionedProduct {\n    id: number\n    position: number  // 1, 2, 3... (order shown to user)\n    name: string\n    price: number\n    mentionedAt: string\n}\n\nexport interface CartItem {\n    product_id: number\n    quantity: number\n    addedAt: string\n}\n\nexport interface ConversationContextState {\n    lastProductsMentioned: MentionedProduct[]\n    tentativeCart: CartItem[]\n    lastIntent: string\n    lastAgentResponse?: string\n    appointmentContext?: any\n    potentialService?: {\n        id?: number\n        name: string\n    }\n    updatedAt: string\n}\n\nexport interface Message {\n    role: 'user' | 'assistant' | 'system'\n    content: string\n    timestamp?: Date\n}\n\nexport interface BusinessCapabilities {\n    primaryBusinessType: string | null\n    hasPhysicalProducts: boolean\n    productCount: number\n    hasServices: boolean\n    serviceCount: number\n    hasAppointments: boolean\n    appointmentCount: number\n    hasShippingSystem: boolean\n}\n\nexport interface Product {\n    id: number\n    productName: string\n    sku?: string\n    price: number\n    stock: number\n    description?: string\n    mediaUrl?: string\n    productType: 'physical' | 'service'\n    serviceDurationMinutes?: number\n}\n\nexport interface Promotion {\n    id: string\n    title: string\n    description?: string\n    benefits?: string\n    callToAction?: string\n    imageUrls?: string[]\n    discount?: string\n    offer?: string\n}\n\nexport interface AppointmentSlot {\n    start_time: string\n    end_time: string\n    service_id: number\n    service_name: string\n    duration_minutes: number\n    available?: boolean\n}\n\nexport interface UserPreference {\n    key: string\n    value: string\n    confidence: number\n    lastUpdated: Date\n}\n\nexport interface AccountLearning {\n    id: string\n    userId: string\n    learningType: 'pattern' | 'objection' | 'product_insight' | 'best_practice'\n    content: string\n    confidence: number\n    usageCount: number\n    lastUsed?: Date\n}\n\n// ============================================================================\n// Agent\n// ============================================================================\n\nexport interface AgentResponse {\n    text: string\n    toolCalls?: ToolCall[]\n    metadata: {\n        model: string\n        tokensUsed: number\n        finishReason: string\n        duration?: number\n    }\n}\n\nexport interface ToolCall {\n    id: string\n    type: 'function'\n    function: {\n        name: string\n        arguments: string\n    }\n}\n\n// ============================================================================\n// Database Types\n// ============================================================================\n\nexport interface Profile {\n    id: string\n    full_name?: string\n    email?: string\n    contact_phone?: string\n    evolution_instance_name?: string\n    evolution_api_key?: string\n    evolution_api_url?: string\n    company_description?: string\n    website?: string\n    business_address?: string\n    business_phone?: string\n    timezone?: string\n    slug?: string // Company slug for profile link\n    work_start_hour?: number\n    work_end_hour?: number\n    product_count?: number\n    service_count?: number\n    business_type?: string\n    quotes_enabled?: boolean\n    has_shipping_system?: boolean\n    // New fields for consolidation\n    system_prompt?: string\n    prompt_history?: any[]\n    appointment_config?: Record<string, any>\n    quote_config?: Record<string, any>\n    automation_settings?: Record<string, any>\n}\n\nexport interface AutomationRule {\n    id: string\n    user_id: string\n    name: string\n    type: 'critical' | 'auto_response' | 'promotion' | 'label_assignment'\n    trigger_type: 'keyword' | 'pattern' | 'intent' | 'schedule'\n    trigger_config: Record<string, any>\n    action_type: 'reply' | 'assign_label' | 'notify' | 'insert_content'\n    action_config: Record<string, any>\n    priority: number\n    is_active: boolean\n    created_at: string\n}\n\nexport interface Contact {\n    id: number\n    user_id: string\n    phone_number: string\n    full_name?: string\n    labels?: string[]\n    followup_status?: string\n    is_simulation?: boolean\n}\n\nexport interface Team {\n    id: string\n    owner_id: string\n    name: string\n    ignored_labels?: string[]\n}\n\nexport interface ConversationState {\n    id: number\n    contact_id: number\n    user_id: string\n    is_paused: boolean\n    pause_reason?: string\n    paused_at?: Date\n}\n\n// ============================================================================\n// Utility Types\n// ============================================================================\n\nexport interface FilterResult {\n    ignore: boolean\n    reason?: string\n}\n\nexport interface MediaProcessingResult {\n    transcription?: string\n    description?: string\n    mediaType: 'image' | 'audio' | 'video' | 'document'\n    success: boolean\n    error?: string\n}\n\nexport interface QuoteItem {\n    product_id: number\n    product_name: string\n    quantity: number\n    price: number\n    subtotal: number\n}\n\n\nexport interface PlaceholderResult {\n    finalText: string\n    productIds: number[]\n    productsMap: Record<string, Product>\n    shouldGenerateQuote: boolean\n    quoteItems: QuoteItem[]\n}\n\n// ============================================================================\n// Tool Calling\n// ============================================================================\n\nexport interface ToolCall {\n    id: string\n    type: 'function'\n    function: {\n        name: string\n        arguments: string  // JSON string\n    }\n}\n\nexport interface ToolResult {\n    tool_call_id: string\n    role: 'tool'\n    name: string\n    content: string  // JSON string\n}\n"},{"name":"core/filters.ts","content":"/**\n * ELINA V5 - Filters System\n * \n * Sistema de filtros para ignorar mensajes seg√∫n etiquetas, estado de conversaci√≥n, etc.\n */\n\nimport type { SupabaseClient } from 'https://esm.sh/@supabase/supabase-js@2'\nimport type { AccountConfig, FilterResult, Contact, ConversationState } from '../config/types.ts'\n\n/**\n * Determina si un mensaje debe ser ignorado\n */\nexport async function shouldIgnoreMessage(\n    supabase: SupabaseClient,\n    config: AccountConfig,\n    contactId: number\n): Promise<FilterResult> {\n    console.log(`üîç [FILTER] Checking if message should be ignored for contact ${contactId}`)\n\n    // 1. Obtener informaci√≥n del contacto\n    const { data: contact, error: contactError } = await supabase\n        .from('contacts')\n        .select('labels, is_simulation')\n        .eq('id', contactId)\n        .single()\n\n    if (contactError || !contact) {\n        console.warn(`‚ö†Ô∏è [FILTER] Contact not found: ${contactId}`)\n        return { ignore: false }\n    }\n\n    // 2. Verificar etiquetas ignoradas\n    const contactLabels = (contact as Contact).labels || []\n\n    // El usuario confirm√≥ expl√≠citamente: \"si entro de sus label existe 'ignorar' ingoramos\"\n    const hasIgnoredLabel = contactLabels.some(label =>\n        label.toLowerCase() === 'ignorar' ||\n        config.ignoredLabels.includes(label)\n    )\n\n    if (hasIgnoredLabel) {\n        console.log(`üö´ [FILTER] Contact has ignored label. Labels: ${contactLabels.join(', ')}`)\n        return {\n            ignore: true,\n            reason: `Contact marked as 'ignorar'`\n        }\n    }\n\n    // 3. Verificar si la conversaci√≥n est√° pausada\n    const { data: convState, error: convError } = await supabase\n        .from('conversation_states')\n        .select('is_paused, pause_reason')\n        .eq('contact_id', contactId)\n        .maybeSingle()\n\n    if (!convError && convState) {\n        const state = convState as ConversationState\n        if (state.is_paused) {\n            console.log(`‚è∏Ô∏è [FILTER] Conversation is paused: ${state.pause_reason}`)\n            return {\n                ignore: true,\n                reason: `Conversation paused: ${state.pause_reason || 'No reason provided'}`\n            }\n        }\n    }\n\n    // 4. Verificar horario laboral (solo si no es simulaci√≥n)\n    if (!contact.is_simulation) {\n        const now = new Date()\n        const currentHour = now.getHours()\n\n        if (currentHour < config.workStartHour || currentHour >= config.workEndHour) {\n            console.log(`üïê [FILTER] Outside working hours (${currentHour}:00, work hours: ${config.workStartHour}-${config.workEndHour})`)\n            // NO ignorar, pero podr√≠amos enviar un mensaje autom√°tico\n            // Por ahora, permitimos que el bot responda 24/7\n        }\n    }\n\n    console.log(`‚úÖ [FILTER] Message should be processed`)\n    return { ignore: false }\n}\n\n/**\n * Verifica si un contacto tiene una etiqueta espec√≠fica\n */\nexport async function contactHasLabel(\n    supabase: SupabaseClient,\n    contactId: number,\n    labelName: string\n): Promise<boolean> {\n    const { data, error } = await supabase\n        .from('contacts')\n        .select('labels')\n        .eq('id', contactId)\n        .single()\n\n    if (error || !data) {\n        return false\n    }\n\n    const labels = (data as Contact).labels || []\n    return labels.includes(labelName)\n}\n\n/**\n * Pausa una conversaci√≥n\n */\nexport async function pauseConversation(\n    supabase: SupabaseClient,\n    contactId: number,\n    userId: string,\n    reason: string\n): Promise<void> {\n    console.log(`‚è∏Ô∏è [FILTER] Pausing conversation for contact ${contactId}`)\n\n    const { error } = await supabase\n        .from('conversation_states')\n        .upsert({\n            contact_id: contactId,\n            user_id: userId,\n            is_paused: true,\n            pause_reason: reason,\n            paused_at: new Date().toISOString(),\n            paused_by: userId,\n            updated_at: new Date().toISOString()\n        }, {\n            onConflict: 'contact_id'\n        })\n\n    if (error) {\n        console.error(`‚ùå [FILTER] Error pausing conversation: ${error.message}`)\n        throw error\n    }\n\n    console.log(`‚úÖ [FILTER] Conversation paused successfully`)\n}\n\n/**\n * Reanuda una conversaci√≥n\n */\nexport async function resumeConversation(\n    supabase: SupabaseClient,\n    contactId: number,\n    userId: string\n): Promise<void> {\n    console.log(`‚ñ∂Ô∏è [FILTER] Resuming conversation for contact ${contactId}`)\n\n    const { error } = await supabase\n        .from('conversation_states')\n        .update({\n            is_paused: false,\n            pause_reason: null,\n            resumed_at: new Date().toISOString(),\n            resumed_by: userId,\n            updated_at: new Date().toISOString()\n        })\n        .eq('contact_id', contactId)\n\n    if (error) {\n        console.error(`‚ùå [FILTER] Error resuming conversation: ${error.message}`)\n        throw error\n    }\n\n    console.log(`‚úÖ [FILTER] Conversation resumed successfully`)\n}\n\n/**\n * Verifica si un mensaje es spam o abusivo\n */\nexport function isSpamOrAbusive(message: string): boolean {\n    // Detectar mensajes muy cortos repetidos\n    if (message.length < 3) {\n        return true\n    }\n\n    // Detectar caracteres repetidos excesivamente\n    const repeatedCharsRegex = /(.)\\1{10,}/\n    if (repeatedCharsRegex.test(message)) {\n        return true\n    }\n\n    // Detectar URLs sospechosas (opcional)\n    const suspiciousUrlRegex = /(bit\\.ly|tinyurl|goo\\.gl)/i\n    if (suspiciousUrlRegex.test(message)) {\n        console.warn(`‚ö†Ô∏è [FILTER] Suspicious URL detected in message`)\n        // No bloquear autom√°ticamente, solo advertir\n    }\n\n    return false\n}\n"},{"name":"index.ts","content":"/**\n * ELINA V5 - Main Orchestrator\n * \n * Voy a usar supabase-ELINA\n * Confirmo: project_ref = mytvwfbijlgbihlegmfg\n */\n\nimport { serve } from 'https://deno.land/std@0.168.0/http/server.ts'\nimport { createSupabaseAdminClient } from './utils/supabase.ts'\nimport { corsHeaders } from './utils/cors.ts'\nimport { loadAccountConfig, validateAccountConfig } from './config/account-config.ts'\nimport { shouldIgnoreMessage } from './core/filters.ts'\nimport { detectIntent, isCriticalIntent } from './intent/detector.ts'\nimport { runConversationalAgent } from './agents/conversational.ts'\nimport { sendMessage, sendImage, sendAudio } from './utils/evolution.ts'\nimport {\n    getProfileByInstance,\n    ensureContact,\n    loadConversationContext,\n    saveChatHistory\n} from './utils/context.ts'\n\nconsole.log('üöÄ ELINA V5 - Edge Function Started')\n\nserve(async (req) => {\n    // Handle CORS preflight\n    if (req.method === 'OPTIONS') {\n        return new Response('ok', { headers: corsHeaders })\n    }\n\n    const startTime = performance.now()\n\n    try {\n        const supabase = createSupabaseAdminClient()\n        const payload = await req.json()\n\n        console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ')\n        console.log('üîî [WEBHOOK] New message received')\n        console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ')\n\n        // ========================================================================\n        // 1. EXTRACT BASIC DATA\n        // ========================================================================\n        const data = payload?.data\n        if (!data) {\n            console.error('‚ùå [ERROR] Invalid payload: missing data')\n            return new Response(JSON.stringify({ error: 'Invalid payload' }), {\n                headers: { ...corsHeaders, 'Content-Type': 'application/json' },\n                status: 400\n            })\n        }\n\n        const { key, message, pushName } = data\n        let remoteJid = key?.remoteJid\n\n        // Handle LID (Linked Devices)\n        if (remoteJid?.includes('@lid')) {\n            remoteJid = key?.remoteJidAlt || remoteJid\n        }\n\n        // Clean suffix\n        remoteJid = remoteJid?.replace('@s.whatsapp.net', '')\n\n        const messageId = key?.id\n        const instanceName = payload?.instance\n        const isSimulation = payload?.isSimulation === true\n\n        console.log(`üìã [INFO] Instance: ${instanceName}`)\n        console.log(`üìã [INFO] Remote JID: ${remoteJid}`)\n        console.log(`üìã [INFO] Message ID: ${messageId}`)\n        console.log(`üìã [INFO] Simulation: ${isSimulation}`)\n\n        // Validate required fields\n        if (!remoteJid || !messageId || !instanceName) {\n            console.error('‚ùå [ERROR] Missing required fields')\n            return new Response(JSON.stringify({ error: 'Missing required fields' }), {\n                headers: corsHeaders,\n                status: 400\n            })\n        }\n\n        // Ignore status broadcasts and own messages\n        if (remoteJid === 'status@broadcast' || key?.fromMe) {\n            console.log('‚è≠Ô∏è [INFO] Ignoring status broadcast or own message')\n            return new Response(JSON.stringify({ ignored: true }), {\n                headers: corsHeaders,\n                status: 200\n            })\n        }\n\n        // ========================================================================\n        // 2. LOAD ACCOUNT CONFIGURATION\n        // ========================================================================\n        console.log(`\\nüìã [CONFIG] Loading account configuration...`)\n\n        const profile = await getProfileByInstance(supabase, instanceName)\n        const config = await loadAccountConfig(supabase, profile.id)\n\n        // Validate configuration\n        const validation = validateAccountConfig(config)\n        if (!validation.valid) {\n            console.error(`‚ùå [CONFIG] Invalid configuration: ${validation.errors.join(', ')}`)\n            return new Response(JSON.stringify({ error: 'Invalid account configuration', details: validation.errors }), {\n                headers: corsHeaders,\n                status: 500\n            })\n        }\n\n        console.log(`‚úÖ [CONFIG] Configuration loaded for: ${config.companyName}`)\n\n        // ========================================================================\n        // 3. ENSURE CONTACT EXISTS\n        // ========================================================================\n        console.log(`\\nüë§ [CONTACT] Ensuring contact exists...`)\n\n        const contact = await ensureContact(supabase, profile.id, remoteJid, pushName)\n        console.log(`‚úÖ [CONTACT] Contact ID: ${contact.id}`)\n\n        // ========================================================================\n        // 4. CHECK FILTERS\n        // ========================================================================\n        console.log(`\\nüîç [FILTER] Checking filters...`)\n\n        const filterResult = await shouldIgnoreMessage(supabase, config, contact.id)\n        if (filterResult.ignore) {\n            console.log(`üö´ [FILTER] Message ignored: ${filterResult.reason}`)\n            return new Response(JSON.stringify({\n                ignored: true,\n                reason: filterResult.reason\n            }), {\n                headers: corsHeaders,\n                status: 200\n            })\n        }\n\n        console.log(`‚úÖ [FILTER] Message should be processed`)\n\n        // ========================================================================\n        // 5. EXTRACT MESSAGE TEXT\n        // ========================================================================\n        let messageText = message.conversation ||\n            message.extendedTextMessage?.text ||\n            ''\n\n        if (!messageText) {\n            console.log('‚è≠Ô∏è [INFO] No text message found (media only or unsupported type)')\n            return new Response(JSON.stringify({ ignored: true, reason: 'No text content' }), {\n                headers: corsHeaders,\n                status: 200\n            })\n        }\n\n        console.log(`\\nüí¨ [MESSAGE] Text: \"${messageText.substring(0, 100)}${messageText.length > 100 ? '...' : ''}\"`)\n\n        // ========================================================================\n        // 5.5 MESSAGE BUFFERING (Group rapid consecutive messages)\n        // Uses Supabase table to coordinate between independent requests\n        // ========================================================================\n        if (!isSimulation) {\n            console.log(`\\n‚è≥ [BUFFER] Checking for rapid consecutive messages...`)\n            const { bufferMessage } = await import('./utils/message-buffer.ts')\n            const bufferResult = await bufferMessage(supabase, profile.id, contact.id, messageText)\n\n            if (!bufferResult.shouldProcess) {\n                // A newer message arrived ‚Äî this request should NOT process\n                console.log(`‚è≠Ô∏è [BUFFER] Deferring to newer message, this request ends here`)\n                return new Response(JSON.stringify({ buffered: true, reason: 'Deferred to newer message' }), {\n                    headers: { ...corsHeaders, 'Content-Type': 'application/json' },\n                    status: 200\n                })\n            }\n\n            messageText = bufferResult.combinedText\n            if (bufferResult.combinedText.includes('\\n')) {\n                console.log(`‚úÖ [BUFFER] Processing ${bufferResult.combinedText.split('\\n').length} combined messages`)\n            }\n        }\n\n        // ========================================================================\n        // 6. CHECK AUTO RESPONSES\n        // ========================================================================\n        console.log(`\\nü§ñ [AUTOMATION] Checking auto-responses...`)\n        const { checkAutoResponses } = await import('./utils/automation.ts')\n        const autoResponse = checkAutoResponses(messageText, config)\n\n        if (autoResponse) {\n            console.log(`‚úÖ [AUTOMATION] Auto-response triggered: ${autoResponse.triggerText}`)\n\n            // üîÑ NUEVO: Solo enviar si NO es simulaci√≥n\n            if (!isSimulation) {\n                await sendMessage(config, remoteJid, autoResponse.responseText)\n            }\n\n            // Save history\n            await saveChatHistory(\n                supabase,\n                profile.id,\n                contact.id,\n                messageText,\n                autoResponse.responseText,\n                {\n                    primary: 'auto_response' as any,\n                    confidence: 1.0,\n                    sentiment: { polarity: 'neutral', score: 0 },\n                    entities: {}\n                }\n            )\n\n            return new Response(JSON.stringify({\n                success: true,\n                intent: 'auto_response',\n                response: autoResponse.responseText\n            }), { headers: corsHeaders })\n        }\n\n        // ========================================================================\n        // 6. DETECT INTENT\n        // ========================================================================\n        console.log(`\\nüéØ [INTENT] Detecting intent...`)\n\n        const conversationHistory = await loadConversationContext(\n            supabase,\n            config,\n            contact,\n            messageText,\n            { primary: 'unknown' }\n        ).then(ctx => ctx.recentMessages)\n\n        const intent = await detectIntent(messageText, config, conversationHistory)\n\n        console.log(`‚úÖ [INTENT] Detected: ${intent.primary}`)\n        console.log(`   - Confidence: ${intent.confidence}`)\n        console.log(`   - Sentiment: ${intent.sentiment.polarity} (${intent.sentiment.score})`)\n\n        // Handle critical intents\n        if (isCriticalIntent(intent.primary)) {\n            console.log(`üö® [CRITICAL] Critical intent detected: ${intent.primary}`)\n            // TODO: Notify account owner\n        }\n\n        // ========================================================================\n        // 7. LOAD FULL CONTEXT\n        // ========================================================================\n        console.log(`\\nüìö [CONTEXT] Loading conversation context...`)\n\n        const context = await loadConversationContext(\n            supabase,\n            config,\n            contact,\n            messageText,\n            intent\n        )\n\n        console.log(`‚úÖ [CONTEXT] Context loaded`)\n        console.log(`   - Recent messages: ${context.recentMessages.length}`)\n        console.log(`   - Account learnings: ${context.accountLearnings?.length || 0}`)\n        console.log(`   - User preferences: ${context.userPreferences?.length || 0}`)\n\n        // ========================================================================\n        // 8. RUN CONVERSATIONAL AGENT\n        // ========================================================================\n        console.log(`\\nü§ñ [AGENT] Running conversational agent...`)\n\n        const agentResponse = await runConversationalAgent(\n            supabase,\n            config,\n            messageText,\n            intent,\n            context\n        )\n\n        // ========================================================================\n        // 8.5. EXECUTE TOOL CALLS (if any)\n        // ========================================================================\n        let executedToolResults: any[] = []  // üî• Guardar para recopilar media despu√©s\n\n        if (agentResponse.toolCalls && agentResponse.toolCalls.length > 0) {\n            console.log(`\\nüîß [TOOLS] Agent requested ${agentResponse.toolCalls.length} tool call(s)`)\n\n            const { executeToolCalls } = await import('./utils/tool-executor.ts')\n\n            const toolResults = await executeToolCalls(\n                supabase,\n                config,\n                contact.id,\n                agentResponse.toolCalls\n            )\n\n            executedToolResults = toolResults  // üî• Guardar para usar despu√©s\n\n            console.log(`‚úÖ [TOOLS] Tool calls executed, re-calling agent with results`)\n\n            // Re-llamar al agente con los resultados de las herramientas\n            const finalAgentResponse = await runConversationalAgent(\n                supabase,\n                config,\n                messageText,\n                intent,\n                context,\n                agentResponse.toolCalls,  // ‚Üê Pasar tool_calls originales\n                toolResults               // ‚Üê Pasar resultados\n            )\n\n            // Usar la respuesta final\n            agentResponse.text = finalAgentResponse.text\n            agentResponse.metadata = finalAgentResponse.metadata\n        }\n\n        if (!agentResponse.text || agentResponse.text.trim() === '') {\n            console.warn('‚ö†Ô∏è [AGENT] Empty response received. Using fallback.')\n            agentResponse.text = 'Lo siento, tuve un problema procesando tu mensaje. ¬øPodr√≠as repetirlo?'\n        }\n\n        console.log(`‚úÖ [AGENT] Response generated`)\n        console.log(`   - Length: ${agentResponse.text.length} chars`)\n        console.log(`   - Tokens used: ${agentResponse.metadata.tokensUsed}`)\n        console.log(`   - Duration: ${agentResponse.metadata.duration?.toFixed(0)}ms`)\n\n        // ========================================================================\n        // 9. PROCESS PLACEHOLDERS & EXTRACT MEDIA\n        // ========================================================================\n        console.log(`\\nüß© [PLACEHOLDERS] Processing placeholders...`)\n\n        const { processPlaceholders } = await import('./utils/placeholders.ts')\n\n        const placeholderResult = await processPlaceholders(\n            supabase,\n            config.userId,\n            agentResponse.text\n        )\n\n        let finalText = placeholderResult.finalText\n\n        // Variable to hold product media for later use\n        let productMediaForSending: Array<{ url: string, type: 'image' | 'video' }> = []\n\n        // ========================================================================\n        // 10. RECOPILAR MEDIA & CALCULATE TOTALS (C√ìDIGO HACE EL TRABAJO)\n        // ========================================================================\n        console.log(`\\nüñºÔ∏è [MEDIA] Collecting media from products and text... (v2.0 - UPDATED)`)\n\n        const mediaToSend: Array<{ url: string, type: 'image' | 'video', source: 'product' | 'text' }> = []\n\n        // --- A. PRIMERO: Media de productos (garantizada si el producto tiene media) ---\n        // Esto asegura que si un producto fue mencionado y tiene media, SE ENV√çA SIEMPRE\n        if (placeholderResult.productMedia && placeholderResult.productMedia.length > 0) {\n            console.log(`   - Found ${placeholderResult.productMedia.length} media from products (via placeholders)`)\n\n            placeholderResult.productMedia.forEach(media => {\n                mediaToSend.push({\n                    url: media.url,\n                    type: media.type,\n                    source: 'product'\n                })\n            })\n        }\n\n        // üî• FALLBACK: Tambi√©n buscar media en tool results (por si el LLM olvid√≥ usar placeholders)\n        if (executedToolResults.length > 0) {\n            console.log(`   - Checking tool results for additional product media...`)\n\n            for (const toolResult of executedToolResults) {\n                if (toolResult.role === 'tool' && toolResult.content) {\n                    try {\n                        const content = JSON.parse(toolResult.content)\n\n                        // Si es resultado de buscar_productos\n                        if (content.products && Array.isArray(content.products)) {\n                            console.log(`   - Found ${content.products.length} products in tool result`)\n\n                            content.products.forEach((product: any) => {\n                                if (product.media_url && product.media_url.trim()) {\n                                    const isVideo = /\\.(mp4|mov|avi|webm)$/i.test(product.media_url)\n\n                                    // Evitar duplicados (comparar URL)\n                                    if (!mediaToSend.find(m => m.url === product.media_url)) {\n                                        mediaToSend.push({\n                                            url: product.media_url,\n                                            type: isVideo ? 'video' : 'image',\n                                            source: 'product'\n                                        })\n                                        console.log(`   - Added media from product ID ${product.id}: ${product.media_url}`)\n                                    }\n                                }\n                            })\n                        }\n                    } catch (e) {\n                        // No es JSON v√°lido, continuar\n                    }\n                }\n            }\n        }\n\n        // --- B. SEGUNDO: Extracci√≥n adicional del texto (por si el LLM agreg√≥ media extra) ---\n        // 1. Detectar URLs de Markdown: ![alt](url)\n        const markdownRegex = /!\\[([^\\]]*)\\]\\((https:\\/\\/creativersezone\\.b-cdn\\.net\\/[^\\)]+\\.(jpg|jpeg|png|gif|webp|mp4|mov|avi|webm))\\)/gi\n        const markdownMatches = [...finalText.matchAll(markdownRegex)]\n\n        for (const match of markdownMatches) {\n            const url = match[2]\n            const isVideo = /\\.(mp4|mov|avi|webm)$/i.test(url)\n\n            // Solo agregar si no est√° ya en la lista (evitar duplicados con product media)\n            if (!mediaToSend.find(m => m.url === url)) {\n                mediaToSend.push({\n                    url: url,\n                    type: isVideo ? 'video' : 'image',\n                    source: 'text'\n                })\n            }\n        }\n\n        // 2. Detectar URLs puras (Raw)\n        const mediaUrlRegex = /https:\\/\\/creativersezone\\.b-cdn\\.net\\/[^\\s\\)]+\\.(jpg|jpeg|png|gif|webp|mp4|mov|avi|webm)/gi\n        let matches = finalText.match(mediaUrlRegex)\n\n        if (matches) {\n            for (const url of matches) {\n                const isVideo = /\\.(mp4|mov|avi|webm)$/i.test(url)\n\n                // Solo agregar si no est√° ya en la lista\n                if (!mediaToSend.find(m => m.url === url)) {\n                    mediaToSend.push({\n                        url: url,\n                        type: isVideo ? 'video' : 'image',\n                        source: 'text'\n                    })\n                }\n            }\n        }\n\n        // --- C. Limpieza de URLs y Markdown de Imagen del texto (GLOBAL) ---\n        // Remover markdown de imagen COMPLETO\n        finalText = finalText.replace(markdownRegex, '')\n\n        // Remover URLs sueltas globalmente\n        finalText = finalText.replace(mediaUrlRegex, '')\n\n        // --- D. Regla de Negocio: M√°ximo 3 media files ---\n        const MAX_MEDIA = 3\n        const finalMediaToSend = mediaToSend.slice(0, MAX_MEDIA)\n\n        if (mediaToSend.length > MAX_MEDIA) {\n            console.log(`   ‚ö†Ô∏è Limitando media: ${mediaToSend.length} encontrados -> enviando ${MAX_MEDIA}`)\n        }\n\n        // --- C. C√°lculos de Subtotales y Totales (L√≥gica n8n V4) ---\n        console.log(`\\nüßÆ [CALCS] Running n8n-style calculations...`)\n\n        // Regex para detectar l√≠neas de item y calcular subtotal\n        // Ejemplo: \"5 piezas Subtotal: $[subtotal_calculado]\"\n        const subtotalRegex = /(\\d+)\\s*piezas?\\s*Subtotal:\\s*\\$\\[subtotal_calculado\\]/gi\n        let totalAcumulado = 0\n\n        finalText = finalText.replace(subtotalRegex, (match, qtyStr, offset) => {\n            const qty = parseInt(qtyStr, 10)\n            // Buscar el precio anterior m√°s cercano en el texto\n            const textBefore = finalText.substring(0, offset)\n            const pricesFound = textBefore.match(/\\$([\\d,]+(?:\\.\\d{2})?)/g)\n\n            if (pricesFound && pricesFound.length > 0) {\n                const lastPriceStr = pricesFound[pricesFound.length - 1].replace(/[$,]/g, \"\")\n                const price = parseFloat(lastPriceStr)\n\n                if (!isNaN(price)) {\n                    const subtotal = qty * price\n                    totalAcumulado += subtotal\n                    return `${qty} piezas Subtotal: $${subtotal.toLocaleString('es-MX', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`\n                }\n            }\n            return match // Si no se encuentra precio, dejar igual\n        })\n\n        // Reemplazar placeholder de Total General\n        finalText = finalText.replace(/\\$\\[TOTAL_CALCULADO\\]/gi, \"$\" + totalAcumulado.toLocaleString(\"es-MX\", { minimumFractionDigits: 2, maximumFractionDigits: 2 }))\n\n        // --- D. Formato de Texto (Limpieza) ---\n        finalText = finalText\n            // Convertir negritas de Markdown (**) a WhatsApp (*)\n            .replace(/\\*\\*([^*]+)\\*\\*/g, '*$1*')\n            // Eliminar corchetes vac√≠os si quedaron de links mal formados \"[]()\"\n            .replace(/\\[\\s*\\]\\(\\s*\\)/g, '')\n            // Eliminar espacios m√∫ltiples\n            .replace(/\\s{2,}/g, ' ')\n            // Asegurar saltos de l√≠nea limpios (m√°ximo 2)\n            .replace(/\\n{3,}/g, '\\n\\n')\n            .trim()\n\n        const productMediaCount = mediaToSend.filter(m => m.source === 'product').length\n        const textMediaCount = mediaToSend.filter(m => m.source === 'text').length\n\n        console.log(`   - Found ${mediaToSend.length} total media URL(s)`)\n        console.log(`     ‚Ä¢ ${productMediaCount} from products (guaranteed)`)\n        console.log(`     ‚Ä¢ ${textMediaCount} from text (LLM generated)`)\n        console.log(`   - Sending ${finalMediaToSend.length} media file(s)`)\n        console.log(`   - Cleaned text length: ${finalText.length}`)\n\n        // üî• CRITICAL: Save media for later use in sending section\n        productMediaForSending = finalMediaToSend.map(m => ({ url: m.url, type: m.type }))\n\n        // ========================================================================\n        // 11. SEND RESPONSE WITH MEDIA (N8N V4 STYLE)\n        // ========================================================================\n        console.log(`\\nüì§ [SEND] Sending response...`)\n\n        // üîÑ NUEVO: Solo enviar mensajes reales si NO es simulaci√≥n\n        if (!isSimulation) {\n\n        if (finalMediaToSend.length > 0) {\n            console.log(`   - Sending ${finalMediaToSend.length} media message(s)`)\n\n            // ========================================================================\n            // DISTRIBUCI√ìN INTELIGENTE DE TEXTO ENTRE CAPTIONS (n8n V4 logic)\n            // ========================================================================\n\n            // Si tenemos productMedia (productos garantizados), usar distribuci√≥n inteligente\n            if (placeholderResult.productMedia && placeholderResult.productMedia.length > 0) {\n                console.log(`   - Using smart text distribution across product media`)\n\n                const { distributeTextAcrossProductMedia } = await import('./utils/text-formatter.ts')\n\n                const mediaWithCaptions = distributeTextAcrossProductMedia(\n                    finalText,\n                    placeholderResult.productMedia.slice(0, 3), // Max 3\n                    placeholderResult.productsMap,\n                    3\n                )\n\n                console.log(`   - Generated ${mediaWithCaptions.length} media with captions`)\n\n                // Enviar cada media con su caption\n                for (let i = 0; i < mediaWithCaptions.length; i++) {\n                    const item = mediaWithCaptions[i]\n\n                    console.log(`   - Sending media ${i + 1}/${mediaWithCaptions.length} (Product ID: ${item.productId})`)\n                    console.log(`     Caption length: ${item.caption.length} chars`)\n\n                    if (item.type === 'video') {\n                        const { sendVideo } = await import('./utils/evolution.ts')\n                        await sendVideo(config, remoteJid, item.url, item.caption)\n                    } else {\n                        await sendImage(config, remoteJid, item.url, item.caption)\n                    }\n\n                    // Delay entre mensajes\n                    if (i < mediaWithCaptions.length - 1) {\n                        await new Promise(r => setTimeout(r, 600))\n                    }\n                }\n\n            } else {\n                // ========================================================================\n                // FALLBACK: Media sin productos (media del texto LLM)\n                // ========================================================================\n                console.log(`   - Using fallback: media without product distribution`)\n\n                if (finalMediaToSend.length === 1) {\n                    // UNA SOLA MEDIA - Todo el texto como caption\n                    const media = finalMediaToSend[0]\n                    console.log(`   - Sending single media with full text as caption`)\n\n                    if (media.type === 'video') {\n                        const { sendVideo } = await import('./utils/evolution.ts')\n                        await sendVideo(config, remoteJid, media.url, finalText)\n                    } else {\n                        await sendImage(config, remoteJid, media.url, finalText)\n                    }\n\n                } else {\n                    // M√öLTIPLES MEDIA - Sin caption, texto al final\n                    console.log(`   - Sending multiple media, text will be sent after`)\n\n                    for (let i = 0; i < finalMediaToSend.length; i++) {\n                        const media = finalMediaToSend[i]\n\n                        if (media.type === 'video') {\n                            const { sendVideo } = await import('./utils/evolution.ts')\n                            await sendVideo(config, remoteJid, media.url, '')\n                        } else {\n                            await sendImage(config, remoteJid, media.url, '')\n                        }\n\n                        if (i < finalMediaToSend.length - 1) {\n                            await new Promise(r => setTimeout(r, 600))\n                        }\n                    }\n\n                    // Texto al final\n                    if (finalText.length > 0) {\n                        await new Promise(r => setTimeout(r, 600))\n                        await sendMessage(config, remoteJid, finalText, true)\n                    }\n                }\n            }\n\n        } else {\n            // Sin media - Enviar solo texto\n            await sendMessage(config, remoteJid, finalText, true)\n        }\n\n        // Si se requiere cotizaci√≥n PDF\n        if (placeholderResult.shouldGenerateQuote) {\n            console.log(`üìÑ [QUOTE] Generating quote PDF...`)\n            // TODO: Implementar generaci√≥n real de PDF\n        }\n\n        } // üîÑ FIN: Cierre de if (!isSimulation)\n\n        console.log(`‚úÖ [SEND] Response sent successfully${isSimulation ? ' (simulation mode - no messages sent)' : ''}`)\n\n        // ========================================================================\n        // 11. SAVE TO HISTORY\n        // ========================================================================\n        console.log(`\\nüíæ [HISTORY] Saving to chat history...`)\n\n        await saveChatHistory(\n            supabase,\n            profile.id,\n            contact.id,\n            messageText,\n            finalText, // Guardamos el texto final\n            intent\n        )\n\n        console.log(`‚úÖ [HISTORY] Saved successfully`)\n\n        // ========================================================================\n        // 12. FINAL METRICS\n        // ========================================================================\n        const totalDuration = performance.now() - startTime\n\n        console.log('\\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ')\n        console.log(`‚úÖ [SUCCESS] Message processed successfully`)\n        console.log(`‚è±Ô∏è  Total duration: ${totalDuration.toFixed(0)}ms`)\n        console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n')\n\n        return new Response(JSON.stringify({\n            success: true,\n            intent: intent.primary,\n            sentiment: intent.sentiment.polarity,\n            duration: totalDuration,\n            tokensUsed: agentResponse.metadata.tokensUsed,\n            quoteGenerated: placeholderResult.shouldGenerateQuote,\n            toolCalls: agentResponse.toolCalls,\n            userId: profile.id, // <--- Verify which user is being used\n            text: agentResponse.text, // <--- CRITICAL: Sending the AI response text\n            message: agentResponse.text, // <--- Compatibility\n            response: agentResponse.text // <--- Compatibility\n        }), {\n            headers: { ...corsHeaders, 'Content-Type': 'application/json' }\n        })\n\n    } catch (error) {\n        console.error('\\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ')\n        console.error('‚ùå [ERROR] Fatal error processing message')\n        console.error(`   Message: ${error.message}`)\n        console.error(`   Stack: ${error.stack}`)\n        console.error('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n')\n\n        return new Response(JSON.stringify({\n            error: error.message,\n            stack: error.stack\n        }), {\n            headers: { ...corsHeaders, 'Content-Type': 'application/json' },\n            status: 500\n        })\n    }\n})\n"},{"name":"intent/detector.ts","content":"/**\n * ELINA V5 - Intent Detection System\n * \n * Sistema avanzado de detecci√≥n de intenciones con an√°lisis de sentimientos\n */\n\nimport type { AccountConfig, Intent, IntentDetectionResult, SentimentAnalysis, Message } from '../config/types.ts'\nimport { INTENT_CONFIDENCE_THRESHOLD } from '../config/constants.ts'\n\n/**\n * Detecta la intenci√≥n del mensaje del usuario\n */\nexport async function detectIntent(\n    message: string,\n    config: AccountConfig,\n    conversationHistory: Message[] = []\n): Promise<IntentDetectionResult> {\n    console.log(`üéØ [INTENT] Detecting intent for message: \"${message.substring(0, 50)}...\"`)\n\n    // 1. Detecci√≥n basada en reglas (r√°pido)\n    const ruleBasedIntent = detectIntentByRules(message, config)\n\n    // 2. Si la confianza es alta, usar el resultado de reglas\n    if (ruleBasedIntent.confidence >= INTENT_CONFIDENCE_THRESHOLD) {\n        console.log(`‚úÖ [INTENT] Rule-based detection: ${ruleBasedIntent.primary} (${ruleBasedIntent.confidence})`)\n        return ruleBasedIntent\n    }\n\n    // 3. Si no, usar LLM para mayor precisi√≥n (m√°s lento)\n    console.log(`ü§ñ [INTENT] Using LLM for intent detection (low confidence: ${ruleBasedIntent.confidence})`)\n    return await detectIntentByLLM(message, config, conversationHistory)\n}\n\n/**\n * Detecci√≥n de intenci√≥n basada en reglas y patrones\n */\nfunction detectIntentByRules(\n    message: string,\n    config: AccountConfig\n): IntentDetectionResult {\n    const lowerMessage = message.toLowerCase().trim()\n    const sentiment = analyzeSentiment(message)\n\n    // Saludos\n    if (/^(hola|buenos d√≠as|buenas tardes|buenas noches|hey|qu√© tal|saludos|buen d√≠a)/i.test(message)) {\n        return {\n            primary: 'greeting' as Intent,\n            confidence: 0.95,\n            sentiment,\n            entities: {}\n        }\n    }\n\n    // Despedidas\n    if (/^(adi√≥s|hasta luego|nos vemos|chao|bye|gracias|ok gracias)/i.test(message)) {\n        return {\n            primary: 'farewell' as Intent,\n            confidence: 0.9,\n            sentiment,\n            entities: {}\n        }\n    }\n\n    // Quejas (CR√çTICO)\n    if (/\\b(queja|reclamo|molesto|enojado|mal servicio|p√©simo|horrible|terrible|decepcionado|fraude|estafa)\\b/i.test(lowerMessage)) {\n        return {\n            primary: 'complaint' as Intent,\n            confidence: 0.95,\n            sentiment: { polarity: 'negative', score: -0.8 },\n            entities: {}\n        }\n    }\n\n    // Urgencias (CR√çTICO)\n    if (/\\b(urgente|emergencia|ayuda|problema grave|necesito ya|inmediato)\\b/i.test(lowerMessage)) {\n        return {\n            primary: 'urgent_issue' as Intent,\n            confidence: 0.9,\n            sentiment: { polarity: 'negative', score: -0.6 },\n            entities: {}\n        }\n    }\n\n    // Cancelaciones\n    if (/\\b(cancelar|anular|ya no quiero|mejor no|desistir)\\b/i.test(lowerMessage)) {\n        return {\n            primary: 'cancellation' as Intent,\n            confidence: 0.85,\n            sentiment,\n            entities: {}\n        }\n    }\n\n    // Citas (solo si est√° habilitado)\n    if (config.hasAppointments || config.appointmentsEnabled) {\n        if (/\\b(cita|agendar|reservar|turno|hora|consulta|appointment)\\b/i.test(lowerMessage)) {\n            return {\n                primary: 'appointment_request' as Intent,\n                confidence: 0.9,\n                sentiment,\n                entities: extractEntities(message)\n            }\n        }\n    }\n\n    // Cotizaciones\n    if (config.quotesEnabled || config.hasQuotes) {\n        if (/\\b(cotizaci√≥n|presupuesto|precio total|cu√°nto ser√≠a todo|quote)\\b/i.test(lowerMessage)) {\n            return {\n                primary: 'quote_request' as Intent,\n                confidence: 0.85,\n                sentiment,\n                entities: extractEntities(message)\n            }\n        }\n    }\n\n    // Productos\n    if (config.hasProducts) {\n        if (/\\b(producto|art√≠culo|precio|costo|cu√°nto|disponible|stock|inventario|comprar|vend(es|en)|tien(es|en)|ofrec(es|en)|manej(as|an)|cat√°logo|qu√© si vend)\\b/i.test(lowerMessage)) {\n            return {\n                primary: 'product_inquiry' as Intent,\n                confidence: 0.8,\n                sentiment,\n                entities: extractEntities(message)\n            }\n        }\n    }\n\n    // Servicios\n    if (config.hasServices) {\n        if (/\\b(servicio|ofreces|haces|realizas|cu√°nto cobras)\\b/i.test(lowerMessage)) {\n            return {\n                primary: 'service_inquiry' as Intent,\n                confidence: 0.8,\n                sentiment,\n                entities: extractEntities(message)\n            }\n        }\n    }\n\n    // Confirmaciones\n    if (/^(s√≠|si|yes|ok|est√° bien|perfecto|de acuerdo|confirmo|acepto)\\b/i.test(message)) {\n        return {\n            primary: 'confirmation' as Intent,\n            confidence: 0.85,\n            sentiment: { polarity: 'positive', score: 0.6 },\n            entities: {}\n        }\n    }\n\n    // Default: pregunta general\n    return {\n        primary: 'general_question' as Intent,\n        confidence: 0.5,\n        sentiment,\n        entities: extractEntities(message)\n    }\n}\n\n/**\n * Detecci√≥n de intenci√≥n usando LLM (m√°s preciso pero m√°s lento)\n */\nasync function detectIntentByLLM(\n    message: string,\n    config: AccountConfig,\n    conversationHistory: Message[]\n): Promise<IntentDetectionResult> {\n    const openrouterKey = Deno.env.get('OPENROUTER_API_KEY')\n    if (!openrouterKey) {\n        console.warn(`‚ö†Ô∏è [INTENT] OPENROUTER_API_KEY not found, falling back to rule-based`)\n        return detectIntentByRules(message, config)\n    }\n\n    const prompt = `Analiza el siguiente mensaje y determina la intenci√≥n principal del usuario.\n\nMensaje: \"${message}\"\n\nContexto de negocio:\n- Tipo: ${config.businessType}\n- Tiene productos: ${config.hasProducts}\n- Tiene servicios: ${config.hasServices}\n- Tiene citas: ${config.appointmentsEnabled}\n- Tiene cotizaciones: ${config.quotesEnabled}\n\nResponde SOLO con un JSON en este formato:\n{\n  \"intent\": \"greeting|farewell|product_inquiry|service_inquiry|appointment_request|quote_request|complaint|urgent_issue|cancellation|confirmation|general_question|unknown\",\n  \"confidence\": 0.0-1.0,\n  \"sentiment\": \"positive|neutral|negative\",\n  \"entities\": {\n    \"products\": [\"producto1\", \"producto2\"],\n    \"dates\": [\"2026-02-10\"],\n    \"prices\": [100, 200]\n  }\n}`\n\n    try {\n        const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {\n            method: 'POST',\n            headers: {\n                'Authorization': `Bearer ${openrouterKey}`,\n                'HTTP-Referer': 'https://elina.ai',\n                'X-Title': 'ELINA V5 Intent Detection',\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                model: 'openai/gpt-4o-mini', // M√°s barato para detecci√≥n de intenci√≥n\n                messages: [{ role: 'user', content: prompt }],\n                temperature: 0.3,\n                max_tokens: 200\n            })\n        })\n\n        if (!response.ok) {\n            throw new Error(`OpenRouter API error: ${response.statusText}`)\n        }\n\n        const data = await response.json()\n        const content = data.choices[0].message.content\n\n        // Extraer JSON de la respuesta\n        const jsonMatch = content.match(/\\{[\\s\\S]*\\}/)\n        if (!jsonMatch) {\n            throw new Error('No JSON found in LLM response')\n        }\n\n        const result = JSON.parse(jsonMatch[0])\n\n        return {\n            primary: result.intent as Intent,\n            confidence: result.confidence || 0.7,\n            sentiment: {\n                polarity: result.sentiment || 'neutral',\n                score: result.sentiment === 'positive' ? 0.6 : result.sentiment === 'negative' ? -0.6 : 0\n            },\n            entities: result.entities || {}\n        }\n    } catch (error) {\n        console.error(`‚ùå [INTENT] LLM detection failed: ${error.message}`)\n        return detectIntentByRules(message, config)\n    }\n}\n\n/**\n * Analiza el sentimiento del mensaje\n */\nexport function analyzeSentiment(message: string): SentimentAnalysis {\n    const lowerMessage = message.toLowerCase()\n\n    // Palabras positivas\n    const positiveWords = ['excelente', 'genial', 'perfecto', 'gracias', 'bueno', 'bien', 'feliz', 'contento', 'encantado', 'maravilloso']\n    const positiveCount = positiveWords.filter(word => lowerMessage.includes(word)).length\n\n    // Palabras negativas\n    const negativeWords = ['mal', 'p√©simo', 'horrible', 'terrible', 'molesto', 'enojado', 'decepcionado', 'problema', 'queja', 'reclamo']\n    const negativeCount = negativeWords.filter(word => lowerMessage.includes(word)).length\n\n    // Calcular polaridad\n    if (positiveCount > negativeCount) {\n        return {\n            polarity: 'positive',\n            score: Math.min(0.8, 0.3 + (positiveCount * 0.2))\n        }\n    } else if (negativeCount > positiveCount) {\n        return {\n            polarity: 'negative',\n            score: Math.max(-0.8, -0.3 - (negativeCount * 0.2))\n        }\n    }\n\n    return {\n        polarity: 'neutral',\n        score: 0\n    }\n}\n\n/**\n * Extrae entidades del mensaje (productos, fechas, precios, etc.)\n */\nfunction extractEntities(message: string): {\n    products?: string[]\n    services?: string[]\n    dates?: string[]\n    prices?: number[]\n    phoneNumbers?: string[]\n} {\n    const entities: any = {}\n\n    // Extraer precios (ej: $100, 100 pesos, $1,000.00)\n    const priceRegex = /\\$?\\d{1,3}(?:,\\d{3})*(?:\\.\\d{2})?(?:\\s*(?:pesos|mxn|usd|d√≥lares))?/gi\n    const prices = message.match(priceRegex)\n    if (prices) {\n        entities.prices = prices.map(p => parseFloat(p.replace(/[$,]/g, '')))\n    }\n\n    // Extraer fechas (ej: 10/02/2026, 10 de febrero, ma√±ana)\n    const dateKeywords = ['ma√±ana', 'hoy', 'pasado ma√±ana', 'lunes', 'martes', 'mi√©rcoles', 'jueves', 'viernes', 's√°bado', 'domingo']\n    const foundDates = dateKeywords.filter(keyword => message.toLowerCase().includes(keyword))\n    if (foundDates.length > 0) {\n        entities.dates = foundDates\n    }\n\n    // Extraer n√∫meros de tel√©fono (ej: 5512345678, +52 55 1234 5678)\n    const phoneRegex = /(?:\\+?52\\s?)?(?:\\d{2,3}\\s?)?\\d{4}\\s?\\d{4}/g\n    const phones = message.match(phoneRegex)\n    if (phones) {\n        entities.phoneNumbers = phones\n    }\n\n    return entities\n}\n\n/**\n * Verifica si la intenci√≥n es cr√≠tica y requiere atenci√≥n humana\n */\nexport function isCriticalIntent(intent: Intent): boolean {\n    const criticalIntents: Intent[] = [\n        'complaint' as Intent,\n        'urgent_issue' as Intent,\n        'cancellation' as Intent,\n        'refund_request' as Intent\n    ]\n\n    return criticalIntents.includes(intent)\n}\n"},{"name":"memory/long-term.ts","content":"/**\n * ELINA V5 - Long-term Memory System\n * \n * Sistema de aprendizaje de largo plazo por cuenta\n */\n\nimport type { SupabaseClient } from 'https://esm.sh/@supabase/supabase-js@2'\nimport type { AccountLearning } from '../config/types.ts'\nimport { LEARNING_CONFIDENCE_THRESHOLD, RAG_MAX_RESULTS } from '../config/constants.ts'\n\n/**\n * Genera embedding para un texto usando OpenAI\n */\nasync function generateEmbedding(text: string): Promise<number[]> {\n    const openaiKey = Deno.env.get('OPENAI_API_KEY')\n    if (!openaiKey) {\n        throw new Error('OPENAI_API_KEY not found')\n    }\n\n    const response = await fetch('https://api.openai.com/v1/embeddings', {\n        method: 'POST',\n        headers: {\n            'Authorization': `Bearer ${openaiKey}`,\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n            model: 'text-embedding-3-small',\n            input: text\n        })\n    })\n\n    if (!response.ok) {\n        throw new Error(`OpenAI API error: ${response.statusText}`)\n    }\n\n    const data = await response.json()\n    return data.data[0].embedding\n}\n\n/**\n * Obtiene aprendizajes relevantes basados en el mensaje actual\n */\nexport async function getRelevantLearnings(\n    supabase: SupabaseClient,\n    userId: string,\n    currentMessage: string,\n    limit: number = RAG_MAX_RESULTS\n): Promise<AccountLearning[]> {\n    console.log(`üß† [MEMORY] Fetching relevant learnings for user ${userId}`)\n\n    try {\n        // 1. Generar embedding del mensaje actual\n        const embedding = await generateEmbedding(currentMessage)\n\n        // 2. Buscar aprendizajes similares\n        const { data, error } = await supabase.rpc('match_account_learnings', {\n            query_embedding: embedding,\n            match_threshold: LEARNING_CONFIDENCE_THRESHOLD,\n            match_count: limit,\n            filter_user_id: userId\n        })\n\n        if (error) {\n            console.error(`‚ùå [MEMORY] Error fetching learnings: ${error.message}`)\n            return []\n        }\n\n        const learnings = (data || []) as AccountLearning[]\n        console.log(`‚úÖ [MEMORY] Found ${learnings.length} relevant learnings`)\n\n        // 3. Actualizar usage_count y last_used\n        if (learnings.length > 0) {\n            await Promise.all(\n                learnings.map(learning =>\n                    supabase\n                        .from('account_learnings')\n                        .update({\n                            usage_count: (learning.usageCount || 0) + 1,\n                            last_used: new Date().toISOString()\n                        })\n                        .eq('id', learning.id)\n                )\n            )\n        }\n\n        return learnings\n    } catch (error) {\n        console.error(`‚ùå [MEMORY] Error in getRelevantLearnings: ${error.message}`)\n        return []\n    }\n}\n\n/**\n * Guarda un nuevo aprendizaje\n */\nexport async function saveLearning(\n    supabase: SupabaseClient,\n    userId: string,\n    learningType: 'pattern' | 'objection' | 'product_insight' | 'best_practice',\n    content: string,\n    confidence: number = 0.5\n): Promise<void> {\n    console.log(`üíæ [MEMORY] Saving new learning: ${learningType}`)\n\n    try {\n        // 1. Generar embedding\n        const embedding = await generateEmbedding(content)\n\n        // 2. Guardar en base de datos\n        const { error } = await supabase.from('account_learnings').insert({\n            user_id: userId,\n            learning_type: learningType,\n            content,\n            confidence,\n            embedding,\n            usage_count: 0,\n            created_at: new Date().toISOString(),\n            updated_at: new Date().toISOString()\n        })\n\n        if (error) {\n            console.error(`‚ùå [MEMORY] Error saving learning: ${error.message}`)\n            throw error\n        }\n\n        console.log(`‚úÖ [MEMORY] Learning saved successfully`)\n    } catch (error) {\n        console.error(`‚ùå [MEMORY] Error in saveLearning: ${error.message}`)\n        throw error\n    }\n}\n\n/**\n * Actualiza la confianza de un aprendizaje\n */\nexport async function updateLearningConfidence(\n    supabase: SupabaseClient,\n    learningId: string,\n    newConfidence: number\n): Promise<void> {\n    const { error } = await supabase\n        .from('account_learnings')\n        .update({\n            confidence: Math.max(0, Math.min(1, newConfidence)), // Clamp between 0 and 1\n            updated_at: new Date().toISOString()\n        })\n        .eq('id', learningId)\n\n    if (error) {\n        console.error(`‚ùå [MEMORY] Error updating learning confidence: ${error.message}`)\n        throw error\n    }\n}\n\n/**\n * Elimina aprendizajes con baja confianza y poco uso\n */\nexport async function cleanupOldLearnings(\n    supabase: SupabaseClient,\n    userId: string,\n    minConfidence: number = 0.3,\n    minUsageCount: number = 1,\n    daysOld: number = 90\n): Promise<number> {\n    console.log(`üßπ [MEMORY] Cleaning up old learnings for user ${userId}`)\n\n    const cutoffDate = new Date()\n    cutoffDate.setDate(cutoffDate.getDate() - daysOld)\n\n    const { data, error } = await supabase\n        .from('account_learnings')\n        .delete()\n        .eq('user_id', userId)\n        .lt('confidence', minConfidence)\n        .lt('usage_count', minUsageCount)\n        .lt('created_at', cutoffDate.toISOString())\n        .select('id')\n\n    if (error) {\n        console.error(`‚ùå [MEMORY] Error cleaning up learnings: ${error.message}`)\n        return 0\n    }\n\n    const deletedCount = data?.length || 0\n    console.log(`‚úÖ [MEMORY] Cleaned up ${deletedCount} old learnings`)\n\n    return deletedCount\n}\n\n/**\n * Formatea aprendizajes para incluir en el prompt\n */\nexport function formatLearningsForPrompt(learnings: AccountLearning[]): string {\n    if (learnings.length === 0) {\n        return ''\n    }\n\n    let formatted = '## Aprendizajes Previos\\n'\n    formatted += 'Estos son patrones y mejores pr√°cticas que has aprendido con el tiempo:\\n\\n'\n\n    for (const learning of learnings) {\n        const emoji = {\n            pattern: 'üîÑ',\n            objection: 'üõ°Ô∏è',\n            product_insight: 'üí°',\n            best_practice: '‚≠ê'\n        }[learning.learningType] || 'üìù'\n\n        formatted += `${emoji} **${learning.learningType}**: ${learning.content}\\n`\n    }\n\n    return formatted\n}\n"},{"name":"utils/appointment-manager.ts","content":"// Appointment Management System for ELINA V5\n// Handles appointment scheduling, slot management, and reminders\n\nimport { SupabaseClient } from 'https://esm.sh/@supabase/supabase-js@2'\n\nexport interface AppointmentSettings {\n    is_enabled: boolean\n    buffer_minutes: number\n    max_days_ahead: number\n    working_hours?: any\n}\n\nexport interface AppointmentSlot {\n    start_time: string\n    end_time: string\n    service_id: number\n    service_name: string\n    duration_minutes: number\n}\n\nexport interface CreateAppointmentParams {\n    userId: string\n    contactId: number\n    serviceId: number\n    startTime: string\n    notes?: string\n}\n\nexport interface AppointmentResult {\n    success: boolean\n    appointmentId?: number\n    serviceName?: string\n    startTime?: string\n    error?: string\n}\n\n/**\n * Gets appointment settings for a user\n */\nexport async function getAppointmentSettings(\n    supabase: SupabaseClient,\n    userId: string\n): Promise<AppointmentSettings | null> {\n    try {\n        const { data, error } = await supabase\n            .from('appointment_settings')\n            .select('*')\n            .eq('user_id', userId)\n            .single()\n\n        if (error) {\n            console.error(`‚ùå [APPOINTMENT] Error fetching settings:`, error)\n            return null\n        }\n\n        return data as AppointmentSettings\n    } catch (error) {\n        console.error(`‚ùå [APPOINTMENT] Error:`, error)\n        return null\n    }\n}\n\n/**\n * Gets available appointment slots\n */\nexport async function getAvailableSlots(\n    userId: string,\n    daysAhead: number = 7\n): Promise<AppointmentSlot[]> {\n    try {\n        console.log(`üìÖ [APPOINTMENT] Fetching slots for next ${daysAhead} days...`)\n        const allSlots: AppointmentSlot[] = []\n        const slotsUrl = `${Deno.env.get('SUPABASE_URL')}/functions/v1/get-available-slots`\n        const anonKey = Deno.env.get('SUPABASE_ANON_KEY')\n\n        // Generate dates for the next N days\n        const dates: string[] = []\n        const today = new Date()\n\n        for (let i = 0; i < daysAhead; i++) {\n            const date = new Date(today)\n            date.setDate(today.getDate() + i)\n            dates.push(date.toISOString().split('T')[0])\n        }\n\n        // Fetch slots for each date in parallel (limited for performance)\n        const fetchPromises = dates.map(async (date) => {\n            try {\n                const response = await fetch(slotsUrl, {\n                    method: 'POST',\n                    headers: {\n                        'Authorization': `Bearer ${anonKey}`,\n                        'Content-Type': 'application/json'\n                    },\n                    body: JSON.stringify({\n                        user_id: userId,\n                        date: date\n                    })\n                })\n\n                if (!response.ok) {\n                    console.warn(`‚ö†Ô∏è [APPOINTMENT] Failed to fetch slots for ${date}: ${response.status}`)\n                    return []\n                }\n\n                const data = await response.json()\n\n                if (data.available_slots && Array.isArray(data.available_slots)) {\n                    // Map response format to AppointmentSlot format\n                    return data.available_slots.map((s: any) => ({\n                        start_time: `${date}T${s.start}:00`, // Ensure valid ISO format if strictly time\n                        end_time: `${date}T${s.end}:00`,\n                        service_id: 0, // Default or generic\n                        service_name: 'Cita General', // Default\n                        duration_minutes: s.duration_minutes || 60\n                    }))\n                }\n\n                return []\n            } catch (err) {\n                console.error(`‚ùå [APPOINTMENT] Error fetching date ${date}:`, err)\n                return []\n            }\n        })\n\n        const results = await Promise.all(fetchPromises)\n\n        // Flatten results\n        results.forEach(slots => {\n            allSlots.push(...slots)\n        })\n\n        return allSlots\n\n    } catch (error) {\n        console.error(`‚ùå [APPOINTMENT] Error fetching slots:`, error)\n        return []\n    }\n}\n\n/**\n * Formats appointment slots for AI context\n */\n/**\n * Formats appointment slots for AI context\n */\nexport function formatAppointmentContext(slots: AppointmentSlot[], slug?: string): string {\n    if (!slots || slots.length === 0) {\n        let noSlotsMsg = '[CITAS] No hay horarios disponibles en los pr√≥ximos d√≠as.'\n        if (slug) {\n            noSlotsMsg += `\\nPuedes revisar disponibilidad completa aqu√≠: [APPOINTMENT_CALENDAR_LINK]`\n        }\n        return noSlotsMsg\n    }\n\n    let context = 'üìÖ [HORARIOS DISPONIBLES PARA CITAS]\\n\\n'\n\n    // Agrupar por d√≠a\n    const slotsByDay: Record<string, AppointmentSlot[]> = {}\n\n    for (const slot of slots) {\n        const date = new Date(slot.start_time)\n        const dayKey = date.toLocaleDateString('es-MX', {\n            weekday: 'long',\n            day: 'numeric',\n            month: 'long'\n        })\n\n        // Capitalizar primer letra\n        const formattedDayKey = dayKey.charAt(0).toUpperCase() + dayKey.slice(1)\n\n        if (!slotsByDay[formattedDayKey]) {\n            slotsByDay[formattedDayKey] = []\n        }\n        slotsByDay[formattedDayKey].push(slot)\n    }\n\n    // Formatear por d√≠a con rangos\n    const dayEntries = Object.entries(slotsByDay)\n    // Limitar a los primeros 3 d√≠as para no saturar contexto\n    const daysToShow = dayEntries.slice(0, 3)\n\n    for (const [day, daySlots] of daysToShow) {\n        context += `üìÜ ${day}:\\n`\n\n        // Ordenar slots por hora\n        daySlots.sort((a, b) => new Date(a.start_time).getTime() - new Date(b.start_time).getTime())\n\n        if (daySlots.length === 0) continue\n\n        // Encontrar primer y √∫ltimo slot del d√≠a\n        const firstSlot = daySlots[0]\n        const lastSlot = daySlots[daySlots.length - 1]\n\n        const startTime = new Date(firstSlot.start_time).toLocaleTimeString('es-MX', {\n            hour: '2-digit', minute: '2-digit', hour12: true\n        })\n\n        const endTime = new Date(lastSlot.start_time).toLocaleTimeString('es-MX', {\n            hour: '2-digit', minute: '2-digit', hour12: true\n        })\n\n        if (daySlots.length === 1) {\n            context += `   ‚Ä¢ A las ${startTime}\\n`\n        } else {\n            context += `   ‚Ä¢ Entre las ${startTime} y las ${endTime}\\n`\n        }\n\n        context += '\\n'\n    }\n\n    if (slug) {\n        context += `üîó Puedes ver el calendario completo y agendar aqu√≠:\\n[APPOINTMENT_CALENDAR_LINK]\\n\\n`\n    }\n\n    context += 'üìå INSTRUCCI√ìN IMPORTANTE:\\n'\n    context += 'Ofrece los horarios como RANGOS (ej: \"tengo espacio entre las 10 y las 12\").\\n'\n    context += 'Si el usuario pide una hora espec√≠fica dentro del rango, verifica si est√° disponible o agenda al horario m√°s cercano.\\n'\n    context += 'SIEMPRE incluye el enlace al calendario completo al final.\\n'\n\n    return context\n}\n\n/**\n * Creates an appointment and automatic reminders\n */\nexport async function createAppointment(\n    supabase: SupabaseClient,\n    params: CreateAppointmentParams,\n    sendMessage: (remoteJid: string, text: string) => Promise<void>,\n    contactPhone: string\n): Promise<AppointmentResult> {\n    try {\n        console.log(`\\nüìÖ [APPOINTMENT] Creating appointment...`)\n        console.log(`   User: ${params.userId}`)\n        console.log(`   Contact: ${params.contactId}`)\n        console.log(`   Service: ${params.serviceId}`)\n        console.log(`   Time: ${params.startTime}`)\n\n        // ========================================================================\n        // 1. GET SERVICE INFO (duration + name)\n        // ========================================================================\n        const { data: serviceData } = await supabase\n            .from('products')\n            .select('service_duration_minutes, product_name')\n            .eq('id', params.serviceId)\n            .single()\n\n        const durationMinutes = serviceData?.service_duration_minutes || 60 // Default 60 min\n        const serviceName = serviceData?.product_name || 'Servicio'\n\n        // Calculate end_time\n        const startTime = new Date(params.startTime)\n        const endTime = new Date(startTime.getTime() + durationMinutes * 60 * 1000)\n\n        console.log(`‚è±Ô∏è [APPOINTMENT] Service: ${serviceName}`)\n        console.log(`   Duration: ${durationMinutes} minutes`)\n        console.log(`   Start: ${params.startTime}`)\n        console.log(`   End: ${endTime.toISOString()}`)\n\n        // ========================================================================\n        // 2. CREATE APPOINTMENT (with AI metadata)\n        // ========================================================================\n        const { data: appointment, error: createError } = await supabase\n            .from('meetings')\n            .insert({\n                user_id: params.userId,\n                contact_id: params.contactId,\n                product_id: params.serviceId,\n                start_time: params.startTime,\n                end_time: endTime.toISOString(),\n                status: 'confirmed',\n                summary: 'Cita Agendada por IA',  // AI marker\n                notes: params.notes ? `${params.notes} (Agendado autom√°ticamente: ${serviceName})` : `Agendado autom√°ticamente: ${serviceName}`,\n                confirmation_status: 'confirmed'\n            })\n            .select()\n            .single()\n\n        if (createError) {\n            console.error(`‚ùå [APPOINTMENT] Creation failed:`, createError)\n            throw createError\n        }\n\n        console.log(`‚úÖ [APPOINTMENT] Created appointment #${appointment.id}`)\n\n        // ========================================================================\n        // 2. CREATE AUTOMATIC REMINDERS\n        // ========================================================================\n        const appointmentTime = new Date(params.startTime)\n        const now = new Date()\n\n        // Recordatorio 24h antes (solo si la cita es en m√°s de 24h)\n        const twentyFourHoursBefore = new Date(appointmentTime.getTime() - 24 * 60 * 60 * 1000)\n        if (twentyFourHoursBefore > now) {\n            await supabase.from('appointment_reminders').insert({\n                meeting_id: appointment.id,\n                reminder_time: twentyFourHoursBefore.toISOString(),\n                reminder_type: '24h_before',\n                status: 'pending'\n            })\n            console.log(`‚úÖ [APPOINTMENT] 24h reminder scheduled`)\n        }\n\n        // Recordatorio 2h antes (solo si la cita es en m√°s de 2h)\n        const twoHoursBefore = new Date(appointmentTime.getTime() - 2 * 60 * 60 * 1000)\n        if (twoHoursBefore > now) {\n            await supabase.from('appointment_reminders').insert({\n                meeting_id: appointment.id,\n                reminder_time: twoHoursBefore.toISOString(),\n                reminder_type: '2h_before',\n                status: 'pending'\n            })\n            console.log(`‚úÖ [APPOINTMENT] 2h reminder scheduled`)\n        }\n\n        // ========================================================================\n        // 3. SEND CONFIRMATION TO CUSTOMER\n        // ========================================================================\n        const confirmationMsg =\n            `‚úÖ *Cita Confirmada*\\n\\n` +\n            `üìÖ Fecha: ${appointmentTime.toLocaleDateString('es-MX', { weekday: 'long', day: 'numeric', month: 'long', year: 'numeric' })}\\n` +\n            `üïê Hora: ${appointmentTime.toLocaleTimeString('es-MX', { hour: '2-digit', minute: '2-digit', hour12: true })}\\n` +\n            `üîπ Servicio: ${serviceName}\\n` +\n            `‚è±Ô∏è Duraci√≥n: ${durationMinutes} minutos\\n\\n` +\n            `Recibir√°s recordatorios antes de tu cita.\\n` +\n            `ID de cita: #${appointment.id}`\n\n        await sendMessage(contactPhone + '@s.whatsapp.net', confirmationMsg)\n        console.log(`‚úÖ [APPOINTMENT] Confirmation sent to customer`)\n\n        // ========================================================================\n        // 4. NOTIFY OWNER (OPTIONAL)\n        // ========================================================================\n        const { data: profile } = await supabase\n            .from('profiles')\n            .select('contact_phone')\n            .eq('id', params.userId)\n            .single()\n\n        if (profile?.contact_phone) {\n            const { data: contact } = await supabase\n                .from('contacts')\n                .select('full_name, phone_number')\n                .eq('id', params.contactId)\n                .single()\n\n            const ownerNotification =\n                `üìÖ *Nueva Cita Agendada*\\n\\n` +\n                `Cliente: ${contact?.full_name || contact?.phone_number}\\n` +\n                `Servicio: ${serviceName}\\n` +\n                `Fecha: ${appointmentTime.toLocaleDateString('es-MX', { day: 'numeric', month: 'long' })}\\n` +\n                `Hora: ${appointmentTime.toLocaleTimeString('es-MX', { hour: '2-digit', minute: '2-digit' })}\\n` +\n                `ID: #${appointment.id}`\n\n            await sendMessage(profile.contact_phone + '@s.whatsapp.net', ownerNotification)\n            console.log(`‚úÖ [APPOINTMENT] Owner notified`)\n        }\n\n        return {\n            success: true,\n            appointmentId: appointment.id,\n            serviceName: serviceName,  // Use the serviceName we fetched earlier\n            startTime: params.startTime\n        }\n\n    } catch (error) {\n        console.error(`‚ùå [APPOINTMENT] Error creating appointment:`, error)\n        return {\n            success: false,\n            error: error instanceof Error ? error.message : 'Unknown error'\n        }\n    }\n}\n\n/**\n * Detects if the message contains an appointment request\n */\nexport function detectAppointmentIntent(text: string, context?: any): boolean {\n    const lowerText = text.toLowerCase().trim()\n\n    // 1. Palabras clave expl√≠citas de cita\n    const appointmentKeywords = /(?:cita|agendar|reservar|horario|turno|disponibilidad|agenda|appointment|schedule|book)/i\n    if (appointmentKeywords.test(lowerText)) return true\n\n    // 2. Si ya estamos hablando de citas (contexto activo), palabras de confirmaci√≥n o fechas cuentan como intent\n    if (context?.appointmentContext || context?.lastIntent === 'appointment_request') {\n        const confirmationKeywords = /^(si|ok|va|dale|acepto|confirmo|claro|por favor|hazlo|que si|seguro)$/i\n        const timeKeywords = /(ma√±ana|hoy|lunes|martes|miercoles|jueves|viernes|sabado|domingo|enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|alas|a las)/i\n\n        if (confirmationKeywords.test(lowerText) || timeKeywords.test(lowerText)) {\n            return true\n        }\n\n        // Si menciona un servicio y estamos en contexto de cita\n        if (text.length < 50 && (lowerText.includes('corte') || lowerText.includes('color') || lowerText.includes('peinado'))) {\n            return true\n        }\n    }\n\n    return false\n}\n"},{"name":"utils/automation.ts","content":"\nimport { AccountConfig, AutoResponse } from '../config/types.ts'\n\n/**\n * Verifica si el mensaje coincide con alguna regla de autorespuesta\n */\nexport function checkAutoResponses(messageText: string, config: AccountConfig): AutoResponse | null {\n    if (!config.autoResponses || config.autoResponses.length === 0) return null\n\n    const lowerMessage = messageText.toLowerCase()\n\n    // Sort by specific criteria if needed (e.g. exact match first)\n    // For now, iterate in order\n    for (const rule of config.autoResponses) {\n        if (!rule.isActive) continue\n\n        const trigger = (rule.triggerText || '').toLowerCase()\n        const matchType = rule.matchType || 'contains'\n\n        let isMatch = false\n\n        if (matchType === 'exact') {\n            isMatch = lowerMessage === trigger\n        } else {\n            // contains\n            isMatch = lowerMessage.includes(trigger)\n        }\n\n        if (isMatch) {\n            console.log(`‚úÖ [AUTOMATION] Auto-response triggered: ${rule.id} (${trigger})`)\n            return rule\n        }\n    }\n\n    return null\n}\n"},{"name":"utils/context-filter.ts","content":"/**\r\n * ELINA V5 - Context Filter\r\n *\r\n * Filtra SOLO cotizaciones formales antiguas (subtotales/totales estructurados).\r\n * NO borra mensajes que simplemente mencionan precios ‚Äî eso es contexto valioso.\r\n */\r\n\r\nimport type { Message } from '../config/types.ts'\r\n\r\n/**\r\n * Detecta si el mensaje actual es una solicitud de cotizaci√≥n formal nueva\r\n * que deber√≠a invalidar cotizaciones anteriores (no todo el contexto).\r\n */\r\nexport function isNewTransactionalRequest(message: string, history: Message[]): boolean {\r\n    const text = message.toLowerCase()\r\n\r\n    // Solo activar filtro para solicitudes EXPL√çCITAS de cotizaci√≥n/presupuesto\r\n    const quoteKeywords = [\r\n        'cotizaci√≥n', 'cotizacion', 'presupuesto',\r\n        'cu√°nto ser√≠a todo', 'cuanto seria todo',\r\n        'precio total', 'total de todo'\r\n    ]\r\n\r\n    const hasQuoteKeyword = quoteKeywords.some(kw => text.includes(kw))\r\n\r\n    // Si no hay historial, no hay nada que filtrar\r\n    if (history.length === 0) return false\r\n\r\n    // Solo filtrar si es una solicitud expl√≠cita de cotizaci√≥n nueva\r\n    return hasQuoteKeyword\r\n}\r\n\r\n/**\r\n * Filtra SOLO cotizaciones formales antiguas (con formato subtotal/total estructurado).\r\n * Mensajes conversacionales que mencionan precios se MANTIENEN.\r\n */\r\nexport function filterTransactionalContext(history: Message[], isNewRequest: boolean): Message[] {\r\n    if (!isNewRequest) return history\r\n\r\n    return history.filter(msg => {\r\n        const text = msg.content.toLowerCase()\r\n\r\n        // Solo filtrar mensajes que son cotizaciones formales (tienen subtotal Y total)\r\n        const isFormalQuote = text.includes('subtotal:') && text.includes('total:')\r\n        const isFormalAppointmentConfirmation = text.includes('cita confirmada') && text.includes('id de cita')\r\n\r\n        // Mantener todo excepto cotizaciones formales antiguas\r\n        return !isFormalQuote && !isFormalAppointmentConfirmation\r\n    })\r\n}\r\n"},{"name":"utils/context.ts","content":"/**\r\n * ELINA V5 - Context Loader\r\n * \r\n * Carga todo el contexto necesario para la conversaci√≥n\r\n */\r\n\r\nimport type { SupabaseClient } from 'https://esm.sh/@supabase/supabase-js@2'\r\nimport type { AccountConfig, ConversationContext, Message, Contact, Product } from '../config/types.ts'\r\nimport { getRelevantLearnings } from '../memory/long-term.ts'\r\n\r\n/**\r\n * Obtiene el perfil por nombre de instancia\r\n */\r\nexport async function getProfileByInstance(\r\n    supabase: SupabaseClient,\r\n    instanceName: string\r\n) {\r\n    const { data, error } = await supabase\r\n        .from('profiles')\r\n        .select('*')\r\n        .eq('evolution_instance_name', instanceName)\r\n        .single()\r\n\r\n    if (error || !data) {\r\n        throw new Error(`Profile not found for instance: ${instanceName}`)\r\n    }\r\n\r\n    return data\r\n}\r\n\r\n/**\r\n * Asegura que el contacto existe en la base de datos\r\n */\r\nexport async function ensureContact(\r\n    supabase: SupabaseClient,\r\n    userId: string,\r\n    phoneNumber: string,\r\n    fullName?: string\r\n): Promise<Contact> {\r\n    // Buscar contacto existente\r\n    const { data: existing, error: searchError } = await supabase\r\n        .from('contacts')\r\n        .select('*')\r\n        .eq('user_id', userId)\r\n        .eq('phone_number', phoneNumber)\r\n        .maybeSingle()\r\n\r\n    if (existing) {\r\n        return existing as Contact\r\n    }\r\n\r\n    // Crear nuevo contacto\r\n    const { data: newContact, error: insertError } = await supabase\r\n        .from('contacts')\r\n        .insert({\r\n            user_id: userId,\r\n            phone_number: phoneNumber,\r\n            full_name: fullName || phoneNumber,\r\n            labels: [],\r\n            created_at: new Date().toISOString()\r\n        })\r\n        .select()\r\n        .single()\r\n\r\n    if (insertError || !newContact) {\r\n        throw new Error(`Failed to create contact: ${insertError?.message}`)\r\n    }\r\n\r\n    return newContact as Contact\r\n}\r\n\r\n/**\r\n * Obtiene el historial de chat reciente\r\n *\r\n * Ventana de 4 horas para mantener continuidad en conversaciones largas.\r\n * El filtro transaccional en context-filter.ts se encarga de limpiar\r\n * datos de precios obsoletos cuando hay una nueva solicitud.\r\n */\r\nexport async function getChatHistory(\r\n    supabase: SupabaseClient,\r\n    userId: string,\r\n    contactId: number,\r\n    limit: number = 20\r\n): Promise<Message[]> {\r\n    // Ventana de 4 horas ‚Äî suficiente para mantener contexto de conversaci√≥n\r\n    const fourHoursAgo = new Date(Date.now() - 4 * 60 * 60 * 1000).toISOString();\r\n\r\n    const { data, error } = await supabase\r\n        .from('chat_history')\r\n        .select('message_type, content, created_at')\r\n        .eq('user_id', userId)\r\n        .eq('contact_id', contactId)\r\n        .gte('created_at', fourHoursAgo)\r\n        .order('created_at', { ascending: false })\r\n        .limit(limit)\r\n\r\n    if (error) {\r\n        console.error(`‚ùå [CONTEXT] Error fetching chat history: ${error.message}`)\r\n        return []\r\n    }\r\n\r\n    const messageCount = data?.length || 0;\r\n    console.log(`üìö [CONTEXT] Loaded ${messageCount} messages from last 4 hours`);\r\n\r\n    // Convertir a formato Message y revertir orden (m√°s antiguo primero)\r\n    return (data || [])\r\n        .reverse()\r\n        .map(msg => ({\r\n            role: msg.message_type === 'user' ? 'user' : 'assistant',\r\n            content: msg.content,\r\n            timestamp: new Date(msg.created_at)\r\n        })) as Message[]\r\n}\r\n\r\n/**\r\n * Guarda un mensaje en el historial\r\n */\r\nexport async function saveChatHistory(\r\n    supabase: SupabaseClient,\r\n    userId: string,\r\n    contactId: number,\r\n    userMessage: string,\r\n    assistantMessage: string,\r\n    intent: any\r\n): Promise<void> {\r\n    // Guardar mensaje del usuario\r\n    await supabase.from('chat_history').insert({\r\n        user_id: userId,\r\n        contact_id: contactId,\r\n        message_type: 'user',\r\n        content: userMessage,\r\n        created_at: new Date().toISOString()\r\n    })\r\n\r\n    // Guardar respuesta del asistente\r\n    await supabase.from('chat_history').insert({\r\n        user_id: userId,\r\n        contact_id: contactId,\r\n        message_type: 'assistant',\r\n        content: assistantMessage,\r\n        metadata: {\r\n            intent: intent.primary,\r\n            sentiment: intent.sentiment.polarity\r\n        },\r\n        created_at: new Date().toISOString()\r\n    })\r\n}\r\n\r\n/**\r\n * Carga el contexto completo de la conversaci√≥n\r\n * \r\n * IMPORTANTE: Filtra datos transaccionales antiguos si detecta nueva solicitud\r\n */\r\nexport async function loadConversationContext(\r\n    supabase: SupabaseClient,\r\n    config: AccountConfig,\r\n    contact: Contact,\r\n    currentMessage: string,\r\n    intent: any\r\n): Promise<ConversationContext> {\r\n    console.log(`üìö [CONTEXT] Loading conversation context`)\r\n\r\n    // Importar din√°micamente para evitar dependencias circulares\r\n    const { loadConversationState } = await import('./conversation-state.ts')\r\n    const { isNewTransactionalRequest, filterTransactionalContext } = await import('./context-filter.ts')\r\n\r\n    // Cargar todo en paralelo\r\n    const [\r\n        recentMessages,\r\n        accountLearnings,\r\n        userPreferences,\r\n        topProducts,\r\n        conversationState\r\n    ] = await Promise.all([\r\n        getChatHistory(supabase, config.userId, contact.id, 20),\r\n        getRelevantLearnings(supabase, config.userId, currentMessage, 5),\r\n        getUserPreferences(supabase, contact.id),\r\n        config.hasProducts ? getTopProducts(supabase, config.userId, 5) : Promise.resolve([]),\r\n        loadConversationState(supabase, contact.id.toString())\r\n    ])\r\n\r\n    // Detectar si es nueva solicitud transaccional\r\n    const isNewRequest = isNewTransactionalRequest(currentMessage, recentMessages);\r\n\r\n    // Filtrar contexto si es nueva solicitud\r\n    const filteredMessages = filterTransactionalContext(recentMessages, isNewRequest);\r\n\r\n    if (isNewRequest && filteredMessages.length < recentMessages.length) {\r\n        console.log(`üßπ [CONTEXT] Filtered ${recentMessages.length - filteredMessages.length} old quote messages`);\r\n    }\r\n\r\n    return {\r\n        recentMessages: filteredMessages,\r\n        accountLearnings,\r\n        userPreferences,\r\n        topProducts,\r\n        conversationState: conversationState || null,\r\n        ragContext: undefined, // Set later in index.ts after RAG retrieval\r\n        activePromotions: [], // TODO: Cargar promociones activas\r\n        appointmentSlots: [] // TODO: Cargar slots si es necesario\r\n    }\r\n}\r\n\r\n/**\r\n * Obtiene las preferencias del usuario\r\n */\r\nasync function getUserPreferences(\r\n    supabase: SupabaseClient,\r\n    contactId: number\r\n) {\r\n    const { data, error } = await supabase\r\n        .from('user_preferences')\r\n        .select('*')\r\n        .eq('contact_id', contactId)\r\n\r\n    if (error) {\r\n        console.error(`‚ùå [CONTEXT] Error fetching preferences: ${error.message}`)\r\n        return []\r\n    }\r\n\r\n    return data || []\r\n}\r\n\r\n/**\r\n * Obtiene los productos m√°s populares\r\n */\r\nasync function getTopProducts(\r\n    supabase: SupabaseClient,\r\n    userId: string,\r\n    limit: number\r\n): Promise<Product[]> {\r\n    const { data, error } = await supabase\r\n        .from('products')\r\n        .select('*')\r\n        .eq('user_id', userId)\r\n        .limit(limit)\r\n\r\n    if (error) {\r\n        console.error(`‚ùå [CONTEXT] Error fetching products: ${error.message}`)\r\n        return []\r\n    }\r\n\r\n    return (data || []) as Product[]\r\n}\r\n"},{"name":"utils/conversation-state.ts","content":"import { SupabaseClient } from 'https://esm.sh/@supabase/supabase-js@2'\r\nimport type {\r\n    ConversationContextState,\r\n    MentionedProduct,\r\n    CartItem\r\n} from '../config/types.ts'\r\n\r\n/**\r\n * Loads conversation state for a contact\r\n */\r\nexport async function loadConversationState(\r\n    supabase: SupabaseClient,\r\n    contactId: string\r\n): Promise<ConversationContextState | null> {\r\n    try {\r\n        const { data, error } = await supabase\r\n            .from('conversation_contexts') // Changed from conversation_states\r\n            .select('state')\r\n            .eq('contact_id', contactId)\r\n            .single()\r\n\r\n        if (error || !data) {\r\n            return null\r\n        }\r\n\r\n        const state = typeof data.state === 'string'\r\n            ? JSON.parse(data.state)\r\n            : data.state\r\n\r\n        // Check if state is stale (older than 24 hours)\r\n        const updatedAt = new Date(state.updatedAt)\r\n        const hoursSince = (Date.now() - updatedAt.getTime()) / 3600000\r\n\r\n        if (hoursSince > 24) {\r\n            console.log(`‚è∞ [STATE] Conversation state is stale (${hoursSince.toFixed(1)}h old), ignoring`)\r\n            return null\r\n        }\r\n\r\n        console.log(`‚úÖ [STATE] Loaded conversation state: ${state.lastProductsMentioned?.length || 0} products mentioned`)\r\n        return state\r\n\r\n    } catch (error) {\r\n        console.error(`‚ùå [STATE] Error loading conversation state:`, error)\r\n        return null\r\n    }\r\n}\r\n\r\n/**\r\n * Saves conversation state for a contact\r\n */\r\nexport async function saveConversationState(\r\n    supabase: SupabaseClient,\r\n    contactId: string,\r\n    state: Partial<ConversationContextState>\r\n): Promise<void> {\r\n    try {\r\n        // Load existing state and merge\r\n        const existing = await loadConversationState(supabase, contactId)\r\n        const merged: ConversationContextState = {\r\n            lastProductsMentioned: state.lastProductsMentioned || existing?.lastProductsMentioned || [],\r\n            tentativeCart: state.tentativeCart || existing?.tentativeCart || [],\r\n            lastIntent: state.lastIntent || existing?.lastIntent || 'unknown',\r\n            lastAgentResponse: state.lastAgentResponse || existing?.lastAgentResponse,\r\n            appointmentContext: state.appointmentContext || existing?.appointmentContext,\r\n            potentialService: state.potentialService || existing?.potentialService,\r\n            updatedAt: new Date().toISOString()\r\n        }\r\n\r\n        await supabase.from('conversation_contexts').upsert({ // Changed from conversation_states\r\n            contact_id: contactId,\r\n            state: merged,\r\n            updated_at: merged.updatedAt\r\n        })\r\n\r\n        console.log(`‚úÖ [STATE] Saved conversation state for contact ${contactId}`)\r\n\r\n    } catch (error) {\r\n        console.error(`‚ùå [STATE] Error saving conversation state:`, error)\r\n    }\r\n}\r\n\r\n/**\r\n * Detects contextual references in user message\r\n * Examples: \"el primero\", \"el segundo\", \"ese\", \"esa\"\r\n */\r\nexport function detectContextualReference(message: string): {\r\n    hasReference: boolean\r\n    position?: number\r\n    type: 'positional' | 'demonstrative' | 'none'\r\n} {\r\n    const lowerMessage = message.toLowerCase()\r\n\r\n    // Positional references: \"el primero\", \"el segundo\", \"la tercera\"\r\n    const positionalPatterns = [\r\n        { pattern: /\\b(el|la)\\s+primer[oa]?\\b/i, position: 1 },\r\n        { pattern: /\\b(el|la)\\s+segund[oa]?\\b/i, position: 2 },\r\n        { pattern: /\\b(el|la)\\s+tercer[oa]?\\b/i, position: 3 },\r\n        { pattern: /\\b(el|la)\\s+cuart[oa]?\\b/i, position: 4 },\r\n        { pattern: /\\b(el|la)\\s+quint[oa]?\\b/i, position: 5 }\r\n    ]\r\n\r\n    for (const { pattern, position } of positionalPatterns) {\r\n        if (pattern.test(lowerMessage)) {\r\n            return { hasReference: true, position, type: 'positional' }\r\n        }\r\n    }\r\n\r\n    // Demonstrative references: \"ese\", \"esa\", \"esos\", \"aquel\"\r\n    if (/\\b(ese|esa|esos|esas|aquel|aquella|aquellos|aquellas)\\b/i.test(lowerMessage)) {\r\n        // Assume they mean the last one mentioned (position 1)\r\n        return { hasReference: true, position: 1, type: 'demonstrative' }\r\n    }\r\n\r\n    return { hasReference: false, type: 'none' }\r\n}\r\n\r\n/**\r\n * Resolves a contextual reference to a product ID\r\n */\r\nexport function resolveReference(\r\n    reference: ReturnType<typeof detectContextualReference>,\r\n    state: ConversationContextState | null\r\n): number | null {\r\n    if (!reference.hasReference || !state || !state.lastProductsMentioned.length) {\r\n        return null\r\n    }\r\n\r\n    const product = state.lastProductsMentioned.find(p => p.position === reference.position)\r\n    return product?.id || null\r\n}\r\n\r\n/**\r\n * Extracts product IDs from agent response (for tracking what was shown)\r\n */\r\nexport function extractMentionedProducts(\r\n    responseText: string,\r\n    productMap: Record<string, any>\r\n): MentionedProduct[] {\r\n    const mentioned: MentionedProduct[] = []\r\n    const productIdRegex = /\\[PRODUCT_(?:CARD|NAME|PRICE|MEDIA):(\\d+)\\]/g\r\n    const foundIds = new Set<number>()\r\n\r\n    let match\r\n    let position = 1\r\n    while ((match = productIdRegex.exec(responseText)) !== null) {\r\n        const id = parseInt(match[1], 10)\r\n        if (!foundIds.has(id) && productMap[id]) {\r\n            foundIds.add(id)\r\n            mentioned.push({\r\n                id,\r\n                position: position++,\r\n                name: productMap[id].productName,\r\n                price: productMap[id].price,\r\n                mentionedAt: new Date().toISOString()\r\n            })\r\n        }\r\n    }\r\n\r\n    return mentioned\r\n}\r\n"},{"name":"utils/cors.ts","content":"/**\n * ELINA V5 - CORS Headers\n */\n\nexport const corsHeaders = {\n    'Access-Control-Allow-Origin': '*',\n    'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',\n    'Access-Control-Allow-Methods': 'POST, GET, OPTIONS, PUT, DELETE'\n}\n"},{"name":"utils/evolution.ts","content":"/**\n * ELINA V5 - Evolution API Client\n * \n * Cliente para interactuar con Evolution API (WhatsApp)\n */\n\nimport type { AccountConfig } from '../config/types.ts'\n\n/**\n * Env√≠a un mensaje de texto\n */\nexport async function sendMessage(\n    config: AccountConfig,\n    remoteJid: string,\n    text: string,\n    enableDelay: boolean = true\n): Promise<void> {\n    console.log(`üì§ [EVOLUTION] Sending message to ${remoteJid}`)\n\n    const url = `${config.evolutionApiUrl}/message/sendText/${config.instanceName}`\n\n    // Calcular delay aleatorio entre 1000-2000ms\n    const delayMs = enableDelay ? Math.floor(Math.random() * 1000) + 1000 : 0\n\n    const payload = {\n        number: remoteJid,\n        text: text,\n        ...(enableDelay && { delay: delayMs })\n    }\n\n    console.log(`üì§ [EVOLUTION] URL: ${url}`)\n    console.log(`üì§ [EVOLUTION] Payload:`, JSON.stringify(payload, null, 2))\n\n    try {\n        const response = await fetch(url, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'apikey': config.evolutionApiKey\n            },\n            body: JSON.stringify(payload)\n        })\n\n        if (!response.ok) {\n            const errorText = await response.text()\n            throw new Error(`Evolution API error: ${response.status} - ${errorText}`)\n        }\n\n        console.log(`‚úÖ [EVOLUTION] Message sent successfully`)\n    } catch (error) {\n        console.error(`‚ùå [EVOLUTION] Error sending message: ${error.message}`)\n        throw error\n    }\n}\n\n/**\n * Env√≠a una imagen\n */\nexport async function sendImage(\n    config: AccountConfig,\n    remoteJid: string,\n    imageUrl: string,\n    caption?: string\n): Promise<void> {\n    console.log(`üì§ [EVOLUTION] Sending image to ${remoteJid}`)\n\n    const url = `${config.evolutionApiUrl}/message/sendMedia/${config.instanceName}`\n\n    // Limpiar n√∫mero (remover @s.whatsapp.net si existe)\n    const cleanNumber = remoteJid.replace('@s.whatsapp.net', '')\n\n    // Extraer extensi√≥n de la URL para mimetype\n    const extension = imageUrl.split('.').pop()?.toLowerCase() || 'jpg'\n    const mimetypes: Record<string, string> = {\n        'jpg': 'image/jpeg',\n        'jpeg': 'image/jpeg',\n        'png': 'image/png',\n        'gif': 'image/gif',\n        'webp': 'image/webp'\n    }\n    const mimetype = mimetypes[extension] || 'image/jpeg'\n\n    // Delay aleatorio entre 1000-2000ms\n    const delayMs = Math.floor(Math.random() * 1000) + 1000\n\n    const payload = {\n        number: cleanNumber,\n        mediatype: 'image',\n        mimetype: mimetype,\n        caption: caption || '',\n        media: imageUrl,\n        fileName: `image.${extension}`,\n        delay: delayMs\n    }\n\n    console.log(`üì§ [EVOLUTION] Payload:`, JSON.stringify(payload, null, 2))\n\n    try {\n        const response = await fetch(url, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'apikey': config.evolutionApiKey\n            },\n            body: JSON.stringify(payload)\n        })\n\n        if (!response.ok) {\n            const errorText = await response.text()\n            throw new Error(`Evolution API error: ${response.status} - ${errorText}`)\n        }\n\n        console.log(`‚úÖ [EVOLUTION] Image sent successfully`)\n    } catch (error) {\n        console.error(`‚ùå [EVOLUTION] Error sending image: ${error.message}`)\n        throw error\n    }\n}\n\n/**\n * Env√≠a un audio\n */\nexport async function sendAudio(\n    config: AccountConfig,\n    remoteJid: string,\n    audioUrl: string\n): Promise<void> {\n    console.log(`üì§ [EVOLUTION] Sending audio to ${remoteJid}`)\n\n    const url = `${config.evolutionApiUrl}/message/sendMedia/${config.instanceName}`\n\n    try {\n        const response = await fetch(url, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'apikey': config.evolutionApiKey\n            },\n            body: JSON.stringify({\n                number: remoteJid,\n                mediatype: 'audio',\n                media: audioUrl\n            })\n        })\n\n        if (!response.ok) {\n            throw new Error(`Evolution API error: ${response.status}`)\n        }\n\n        console.log(`‚úÖ [EVOLUTION] Audio sent successfully`)\n    } catch (error) {\n        console.error(`‚ùå [EVOLUTION] Error sending audio: ${error.message}`)\n        throw error\n    }\n}\n\n/**\n * Env√≠a un video\n */\nexport async function sendVideo(\n    config: AccountConfig,\n    remoteJid: string,\n    videoUrl: string,\n    caption?: string\n): Promise<void> {\n    console.log(`üì§ [EVOLUTION] Sending video to ${remoteJid}`)\n\n    const url = `${config.evolutionApiUrl}/message/sendMedia/${config.instanceName}`\n\n    // Limpiar n√∫mero (remover @s.whatsapp.net si existe)\n    const cleanNumber = remoteJid.replace('@s.whatsapp.net', '')\n\n    // Extraer extensi√≥n para mimetype\n    const extension = videoUrl.split('.').pop()?.toLowerCase() || 'mp4'\n    const mimetypes: Record<string, string> = {\n        'mp4': 'video/mp4',\n        'mov': 'video/quicktime',\n        'avi': 'video/x-msvideo',\n        'webm': 'video/webm'\n    }\n    const mimetype = mimetypes[extension] || 'video/mp4'\n\n    // Delay aleatorio entre 1000-2000ms\n    const delayMs = Math.floor(Math.random() * 1000) + 1000\n\n    const payload = {\n        number: cleanNumber,\n        mediatype: 'video',\n        mimetype: mimetype,\n        caption: caption || '',\n        media: videoUrl,\n        fileName: `video.${extension}`,\n        delay: delayMs\n    }\n\n    console.log(`üì§ [EVOLUTION] Payload:`, JSON.stringify(payload, null, 2))\n\n    try {\n        const response = await fetch(url, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'apikey': config.evolutionApiKey\n            },\n            body: JSON.stringify(payload)\n        })\n\n        if (!response.ok) {\n            const errorText = await response.text()\n            throw new Error(`Evolution API error: ${response.status} - ${errorText}`)\n        }\n\n        console.log(`‚úÖ [EVOLUTION] Video sent successfully`)\n    } catch (error) {\n        console.error(`‚ùå [EVOLUTION] Error sending video: ${error.message}`)\n        throw error\n    }\n}\n\n"},{"name":"utils/message-buffer.ts","content":"/**\n * ELINA V5 - Message Buffer (Supabase Table)\n *\n * Agrupa m√∫ltiples mensajes consecutivos del mismo usuario en una sola respuesta.\n * Usa tabla message_buffer en Supabase para coordinar entre requests independientes.\n *\n * Flujo:\n * 1. Llega mensaje ‚Üí INSERT en message_buffer\n * 2. Esperar BUFFER_WINDOW_MS\n * 3. Consultar si mi mensaje es el m√°s reciente para este contacto\n *    - S√≠ ‚Üí Tomar todos, DELETE, devolver texto combinado\n *    - No ‚Üí Otro mensaje lleg√≥ despu√©s, retornar shouldProcess: false\n */\n\nconst BUFFER_WINDOW_MS = 4000 // 4 segundos para agrupar mensajes\n\nfunction sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms))\n}\n\n/**\n * Agrega un mensaje al buffer y decide si procesar o esperar\n */\nexport async function bufferMessage(\n    supabase: any,\n    accountId: string,\n    contactId: number,\n    messageText: string\n): Promise<{ shouldProcess: boolean; combinedText: string }> {\n\n    // 1. Insertar mensaje en el buffer\n    const { data: inserted, error: insertError } = await supabase\n        .from('message_buffer')\n        .insert({\n            account_id: accountId,\n            contact_id: contactId,\n            message_text: messageText\n        })\n        .select('id, created_at')\n        .single()\n\n    if (insertError || !inserted) {\n        console.error('‚ùå [BUFFER] Error inserting into buffer:', insertError)\n        // Fallback: procesar el mensaje solo sin buffering\n        return { shouldProcess: true, combinedText: messageText }\n    }\n\n    const myId = inserted.id\n    console.log(`üì• [BUFFER] Message buffered (id: ${myId}), waiting ${BUFFER_WINDOW_MS}ms...`)\n\n    // 2. Esperar la ventana de buffer\n    await sleep(BUFFER_WINDOW_MS)\n\n    // 3. Verificar si llegaron mensajes m√°s recientes para este contacto\n    const { data: latest, error: latestError } = await supabase\n        .from('message_buffer')\n        .select('id')\n        .eq('account_id', accountId)\n        .eq('contact_id', contactId)\n        .order('id', { ascending: false })\n        .limit(1)\n        .single()\n\n    if (latestError || !latest) {\n        // Buffer fue limpiado por otro request, no procesar\n        console.log(`‚è≠Ô∏è [BUFFER] Buffer already consumed by another request`)\n        return { shouldProcess: false, combinedText: '' }\n    }\n\n    // Si mi mensaje NO es el m√°s reciente, otro lleg√≥ despu√©s ‚Üí no procesar\n    if (latest.id !== myId) {\n        console.log(`‚è≠Ô∏è [BUFFER] Newer message exists (my: ${myId}, latest: ${latest.id}), skipping`)\n        return { shouldProcess: false, combinedText: '' }\n    }\n\n    // 4. Soy el m√°s reciente ‚Üí tomar todos los mensajes y procesarlos\n    const { data: allMessages, error: fetchError } = await supabase\n        .from('message_buffer')\n        .select('id, message_text, created_at')\n        .eq('account_id', accountId)\n        .eq('contact_id', contactId)\n        .order('created_at', { ascending: true })\n\n    if (fetchError || !allMessages || allMessages.length === 0) {\n        console.error('‚ùå [BUFFER] Error fetching buffered messages:', fetchError)\n        return { shouldProcess: true, combinedText: messageText }\n    }\n\n    // 5. Combinar todos los mensajes\n    const combinedText = allMessages\n        .map((m: any) => m.message_text)\n        .join('\\n')\n\n    // 6. Limpiar el buffer para este contacto\n    const ids = allMessages.map((m: any) => m.id)\n    const { error: deleteError } = await supabase\n        .from('message_buffer')\n        .delete()\n        .in('id', ids)\n\n    if (deleteError) {\n        console.error('‚ö†Ô∏è [BUFFER] Error cleaning buffer (non-critical):', deleteError)\n    }\n\n    console.log(`‚úÖ [BUFFER] Combined ${allMessages.length} messages into one`)\n    return { shouldProcess: true, combinedText }\n}\n\n/**\n * Limpia mensajes viejos del buffer (seguridad, llamar peri√≥dicamente)\n */\nexport async function cleanOldBuffers(supabase: any): Promise<number> {\n    const cutoff = new Date(Date.now() - 60000).toISOString() // 60 segundos\n    const { data, error } = await supabase\n        .from('message_buffer')\n        .delete()\n        .lt('created_at', cutoff)\n        .select('id')\n\n    if (error) {\n        console.error('‚ö†Ô∏è [BUFFER] Error cleaning old buffers:', error)\n        return 0\n    }\n    return data?.length || 0\n}\n"},{"name":"utils/placeholders.ts","content":"/**\n * ELINA V5 - Product Placeholders System\n * \n * Maneja el reemplazo de placeholders de productos y generaci√≥n de cotizaciones\n * Basado en la l√≥gica original de n8n V4\n */\n\nimport type { SupabaseClient } from 'https://esm.sh/@supabase/supabase-js@2'\nimport type { Product, QuoteItem, PlaceholderResult } from '../config/types.ts'\n\n/**\n * Procesa el texto del agente para reemplazar placeholders y detectar cotizaciones\n */\nexport async function processPlaceholders(\n    supabase: SupabaseClient,\n    userId: string,\n    text: string\n): Promise<PlaceholderResult> {\n    let finalText = text\n\n    // 1. Extraer IDs de productos\n    // Regex: Busca [CUALQUIER_COSA:NUMERO]\n    const placeholderRegex = /\\[[^\\]]*?(\\d+)\\]/g\n    const matches = [...text.matchAll(placeholderRegex)]\n    const productIds = [...new Set(matches.map(m => parseInt(m[1], 10)))].filter(id => !isNaN(id))\n\n    if (productIds.length === 0) {\n        return {\n            finalText,\n            productIds: [],\n            productsMap: {},\n            shouldGenerateQuote: false,\n            quoteItems: [],\n            productMedia: []\n        }\n    }\n\n    // 2. Obtener productos de la DB\n    const { data: products, error } = await supabase\n        .rpc('get_products_by_ids', {\n            p_user_id: userId,\n            p_product_ids: productIds\n        })\n\n    if (error || !products) {\n        console.error(`‚ùå [PLACEHOLDERS] Error fetching products: ${error?.message}`)\n        return {\n            finalText, // Devolver texto original si falla\n            productIds,\n            productsMap: {},\n            shouldGenerateQuote: false,\n            quoteItems: [],\n            productMedia: []\n        }\n    }\n\n    // Crear mapa de productos para b√∫squeda r√°pida\n    const productMap: Record<string, Product> = {}\n    products.forEach((p: any) => {\n        productMap[String(p.id)] = {\n            id: p.id,\n            productName: p.product_name,\n            price: Number(p.price),\n            stock: p.stock,\n            description: p.description,\n            mediaUrl: p.media_url,\n            productType: p.product_type\n        }\n    })\n\n    // 3. Reemplazar Placeholders T√©cnicos\n    const techRegex = /\\[PRODUCT_(\\w+):(\\d+)\\]/g\n    finalText = finalText.replace(techRegex, (fullMatch, field, idStr) => {\n        const product = productMap[idStr]\n        if (!product) return fullMatch\n\n        switch (field.toUpperCase()) {\n            case 'NAME': return product.productName\n            case 'PRICE': return `$${product.price.toFixed(2)}`\n            case 'URL': return '' // No mostrar URL en texto, se env√≠a como media autom√°ticamente\n            case 'MEDIA': return '' // No mostrar URL en texto, se env√≠a como media autom√°ticamente\n            case 'STOCK': return String(product.stock)\n            case 'DESC': return product.description || ''\n            default: return fullMatch\n        }\n    })\n\n    // 4. Limpiar Placeholders \"Sucios\" (IA hallucination: [105X:7305])\n    // Reemplaza [CUALQUIER_TEXTO:ID] por el nombre real del producto\n    const messRegex = /\\[([^\\]]+):(\\d+)\\]/g\n    finalText = finalText.replace(messRegex, (fullMatch, content, idStr) => {\n        const product = productMap[idStr]\n        if (!product) return fullMatch\n\n        // Si es un placeholder t√©cnico ya procesado (o que parezca uno), ignorarlo\n        if (content.startsWith('PRODUCT_')) return fullMatch\n\n        return product.productName\n    })\n\n    // 5. Detectar necesidad de cotizaci√≥n\n    const shouldGenerateQuote = detectQuoteNeed(text, productIds.length)\n\n    // 6. Generar items de cotizaci√≥n si es necesario\n    const quoteItems: QuoteItem[] = []\n    if (shouldGenerateQuote) {\n        // Extraer cantidades del texto (simple heuristic)\n        // Busca patrones como \"2 unidades de [PROD:123]\" o \"x3 [PROD:123]\"\n        // Esta es una simplificaci√≥n, la l√≥gica real puede ser m√°s compleja\n        productIds.forEach(id => {\n            const product = productMap[String(id)]\n            if (product) {\n                quoteItems.push({\n                    product_id: product.id,\n                    product_name: product.productName,\n                    quantity: 1, // Default a 1 por ahora\n                    price: product.price,\n                    subtotal: product.price\n                })\n            }\n        })\n    }\n\n    // 7. Recopilar media de productos procesados\n    // Regla: Si el producto fue mencionado (productIds) Y tiene mediaUrl, agregarlo\n    const productMedia: Array<{ productId: number; url: string; type: 'image' | 'video' }> = []\n\n    productIds.forEach(id => {\n        const product = productMap[String(id)]\n        if (product && product.mediaUrl) {\n            // Detectar tipo por extensi√≥n\n            const isVideo = /\\.(mp4|mov|avi|webm)$/i.test(product.mediaUrl)\n            productMedia.push({\n                productId: product.id,\n                url: product.mediaUrl,\n                type: isVideo ? 'video' : 'image'\n            })\n        }\n    })\n\n    console.log(`   - Found ${productMedia.length} product media from ${productIds.length} products`)\n\n    return {\n        finalText,\n        productIds,\n        productsMap: productMap,\n        shouldGenerateQuote,\n        quoteItems,\n        productMedia\n    }\n}\n\n/**\n * Detecta si se debe generar una cotizaci√≥n basado en reglas\n */\nfunction detectQuoteNeed(text: string, productCount: number): boolean {\n    const lowerText = text.toLowerCase()\n\n    // Keywords positivas\n    const quoteKeywords = [\n        'cotizaci√≥n', 'cotizacion', 'presupuesto',\n        'generar pdf', 'enviar pdf', 'formalizar', 'documento'\n    ]\n    const hasKeyword = quoteKeywords.some(k => lowerText.includes(k))\n\n    // Keywords negativas\n    const negativeKeywords = [\n        'no quiero', 'no necesito', 'solo ver',\n        'consultar', 'solo pregunto'\n    ]\n    const hasNegative = negativeKeywords.some(k => lowerText.includes(k))\n\n    if (hasNegative) return false\n\n    // Regla 1: Muchos productos (>= 3) -> Asumir cotizaci√≥n\n    if (productCount >= 3) return true\n\n    // Regla 2: Petici√≥n expl√≠cita\n    if (productCount > 0 && hasKeyword) return true\n\n    return false\n}\n"},{"name":"utils/product-cache.ts","content":"/**\n * ELINA V5 - Product Cache Manager\n *\n * Gestiona el cache de productos mencionados en conversaciones\n * para mantener FAQs y contexto disponible en follow-up questions\n */\n\nimport type { SupabaseClient } from 'https://esm.sh/@supabase/supabase-js@2'\nimport type { ProductWithFAQs } from '../config/types.ts'\n\n/**\n * Cachea productos mencionados en una conversaci√≥n\n */\nexport async function cacheProductsMentioned(\n    supabase: SupabaseClient,\n    userId: string,\n    contactId: number,\n    products: any[] // Productos retornados por buscar_productos\n): Promise<void> {\n    if (!products || products.length === 0) {\n        return\n    }\n\n    console.log(`üíæ [CACHE] Caching ${products.length} mentioned products for contact ${contactId}`)\n\n    try {\n        // Preparar datos para insertar\n        const cacheRecords = products.map(p => ({\n            user_id: userId,\n            contact_id: contactId,\n            product_id: p.id,\n            product_snapshot: {\n                id: p.id,\n                product_name: p.product_name,\n                price: p.price,\n                description: p.description,\n                enhanced_description: p.enhanced_description,\n                media_url: p.media_url,\n                faq: p.faq,\n                benefits: p.benefits,\n                usage_instructions: p.usage_instructions\n            },\n            mentioned_at: new Date().toISOString(),\n            last_accessed_at: new Date().toISOString()\n        }))\n\n        // Upsert: Si ya existe (user_id + contact_id + product_id), actualizar last_accessed_at\n        const { error } = await supabase\n            .from('conversation_product_cache')\n            .upsert(cacheRecords, {\n                onConflict: 'user_id,contact_id,product_id',\n                ignoreDuplicates: false\n            })\n\n        if (error) {\n            console.error(`‚ùå [CACHE] Error caching products: ${error.message}`)\n            // No lanzar error, esto no debe bloquear la conversaci√≥n\n        } else {\n            console.log(`‚úÖ [CACHE] Products cached successfully`)\n        }\n\n    } catch (error) {\n        console.error(`‚ùå [CACHE] Exception caching products: ${error.message}`)\n        // No lanzar error\n    }\n}\n\n/**\n * Obtiene productos mencionados recientemente en una conversaci√≥n\n */\nexport async function getRecentlyMentionedProducts(\n    supabase: SupabaseClient,\n    userId: string,\n    contactId: number,\n    limit: number = 5\n): Promise<ProductWithFAQs[]> {\n    console.log(`üì¶ [CACHE] Fetching recently mentioned products for contact ${contactId}`)\n\n    try {\n        const { data, error } = await supabase\n            .from('conversation_product_cache')\n            .select('product_snapshot, mentioned_at, last_accessed_at')\n            .eq('user_id', userId)\n            .eq('contact_id', contactId)\n            .order('last_accessed_at', { ascending: false })\n            .limit(limit)\n\n        if (error) {\n            console.error(`‚ùå [CACHE] Error fetching cached products: ${error.message}`)\n            return []\n        }\n\n        if (!data || data.length === 0) {\n            console.log(`   - No cached products found`)\n            return []\n        }\n\n        // Mapear snapshots a ProductWithFAQs\n        const products: ProductWithFAQs[] = data.map((record: any) => {\n            const snapshot = record.product_snapshot\n\n            return {\n                id: snapshot.id,\n                productName: snapshot.product_name,\n                price: parseFloat(snapshot.price) || 0,\n                description: snapshot.description,\n                enhanced_description: snapshot.enhanced_description,\n                faq: snapshot.faq,\n                benefits: snapshot.benefits,\n                usage_instructions: snapshot.usage_instructions,\n                mentionedAt: new Date(record.mentioned_at)\n            }\n        })\n\n        console.log(`‚úÖ [CACHE] Found ${products.length} cached products`)\n        return products\n\n    } catch (error) {\n        console.error(`‚ùå [CACHE] Exception fetching cached products: ${error.message}`)\n        return []\n    }\n}\n\n/**\n * Formatea productos cacheados para incluir en el prompt del sistema\n */\nexport function formatCachedProductsForPrompt(products: ProductWithFAQs[]): string {\n    if (!products || products.length === 0) {\n        return ''\n    }\n\n    let formatted = `\\n## üì¶ Productos Mencionados Recientemente en esta Conversaci√≥n\\n`\n    formatted += `(√ösalos para responder preguntas de seguimiento sin necesidad de buscar de nuevo)\\n\\n`\n\n    for (const product of products) {\n        formatted += `### ${product.productName} (ID: ${product.id})\\n`\n        formatted += `- Precio: $${product.price}\\n`\n\n        // Usar enhanced_description si existe\n        const desc = product.enhanced_description || product.description\n        if (desc) {\n            formatted += `- Descripci√≥n: ${desc}\\n`\n        }\n\n        // Incluir benefits si existen\n        if (product.benefits) {\n            formatted += `- Beneficios: ${product.benefits}\\n`\n        }\n\n        // Incluir FAQs si existen\n        if (product.faq && Array.isArray(product.faq) && product.faq.length > 0) {\n            formatted += `- FAQs:\\n`\n            product.faq.forEach((item, idx) => {\n                formatted += `  ${idx + 1}. ${item.question}\\n`\n                formatted += `     ‚Üí ${item.answer}\\n`\n            })\n        }\n\n        formatted += `\\n`\n    }\n\n    return formatted\n}\n\n/**\n * Limpia cache antiguo (llamar peri√≥dicamente o en cron job)\n */\nexport async function cleanupOldCache(supabase: SupabaseClient): Promise<number> {\n    console.log(`üßπ [CACHE] Cleaning up old product cache`)\n\n    try {\n        const { error } = await supabase.rpc('cleanup_old_product_cache')\n\n        if (error) {\n            console.error(`‚ùå [CACHE] Error cleaning up cache: ${error.message}`)\n            return 0\n        }\n\n        console.log(`‚úÖ [CACHE] Old cache cleaned up successfully`)\n        return 1\n\n    } catch (error) {\n        console.error(`‚ùå [CACHE] Exception cleaning up cache: ${error.message}`)\n        return 0\n    }\n}\n"},{"name":"utils/rag-system.ts","content":"/**\n * RAG System with Semantic Embeddings\n * Retrieval-Augmented Generation for context-aware responses\n */\n\nimport { SupabaseClient } from 'https://esm.sh/@supabase/supabase-js@2'\n\n\nconst OPENAI_API_KEY = Deno.env.get('OPENAI_API_KEY')!\nconst EMBEDDING_MODEL = 'text-embedding-3-small'\nconst SIMILARITY_THRESHOLD = 0.35\nconst MAX_CONTEXT_MESSAGES = 5\nconst MAX_PRODUCT_RESULTS = 3\n\nexport interface RAGContext {\n    relevantMessages: Array<{\n        content: string\n        type: string\n        similarity: number\n        created_at: string\n    }>\n    relevantProducts: Array<{\n        product_name: string\n        description: string\n        price: number\n        similarity: number\n    }>\n    contextSummary: string\n    relevantKnowledge: Array<{\n        content: string\n        similarity: number\n        metadata: any\n    }>\n}\n\n/**\n * Generates embedding for text using OpenAI API with caching\n * @param supabase Supabase client\n * @param text Text to generate embedding for\n * @param userId Optional user ID for tracking\n * @returns Embedding vector\n */\nasync function generateEmbedding(\n    supabase: SupabaseClient,\n    text: string,\n    userId?: string\n): Promise<number[]> {\n    try {\n        // Generate hash for cache lookup using Web Crypto API\n        const encoder = new TextEncoder()\n        const textData = encoder.encode(text)\n        const hashBuffer = await crypto.subtle.digest('SHA-256', textData)\n        const hashArray = Array.from(new Uint8Array(hashBuffer))\n        const textHash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('')\n\n\n        // Check cache first\n        const { data: cached } = await supabase\n            .from('embedding_cache')\n            .select('embedding')\n            .eq('text_hash', textHash)\n            .eq('model', EMBEDDING_MODEL)\n            .single()\n\n        if (cached?.embedding) {\n            // console.log(`‚úÖ [RAG] Using cached embedding`)\n\n            // Update usage stats\n            await supabase\n                .from('embedding_cache')\n                .update({\n                    last_used_at: new Date().toISOString(),\n                    usage_count: supabase.rpc('increment', { row_id: textHash })\n                })\n                .eq('text_hash', textHash)\n\n            return cached.embedding\n        }\n\n        // console.log(`üîÑ [RAG] Generating new embedding...`)\n\n        // Generate new embedding\n        const response = await fetch('https://api.openai.com/v1/embeddings', {\n            method: 'POST',\n            headers: {\n                'Authorization': `Bearer ${OPENAI_API_KEY}`,\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                model: EMBEDDING_MODEL,\n                input: text\n            })\n        })\n\n        if (!response.ok) {\n            const error = await response.text()\n            throw new Error(`OpenAI API error: ${error}`)\n        }\n\n        const data = await response.json()\n        const embedding = data.data[0].embedding\n\n        // Cache the embedding\n        await supabase\n            .from('embedding_cache')\n            .insert({\n                text_hash: textHash,\n                text_content: text,\n                embedding,\n                model: EMBEDDING_MODEL,\n                user_id: userId\n            })\n            .select()\n\n        // console.log(`‚úÖ [RAG] Embedding generated and cached`)\n        return embedding\n\n    } catch (error) {\n        console.error(`‚ùå [RAG] Error generating embedding:`, error)\n        throw error\n    }\n}\n\n/**\n * Searches for relevant messages in chat history using semantic similarity\n * @param supabase Supabase client\n * @param userId User ID\n * @param contactId Contact ID\n * @param queryEmbedding Query embedding vector\n * @returns Relevant messages\n */\nasync function searchRelevantMessages(\n    supabase: SupabaseClient,\n    userId: string,\n    contactId: number,\n    queryEmbedding: number[]\n): Promise<RAGContext['relevantMessages']> {\n    try {\n        // console.log(`üîç [RAG] Searching relevant messages...`)\n\n        // Use pgvector similarity search\n        const { data: messages, error } = await supabase.rpc('search_similar_messages', {\n            query_embedding: queryEmbedding,\n            match_threshold: SIMILARITY_THRESHOLD,\n            match_count: MAX_CONTEXT_MESSAGES,\n            p_user_id: userId,\n            p_contact_id: contactId.toString()\n        })\n\n        if (error) {\n            console.error(`‚ùå [RAG] Error searching messages:`, error)\n            return []\n        }\n\n        if (!messages || messages.length === 0) {\n            // console.log(`‚ÑπÔ∏è [RAG] No relevant messages found`)\n            return []\n        }\n\n        // console.log(`‚úÖ [RAG] Found ${messages.length} relevant messages`)\n        return messages.map((msg: any) => ({\n            content: msg.content,\n            type: msg.message_type,\n            similarity: msg.similarity,\n            created_at: msg.created_at\n        }))\n\n    } catch (error) {\n        console.error(`‚ùå [RAG] Error in message search:`, error)\n        return []\n    }\n}\n\n/**\n * Searches for relevant products using semantic similarity\n * @param supabase Supabase client\n * @param userId User ID\n * @param queryEmbedding Query embedding vector\n * @returns Relevant products\n */\nasync function searchRelevantProducts(\n    supabase: SupabaseClient,\n    userId: string,\n    queryEmbedding: number[]\n): Promise<RAGContext['relevantProducts']> {\n    try {\n        // console.log(`üîç [RAG] Searching relevant products...`)\n\n        // Use pgvector similarity search on products\n        const { data: products, error } = await supabase.rpc('search_similar_products', {\n            query_embedding: queryEmbedding,\n            match_threshold: SIMILARITY_THRESHOLD,\n            match_count: MAX_PRODUCT_RESULTS,\n            p_user_id: userId\n        })\n\n        if (error) {\n            console.error(`‚ùå [RAG] Error searching products:`, error)\n            return []\n        }\n\n        if (!products || products.length === 0) {\n            // console.log(`‚ÑπÔ∏è [RAG] No relevant products found`)\n            return []\n        }\n\n        // console.log(`‚úÖ [RAG] Found ${products.length} relevant products`)\n        return products.map((prod: any) => ({\n            product_name: prod.product_name,\n            description: prod.description,\n            price: prod.price,\n            similarity: prod.similarity\n        }))\n\n    } catch (error) {\n        console.error(`‚ùå [RAG] Error in product search:`, error)\n        return []\n    }\n}\n\n/**\n * Searches for relevant knowledge base entries using semantic similarity\n * @param supabase Supabase client\n * @param userId User ID\n * @param queryEmbedding Query embedding vector\n * @returns Relevant knowledge entries\n */\nasync function searchKnowledgeBase(\n    supabase: SupabaseClient,\n    userId: string,\n    queryEmbedding: number[]\n): Promise<RAGContext['relevantKnowledge']> {\n    try {\n        // console.log(`üîç [RAG] Searching knowledge base for user: ${userId}`)\n        // console.log(`üîç [RAG] Query embedding length: ${queryEmbedding.length}`)\n        // console.log(`üîç [RAG] Threshold: ${SIMILARITY_THRESHOLD}, Match count: 3`)\n\n        const { data: knowledge, error } = await supabase.rpc('search_knowledge_base', {\n            query_embedding: queryEmbedding,\n            match_threshold: SIMILARITY_THRESHOLD,\n            match_count: 3,\n            p_user_id: userId\n        })\n\n        // console.log(`üîç [RAG] RPC call completed. Error:`, error, `Data:`, knowledge)\n\n        if (error) {\n            console.error(`‚ùå [RAG] RPC Error: ${error.message} (Code: ${error.code})`)\n            return []\n        }\n\n        if (!knowledge || knowledge.length === 0) {\n            console.log(`‚ÑπÔ∏è [RAG] No knowledge found with threshold ${SIMILARITY_THRESHOLD} for user ${userId}`)\n            return []\n        }\n\n        console.error(`üîç [RAG] Found ${knowledge.length} knowledge chunks`)\n        if (knowledge.length > 0) {\n            console.error(`üìÑ [RAG] First chunk: \"${knowledge[0]?.content?.substring(0, 100)}...\" (similarity: ${knowledge[0]?.similarity})`)\n        }\n        // console.log(`‚úÖ [RAG] Found ${knowledge.length} relevant knowledge chunks`)\n        // console.log(`‚úÖ [RAG] First chunk similarity: ${knowledge[0]?.similarity}`)\n        return knowledge.map((item: any) => ({\n            content: item.content,\n            similarity: item.similarity,\n            metadata: item.metadata\n        }))\n\n    } catch (error) {\n        console.error(`‚ùå [RAG] Error in knowledge base search:`, error)\n        return []\n    }\n}\n\n/**\n * Retrieves relevant context for a user message using RAG\n * @param supabase Supabase client\n * @param userId User ID\n * @param contactId Contact ID\n * @param messageText User message text\n * @returns RAG context with relevant messages and products\n */\nexport async function retrieveContext(\n    supabase: SupabaseClient,\n    userId: string,\n    contactId: number,\n    messageText: string\n): Promise<RAGContext> {\n    try {\n        // console.log(`\\nüß† [RAG] Retrieving context for message...`)\n\n        // Generate embedding for the query\n        const queryEmbedding = await generateEmbedding(supabase, messageText, userId)\n\n        // Search in parallel\n        const [relevantMessages, relevantProducts, relevantKnowledge] = await Promise.all([\n            searchRelevantMessages(supabase, userId, contactId, queryEmbedding),\n            searchRelevantProducts(supabase, userId, queryEmbedding),\n            searchKnowledgeBase(supabase, userId, queryEmbedding)\n        ])\n\n        // Build context summary\n        let contextSummary = ''\n\n        if (relevantMessages.length > 0) {\n            contextSummary += `\\n### Conversaciones Relevantes Anteriores:\\n`\n            relevantMessages.forEach((msg, idx) => {\n                contextSummary += `${idx + 1}. [${msg.type}] ${msg.content.substring(0, 150)}...\\n`\n            })\n        }\n\n        if (relevantProducts.length > 0) {\n            contextSummary += `\\n### Productos Relevantes:\\n`\n            relevantProducts.forEach((prod, idx) => {\n                contextSummary += `${idx + 1}. ${prod.product_name} - $${prod.price}\\n   ${prod.description.substring(0, 100)}...\\n`\n            })\n        }\n\n        if (relevantKnowledge.length > 0) {\n            contextSummary += `\\n### Base de Conocimiento:\\n`\n            relevantKnowledge.forEach((item, idx) => {\n                contextSummary += `${idx + 1}. ${item.content}\\n`\n            })\n        }\n\n        if (!contextSummary) {\n            contextSummary = 'No se encontr√≥ contexto relevante previo.'\n        }\n\n        // console.log(`‚úÖ [RAG] Context retrieved successfully`)\n        // console.log(`   - Messages: ${relevantMessages.length}`)\n        // console.log(`   - Products: ${relevantProducts.length}`)\n        // console.log(`   - Knowledge: ${relevantKnowledge.length}`)\n\n        return {\n            relevantMessages,\n            relevantProducts,\n            relevantKnowledge,\n            contextSummary\n        }\n\n    } catch (error) {\n        console.error(`‚ùå [RAG] Error retrieving context:`, error)\n        return {\n            relevantMessages: [],\n            relevantProducts: [],\n            relevantKnowledge: [],\n            contextSummary: 'Error al recuperar contexto.'\n        }\n    }\n}\n\n/**\n * Formats RAG context for inclusion in AI prompt\n * @param context RAG context\n * @returns Formatted context string\n */\nexport function formatContextForPrompt(context: RAGContext): string {\n    if (!context.relevantMessages.length && !context.relevantProducts.length && !context.relevantKnowledge.length) {\n        return ''\n    }\n\n    let formattedContext = '\\n\\n--- CONTEXTO RELEVANTE ---\\n'\n    formattedContext += context.contextSummary\n    formattedContext += '\\n--- FIN DEL CONTEXTO ---\\n\\n'\n\n    return formattedContext\n}\n"},{"name":"utils/supabase.ts","content":"/**\n * ELINA V5 - Supabase Client\n */\n\nimport { createClient } from 'https://esm.sh/@supabase/supabase-js@2'\n\nexport function createSupabaseAdminClient() {\n    const supabaseUrl = Deno.env.get('SUPABASE_URL')\n    const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')\n\n    if (!supabaseUrl || !supabaseServiceKey) {\n        throw new Error('Missing Supabase environment variables')\n    }\n\n    return createClient(supabaseUrl, supabaseServiceKey, {\n        auth: {\n            autoRefreshToken: false,\n            persistSession: false\n        }\n    })\n}\n"},{"name":"utils/text-formatter.ts","content":"/**\n * ELINA V5 - Text Formatter\n * \n * Formatea texto para WhatsApp con estructura clara y saltos de l√≠nea apropiados\n */\n\n/**\n * Formatea texto para que sea m√°s legible en WhatsApp\n * - Asegura saltos de l√≠nea apropiados\n * - Estructura listas y p√°rrafos\n * - Limpia espacios excesivos\n */\nexport function formatTextForWhatsApp(text: string): string {\n    if (!text) return ''\n\n    let formatted = text\n        // Limpiar markdown residual\n        .replace(/\\*\\*([^*]+)\\*\\*/g, '*$1*') // ** a *\n        .replace(/\\[([^\\]]+)\\]\\([^)]+\\)/g, '$1') // Links [text](url) a text\n\n        // Asegurar espacio despu√©s de puntos seguidos de letra\n        .replace(/\\.([A-Z√Å√â√ç√ì√ö√ë])/g, '. $1')\n\n        // üé® NUEVO: Asegurar salto de l√≠nea antes de emojis de vi√±eta (üîπ, üî∏, ‚ú®, etc.)\n        .replace(/([^\\n])\\s*(üîπ|üî∏|‚ú®|üì¶|üíé|‚≠ê|üéØ|üî•|üí°|üìç|üí∞|üèÜ|üéÅ|‚ö°)/g, '$1\\n$2')\n\n        // üé® NUEVO: Asegurar salto de l√≠nea despu√©s de precio (formato $XXX.XX o $XXX)\n        .replace(/(\\$[\\d,]+\\.?\\d*)\\s+(?=[üîπüî∏‚ú®üì¶üíé‚≠êüéØüî•üí°üìçüí∞üèÜüéÅ‚ö°¬ø?A-Z])/g, '$1\\n')\n\n        // Asegurar salto de l√≠nea despu√©s de dos puntos si sigue lista\n        .replace(/:(\\s*)-/g, ':\\n-')\n        .replace(/:(\\s*)\\d+\\./g, ':\\n$1$2.')\n\n        // Asegurar salto antes de vi√±etas si no lo hay\n        .replace(/([^\\n])\\n?-\\s/g, '$1\\n- ')\n        .replace(/([^\\n])\\n?‚Ä¢\\s/g, '$1\\n‚Ä¢ ')\n\n        // Asegurar salto antes de n√∫meros de lista\n        .replace(/([^\\n])\\n?(\\d+)\\.\\s/g, '$1\\n$2. ')\n\n        // üé® NUEVO: Asegurar salto antes de preguntas (¬ø...?)\n        .replace(/([^\\n])\\s*(¬ø[^?]+\\?)/g, '$1\\n$2')\n\n        // Limpiar espacios m√∫ltiples\n        .replace(/[ \\t]{2,}/g, ' ')\n\n        // Normalizar saltos de l√≠nea (m√°ximo 2 seguidos)\n        .replace(/\\n{3,}/g, '\\n\\n')\n\n        // Limpiar espacios al inicio/fin de l√≠neas\n        .split('\\n')\n        .map(line => line.trim())\n        .join('\\n')\n\n        .trim()\n\n    return formatted\n}\n\n/**\n * Distribuye texto entre m√∫ltiples items de media (como n8n)\n * Retorna array de objetos con media_url y caption\n */\nexport interface MediaWithCaption {\n    type: 'image' | 'video'\n    url: string\n    caption: string\n}\n\nexport function distributeTextAcrossMedia(\n    fullText: string,\n    mediaUrls: Array<{ type: 'image' | 'video', url: string }>,\n    maxMedia: number = 3\n): MediaWithCaption[] {\n    if (mediaUrls.length === 0) {\n        return []\n    }\n\n    // ============================================================================\n    // EXACT n8n V4 LOGIC: Extract URLs from text with regex, not from list\n    // ============================================================================\n\n    // 1. Find ALL URLs in the text using regex (like n8n V4)\n    const mediaRegex = /https?:\\/\\/[^\\s\"'<>]+\\.(?:png|jpg|jpeg|gif|webp|mp4)/gi\n    const matches = [...fullText.matchAll(mediaRegex)]\n\n    // If no URLs found in text, return empty\n    if (matches.length === 0) {\n        return []\n    }\n\n    // 2. Limit to max 3 media\n    const maxMediaCount = Math.min(matches.length, maxMedia)\n    const results: MediaWithCaption[] = []\n    let lastIndex = 0\n\n    // 3. For each URL found in text:\n    for (let i = 0; i < maxMediaCount; i++) {\n        const match = matches[i]\n        const url = match[0]\n        const isVideo = url.toLowerCase().endsWith('.mp4')\n\n        // Get text BEFORE this URL\n        let textBefore = fullText.substring(lastIndex, match.index)\n            .replace(/Imagen:\\s*$/i, \"\")  // Remove \"Imagen:\" label\n            .replace(/Video:\\s*$/i, \"\")   // Remove \"Video:\" label\n            .trim()\n\n        // CRITICAL: If this is the LAST media we're sending (e.g., 3rd)\n        if (i === maxMediaCount - 1) {\n            // Get ALL remaining text after this URL\n            let restOfText = fullText.substring(match.index + url.length)\n\n            // CLEAN IT: Remove any remaining URLs and labels\n            restOfText = restOfText\n                .replace(mediaRegex, \"\")           // Remove all URLs\n                .replace(/Imagen:\\s*/gi, \"\")       // Remove \"Imagen:\" labels\n                .replace(/Video:\\s*/gi, \"\")        // Remove \"Video:\" labels\n                .replace(/\\n{3,}/g, \"\\n\\n\")        // Clean extra newlines\n                .trim()\n\n            // APPEND remaining text to this caption\n            if (restOfText) {\n                textBefore = (textBefore + \"\\n\\n\" + restOfText).trim()\n            }\n        }\n\n        results.push({\n            type: isVideo ? 'video' : 'image',\n            url: url,\n            caption: formatTextForWhatsApp(textBefore)\n        })\n\n        lastIndex = match.index + url.length\n    }\n\n    return results\n}\n\n/**\n * EXACT n8n V4 CODE: \"IMG - Split a 3 env√≠os\"\n * Splits text with media URLs into multiple messages (max 3)\n * Each message has a media_url and its corresponding caption\n */\nexport interface MediaMessage {\n    type: 'image' | 'video' | 'text'\n    media_url: string\n    url_imagen?: string\n    caption: string\n    'mensaje texto '?: string\n}\n\nexport function splitMediaIntoMessages(\n    textoCompleto: string,\n    mediaType: 'image' | 'video' = 'image'\n): MediaMessage[] {\n    // REGEX EXACTO de n8n V4\n    const mediaRegex = /https?:\\/\\/[^\\s\"'<>]+\\.(?:png|jpg|jpeg|gif|webp|mp4)/gi\n    const matches = [...textoCompleto.matchAll(mediaRegex)]\n\n    // Si no hay multimedia, enviamos el texto tal cual\n    if (matches.length === 0) {\n        return [{\n            type: 'text',\n            media_url: '',\n            caption: textoCompleto,\n            'mensaje texto ': textoCompleto\n        }]\n    }\n\n    const results: MediaMessage[] = []\n    let lastIndex = 0\n    const maxMedia = Math.min(matches.length, 3)\n\n    for (let i = 0; i < maxMedia; i++) {\n        const match = matches[i]\n        const url = match[0]\n        const isVideo = url.toLowerCase().endsWith('.mp4')\n\n        // Extraemos el texto previo a la imagen actual y limpiamos etiquetas\n        let textBefore = textoCompleto.substring(lastIndex, match.index)\n            .replace(/Imagen:\\s*$/i, \"\") // Quitar \"Imagen:\" si est√° justo antes\n            .trim()\n\n        // Si es la √∫ltima imagen que vamos a mandar (ej. la 3¬™)\n        if (i === maxMedia - 1) {\n            // Tomamos el resto del mensaje que queda despu√©s de esta URL\n            let restOfText = textoCompleto.substring(match.index + url.length)\n\n            // LIMPIEZA CR√çTICA: Borramos CUALQUIER otra URL de imagen/video que haya sobrado\n            // Tambi√©n limpiamos las palabras \"Imagen:\" residuales que queden solas\n            restOfText = restOfText\n                .replace(mediaRegex, \"\")\n                .replace(/Imagen:\\s*/gi, \"\")\n                .replace(/\\n{3,}/g, \"\\n\\n\") // Evitar demasiados saltos de l√≠nea vac√≠os\n                .trim()\n\n            if (restOfText) {\n                textBefore = (textBefore + \"\\n\\n\" + restOfText).trim()\n            }\n        }\n\n        results.push({\n            type: isVideo ? 'video' : 'image',\n            media_url: url,\n            url_imagen: url,\n            caption: textBefore,\n            'mensaje texto ': textBefore\n        })\n\n        lastIndex = match.index + url.length\n    }\n\n    return results\n}\n\n"},{"name":"utils/tool-executor.ts","content":"/**\n * ELINA V5 - Tool Executor\n * \n * Ejecuta las llamadas a herramientas (tool calls) del LLM\n */\n\nimport type { SupabaseClient } from 'https://esm.sh/@supabase/supabase-js@2'\nimport type { AccountConfig, ToolCall, ToolResult } from '../config/types.ts'\nimport { buscarProductos, agendarCita, consultarDisponibilidad } from './tools.ts'\n\n/**\n * Ejecuta una lista de tool calls y devuelve los resultados\n */\nexport async function executeToolCalls(\n    supabase: SupabaseClient,\n    config: AccountConfig,\n    contactId: number,\n    toolCalls: ToolCall[],\n    conversationState?: any,  // ‚Üê Par√°metro para estado conversacional\n    userMessage?: string      // ‚Üê Nuevo: mensaje original del usuario para detecci√≥n inteligente\n): Promise<ToolResult[]> {\n    console.log(`üîß [TOOLS] Executing ${toolCalls.length} tool call(s)`)\n\n    const results: ToolResult[] = []\n\n    for (const toolCall of toolCalls) {\n        const functionName = toolCall.function.name\n        const functionArgs = JSON.parse(toolCall.function.arguments)\n\n        console.log(`   - Calling: ${functionName}`, functionArgs)\n\n        try {\n            let result: any\n\n            switch (functionName) {\n                case 'buscar_productos':\n                    const searchResult = await buscarProductos(\n                        supabase,\n                        config.userId,\n                        functionArgs.query,\n                        functionArgs.limit || 5,\n                        userMessage // ‚Üê Pasar mensaje original para detecci√≥n autom√°tica\n                    )\n\n                    // Handle new structured response format\n                    if (searchResult.status === 'ERROR' || searchResult.status === 'NOT_FOUND') {\n                        result = {\n                            status: searchResult.status,\n                            message: searchResult.message,\n                            products: []\n                        }\n                    } else {\n                        // SUCCESS case - combine exact matches and alternatives\n                        const allProducts = [\n                            ...(searchResult.exact_matches || []),\n                            ...(searchResult.suggested_alternatives || [])\n                        ]\n\n                        // Separate services for special formatting\n                        const services = allProducts.filter(p => p.product_type === 'service')\n                        const physicalProducts = allProducts.filter(p => p.product_type !== 'service')\n\n                        result = {\n                            status: searchResult.status,\n                            message: searchResult.message,\n                            exact_match_found: searchResult.exact_match_found,\n                            has_alternatives: searchResult.has_alternatives,\n                            products: allProducts,\n                            services: services,  // Store for code-based formatting\n                            physicalProducts: physicalProducts,\n                            // Pass formatting hints to agent\n                            formatting_hint: searchResult.exact_matches?.map(p => p.formatting_hint).join('\\n') || ''\n                        }\n                    }\n                    break\n\n                    break\n\n                case 'consultar_disponibilidad':\n                    result = await consultarDisponibilidad(\n                        supabase,\n                        config.userId,\n                        functionArgs.date,\n                        config.slug // Pasar el slug para generar link\n                    )\n                    break\n\n                case 'agendar_cita':\n                    result = await agendarCita(\n                        supabase,\n                        config.userId,\n                        contactId,\n                        functionArgs.date,\n                        functionArgs.time,\n                        functionArgs.service_id,\n                        functionArgs.notes,\n                        conversationState  // ‚Üê Pasar el estado\n                    )\n                    break\n\n                case 'consultar_mis_citas':\n                    const { consultarMisCitas } = await import('./tools.ts')\n                    result = await consultarMisCitas(\n                        supabase,\n                        config.userId,\n                        contactId\n                    )\n                    break\n\n                case 'modificar_cita':\n                    const { modificarCita } = await import('./tools.ts')\n                    result = await modificarCita(\n                        supabase,\n                        config.userId,\n                        contactId,\n                        functionArgs.appointment_id,\n                        functionArgs.new_date,\n                        functionArgs.new_time\n                    )\n                    break\n\n                case 'consultar_promociones':\n                    const { consultarPromociones } = await import('./tools.ts')\n                    result = await consultarPromociones(\n                        supabase,\n                        config.userId\n                    )\n                    break\n\n                default:\n                    console.warn(`‚ö†Ô∏è [TOOLS] Unknown tool: ${functionName}`)\n                    result = { error: `Unknown tool: ${functionName}` }\n            }\n\n            results.push({\n                tool_call_id: toolCall.id,\n                role: 'tool',\n                name: functionName,\n                content: JSON.stringify(result)\n            })\n\n            console.log(`   ‚úÖ ${functionName} completed`)\n\n        } catch (error) {\n            console.error(`   ‚ùå Error executing ${functionName}:`, error)\n            results.push({\n                tool_call_id: toolCall.id,\n                role: 'tool',\n                name: functionName,\n                content: JSON.stringify({\n                    error: error instanceof Error ? error.message : String(error)\n                })\n            })\n        }\n    }\n\n    return results\n}\n"},{"name":"utils/tools.ts","content":"/**\n * ELINA V5 - Tools Implementation\n * \n * Implementaci√≥n de las herramientas disponibles para el agente\n */\n\nimport type { SupabaseClient } from 'https://esm.sh/@supabase/supabase-js@2'\n\n/**\n * Genera respuesta de proceso de compra usando LLM con datos disponibles\n */\nasync function generatePurchaseResponse(\n    companyName: string,\n    contactData: string\n): Promise<string> {\n    try {\n        const prompt = `Genera una respuesta BREVE (m√°ximo 2-3 l√≠neas) sobre c√≥mo un cliente puede contratar/comprar.\n\nEmpresa: ${companyName}\nCanales disponibles:\n${contactData}\n\nREGLAS CR√çTICAS:\n1. M√°ximo 2-3 l√≠neas\n2. Incluye SOLO los canales mencionados arriba\n3. Tono amigable para WhatsApp\n4. NO inventes canales que no existen\n5. Formato simple, sin markdown complejo`\n\n        const response = await fetch('https://api.openai.com/v1/chat/completions', {\n            method: 'POST',\n            headers: {\n                'Authorization': `Bearer ${Deno.env.get('OPENAI_API_KEY')}`,\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                model: 'gpt-4o-mini',\n                messages: [{ role: 'user', content: prompt }],\n                temperature: 0.7,\n                max_tokens: 100\n            })\n        })\n\n        if (!response.ok) throw new Error('LLM failed')\n\n        const data = await response.json()\n        return data.choices[0]?.message?.content?.trim() || `Cont√°ctanos:\\n${contactData}`\n\n    } catch (error) {\n        console.error('‚ùå [TOOL] Error generating response:', error)\n        return `Puedes contactarnos:\\n${contactData}`\n    }\n}\n\n/**\n * Sistema de cascada inteligente para obtener info de proceso de compra\n * Nivel 1: B√∫squeda sem√°ntica en FAQs (RAG)\n * Nivel 2: Generaci√≥n din√°mica con LLM usando datos del perfil\n * Nivel 3: Formato simple de datos disponibles\n * Nivel 4: Mensaje gen√©rico profesional\n */\nasync function fetchPurchaseProcessInfo(\n    supabase: SupabaseClient,\n    userId: string\n): Promise<string | null> {\n    try {\n        // NIVEL 1: B√∫squeda sem√°ntica en knowledge_base usando RAG\n        console.log(`üîç [PURCHASE_INFO] Nivel 1: Buscando en FAQs con RAG...`)\n\n        const { retrieveContext } = await import('./rag-system.ts')\n        const purchaseQuery = \"¬øC√≥mo puedo contratar, comprar o adquirir este producto o servicio? ¬øD√≥nde lo compro?\"\n\n        const ragContext = await retrieveContext(supabase, userId, 0, purchaseQuery)\n\n        if (ragContext.relevantKnowledge && ragContext.relevantKnowledge.length > 0) {\n            const topMatch = ragContext.relevantKnowledge[0]\n            // Umbral de confianza: 0.35 es suficientemente similar\n            if (topMatch.similarity >= 0.35) {\n                console.log(`‚úÖ [PURCHASE_INFO] FAQ encontrada (similarity: ${topMatch.similarity})`)\n                return `\\n\\nüìã **INFORMACI√ìN IMPORTANTE:**\\n${topMatch.content}`\n            }\n            console.log(`‚ö†Ô∏è [PURCHASE_INFO] FAQ similarity baja (${topMatch.similarity}), continuando...`)\n        }\n\n        // NIVEL 2: No hay FAQs relevantes - Buscar datos del perfil\n        console.log(`üîç [PURCHASE_INFO] Nivel 2: Obteniendo datos del perfil...`)\n\n        const { data: profile } = await supabase\n            .from('profiles')\n            .select('website, business_phone, business_address, social_media, company_name')\n            .eq('id', userId)\n            .single()\n\n        if (!profile) {\n            console.log(`‚ö†Ô∏è [PURCHASE_INFO] No se encontr√≥ perfil`)\n            return null\n        }\n\n        // Construir informaci√≥n de contacto disponible\n        const contactChannels: string[] = []\n        if (profile.website) contactChannels.push(`üåê Sitio web: ${profile.website}`)\n        if (profile.business_phone) contactChannels.push(`üìû Tel√©fono: ${profile.business_phone}`)\n        if (profile.business_address) contactChannels.push(`üìç Direcci√≥n: ${profile.business_address}`)\n        if (profile.social_media?.whatsapp) contactChannels.push(`üí¨ WhatsApp: ${profile.social_media.whatsapp}`)\n        if (profile.social_media?.instagram) contactChannels.push(`üì± Instagram: @${profile.social_media.instagram}`)\n        if (profile.social_media?.facebook) contactChannels.push(`üë• Facebook: ${profile.social_media.facebook}`)\n\n        if (contactChannels.length === 0) {\n            // NIVEL 4: No hay datos - Mensaje gen√©rico profesional\n            console.log(`‚ö†Ô∏è [PURCHASE_INFO] Nivel 4: Sin datos de contacto, mensaje gen√©rico`)\n            return '\\n\\nüìã Cont√°ctanos directamente para m√°s informaci√≥n sobre c√≥mo adquirir este producto o servicio.'\n        }\n\n        // NIVEL 2B: Generar respuesta inteligente con LLM\n        console.log(`ü§ñ [PURCHASE_INFO] Nivel 2B: Generando respuesta con LLM...`)\n        const contactData = contactChannels.join('\\n')\n        const companyName = profile.company_name || 'nuestra empresa'\n\n        const generatedResponse = await generatePurchaseResponse(companyName, contactData)\n        console.log(`‚úÖ [PURCHASE_INFO] Respuesta generada exitosamente`)\n\n        return `\\n\\nüìã **INFORMACI√ìN IMPORTANTE:**\\n${generatedResponse}`\n\n    } catch (error) {\n        console.error(`‚ùå [TOOL] Error fetching purchase info:`, error)\n        // NIVEL 3: Fallback en caso de error\n        return '\\n\\nüìã Para adquirir este producto, cont√°ctanos directamente.'\n    }\n}\n\n/**\n * Busca productos por query\n */\nexport async function buscarProductos(\n    supabase: SupabaseClient,\n    userId: string,\n    query: string,\n    limit: number = 5,\n    originalMessage?: string // Nuevo par√°metro para detectar intent de compra\n): Promise<any> {\n    console.log(`üîç [TOOL] Searching products: \"${query}\"`)\n\n    // Normalizaci√≥n de queries gen√©ricos (con posibles typos o caracteres extra)\n    // Si el usuario pone \"que vendes_\", \"catalogo\", \"lista\", lo tratamos como vac√≠o para mostrar todo.\n    const genericKeywords = ['que vendes', 'qu√© vendes', 'que tienes', 'qu√© tienes', 'catalogo', 'cat√°logo', 'productos', 'lista', 'precio', 'precios']\n    const normalizedQuery = query.toLowerCase().replace(/[^\\w\\s√±√°√©√≠√≥√∫]/g, '').trim() // Quitar caracteres raros como \"_\"\n\n    // Detectar si el usuario pregunta espec√≠ficamente por SERVICIOS\n    const serviceKeywords = ['servicio', 'servicios', 'cita', 'citas', 'que servicios', 'qu√© servicios']\n    const isAskingForServices = serviceKeywords.some(k => normalizedQuery.includes(k))\n\n    let effectiveQuery = query\n    if (genericKeywords.some(k => normalizedQuery.includes(k)) || normalizedQuery.length < 3 || isAskingForServices) {\n        effectiveQuery = '' // Forzar modo \"ver todo\" para keywords gen√©ricos O servicios\n    }\n\n    // CASO 1: Query vac√≠o -> Mostrar cat√°logo general (sin clasificar)\n    if (!effectiveQuery || effectiveQuery.trim() === '') {\n        // Si pregunta por servicios, filtrar solo servicios\n        if (isAskingForServices) {\n            const { data, error } = await supabase\n                .from('products')\n                .select('id, product_name, sku, price, stock, description, media_url, product_type, benefits, usage_instructions, faq')\n                .eq('user_id', userId)\n                .eq('product_type', 'service')\n                .order('created_at', { ascending: false })\n                .limit(limit)\n\n            if (error) {\n                console.error(`‚ùå [TOOL] Error fetching services:`, error)\n                return { status: \"ERROR\", message: \"Error consultando servicios.\" }\n            }\n\n            return {\n                status: \"SUCCESS\",\n                message: \"Aqu√≠ est√°n los servicios disponibles.\",\n                exact_match_found: true,\n                exact_matches: data?.map(p => {\n                    const benefits = p.benefits ? `\\n‚ú® Benefits: ${p.benefits}` : '';\n                    const usage = p.usage_instructions ? `\\nüìù Usage: ${p.usage_instructions}` : '';\n                    const faqContent = p.faq?.content ? `\\n‚ùì FAQ: ${p.faq.content}` : '';\n                    return {\n                        ...p,\n                        formatting_hint: `üõçÔ∏è *${p.product_name}* ‚Äî $${p.price}\\nüîπ ${p.description || ''}${benefits}${usage}${faqContent}\\n\\n`\n                    }\n                }) || [],\n                has_alternatives: false,\n                suggested_alternatives: []\n            }\n        } else {\n            // Modo MIXTO: Traer productos y servicios por separado para mostrar variedad\n            // 1. Productos F√≠sicos\n            const { data: products } = await supabase\n                .from('products')\n                .select('id, product_name, sku, price, stock, description, media_url, product_type, benefits, usage_instructions, faq')\n                .eq('user_id', userId)\n                .neq('product_type', 'service') // Excluir servicios\n                .order('created_at', { ascending: false })\n                .limit(3)\n\n            // 2. Servicios\n            const { data: services } = await supabase\n                .from('products')\n                .select('id, product_name, sku, price, stock, description, media_url, product_type, benefits, usage_instructions, faq')\n                .eq('user_id', userId)\n                .eq('product_type', 'service') // Solo servicios\n                .order('created_at', { ascending: false })\n                .limit(3)\n\n            const mixedData = [...(products || []), ...(services || [])]\n\n            return {\n                status: \"SUCCESS\",\n                message: \"Aqu√≠ tienes una selecci√≥n de nuestros productos y servicios.\",\n                exact_match_found: true,\n                exact_matches: mixedData.map(p => {\n                    const benefits = p.benefits ? `\\n‚ú® Benefits: ${p.benefits}` : '';\n                    const usage = p.usage_instructions ? `\\nüìù Usage: ${p.usage_instructions}` : '';\n                    const faqContent = p.faq?.content ? `\\n‚ùì FAQ: ${p.faq.content}` : '';\n\n                    return {\n                        ...p,\n                        formatting_hint: p.product_type === 'service'\n                            ? `üõçÔ∏è *${p.product_name}* ‚Äî $${p.price}\\nüîπ ${p.description || ''}${benefits}${usage}${faqContent}\\n\\n`\n                            : `üõçÔ∏è *${p.product_name}* ‚Äî $${p.price}\\nüîπ ${p.description || ''}\\n\\n` // Use same format for physical products\n                    }\n                }),\n                has_alternatives: false,\n                suggested_alternatives: []\n            }\n        }\n    }\n\n    // CASO 2: B√∫squeda Vectorial / Fulltext\n    const { data, error } = await supabase.rpc('search_products_fulltext', {\n        p_user_id: userId,\n        p_query: effectiveQuery, // Usar la query normalizada/efectiva\n        p_limit: limit\n    })\n\n    if (error) {\n        console.error(`‚ùå [TOOL] Error searching products:`, error)\n        return { status: \"ERROR\", message: \"Error en la b√∫squeda.\" }\n    }\n\n    const results = data || []\n\n    // Clasificaci√≥n por fidelidad (L√≥gica Proactiva de n8n)\n    const highConfidence = results\n\n    if (highConfidence.length === 0) {\n        // üìä Log b√∫squeda fallida para analytics (non-blocking)\n        supabase.from('product_search_misses').insert({\n            user_id: userId,\n            query: query,\n            original_message: originalMessage,\n            timestamp: new Date().toISOString()\n        }).then(() => {\n            console.log(`üìä [ANALYTICS] Search miss logged: \"${query}\"`)\n        }).catch((err: any) => {\n            console.error(`‚ùå [ANALYTICS] Failed to log search miss:`, err)\n        })\n\n        return {\n            status: \"NOT_FOUND\",\n            message: `No encontr√© productos que coincidan con '${query}'.`\n        }\n    }\n\n    // üéØ DETECCI√ìN AUTOM√ÅTICA: Si el mensaje original contiene palabras de compra/contrataci√≥n\n    // autom√°ticamente buscamos y agregamos info del proceso de compra\n    let purchaseInfo = null\n    if (originalMessage) {\n        const purchaseKeywords = ['contratar', 'comprar', 'adquirir', 'obtener', 'conseguir', 'me ayuda']\n        const hasPurchaseIntent = purchaseKeywords.some(kw =>\n            originalMessage.toLowerCase().includes(kw)\n        )\n\n        if (hasPurchaseIntent) {\n            console.log(`üõí [TOOL] Purchase intent detected, fetching process info...`)\n            purchaseInfo = await fetchPurchaseProcessInfo(supabase, userId)\n            if (purchaseInfo) {\n                console.log(`‚úÖ [TOOL] Purchase process info added automatically`)\n            }\n        }\n    }\n\n    // Estructura \"Anti-Alucinaci√≥n\" con Urgencia/Escasez\n    const result: any = {\n        status: \"SUCCESS\",\n        message: `Encontr√© ${highConfidence.length} coincidencias para '${query}'.`,\n        exact_match_found: highConfidence.length > 0,\n        exact_matches: highConfidence.map(r => {\n            let urgencyNote = ''\n\n            // üî• URGENCIA: Stock bajo (√∫ltimas unidades)\n            if (r.stock !== null && r.stock > 0 && r.stock <= 5) {\n                urgencyNote = `\\n‚ö†Ô∏è ¬°√öltimas ${r.stock} unidades disponibles!`\n            }\n\n            // üî• URGENCIA: Sin stock (agotado)\n            if (r.stock !== null && r.stock === 0) {\n                urgencyNote = `\\n‚ùå Agotado temporalmente`\n            }\n\n            return {\n                id: r.id,\n                name: r.product_name,\n                price: r.price,\n                stock: r.stock,\n                description: r.description,\n                media_url: r.media_url, // ‚úÖ ADDED: Include media_url for automatic media sending\n                enhanced_description: r.enhanced_description,\n                faq: r.faq,\n                benefits: r.benefits,\n                usage_instructions: r.usage_instructions,\n                formatting_hint: `üõçÔ∏è *${r.product_name}* ‚Äî $${r.price}${urgencyNote}\\nüîπ ${r.description || ''}\\n\\n`\n            }\n        }),\n        has_alternatives: false,\n        suggested_alternatives: []\n    }\n\n    // Si encontramos info de proceso de compra, agregarla al resultado\n    if (purchaseInfo) {\n        result.purchase_process_info = purchaseInfo\n        result.message += ' ' + purchaseInfo\n    }\n\n    return result\n}\n\n/**\n * Consulta disponibilidad de citas\n */\nexport async function consultarDisponibilidad(\n    supabase: SupabaseClient,\n    userId: string,\n    date?: string,\n    slug?: string // Propiedad opcional para link\n): Promise<any> {\n    console.log(`üìÖ [TOOL] Checking availability for date: ${date || 'next 7 days'}`)\n\n    const { getAvailableSlots, formatAppointmentContext } = await import('./appointment-manager.ts')\n    const slots = await getAvailableSlots(userId, 7)\n\n    return {\n        available: slots.length > 0,\n        // Proporcionar contexto formateado para que el LLM lo use directamente\n        formatted_response: formatAppointmentContext(slots, slug),\n        // Mantener slots crudos por si el LLM necesita datos estructurados precisos\n        raw_slots: slots.map(slot => ({\n            start_time: slot.start_time,\n            service_name: slot.service_name,\n            duration_minutes: slot.duration_minutes\n        }))\n    }\n}\n\n/**\n * Agenda una cita\n */\nexport async function agendarCita(\n    supabase: SupabaseClient,\n    userId: string,\n    contactId: number,\n    date: string,\n    time: string,\n    serviceId?: number,\n    notes?: string,\n    conversationState?: any  // ‚Üê Nuevo par√°metro para acceder al estado\n): Promise<any> {\n    console.log(`üìÖ [TOOL] Creating appointment...`)\n\n    // Si no se proporciona serviceId, intentar detectarlo del contexto\n    let finalServiceId = serviceId\n\n    if (!finalServiceId) {\n        console.log(`üîç [TOOL] No service_id provided, searching conversation context...`)\n\n        // 1. Revisar si hay un servicio en el estado de conversaci√≥n\n        if (conversationState?.potentialService?.id) {\n            finalServiceId = conversationState.potentialService.id\n            console.log(`‚úÖ [TOOL] Found service in conversation state: ${conversationState.potentialService.name} (${finalServiceId})`)\n        }\n\n        // 2. Si no hay en el estado, buscar en mensajes recientes (√∫ltimas 24h)\n        if (!finalServiceId) {\n            const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString()\n            const { data: recentMessages } = await supabase\n                .from('chat_history')\n                .select('message_text')\n                .eq('contact_id', contactId)\n                .gt('created_at', oneDayAgo)\n                .order('created_at', { ascending: false })\n                .limit(10)\n\n            if (recentMessages && recentMessages.length > 0) {\n                // Buscar menciones de servicios en los mensajes\n                const { data: services } = await supabase\n                    .from('products')\n                    .select('id, product_name')\n                    .eq('user_id', userId)\n                    .eq('product_type', 'service')\n\n                if (services) {\n                    // Buscar si alg√∫n servicio fue mencionado\n                    for (const service of services) {\n                        const serviceName = service.product_name.toLowerCase()\n                        const mentioned = recentMessages.some(msg =>\n                            msg.message_text?.toLowerCase().includes(serviceName)\n                        )\n                        if (mentioned) {\n                            finalServiceId = service.id\n                            console.log(`‚úÖ [TOOL] Found service mentioned in history: ${service.product_name} (${finalServiceId})`)\n                            break\n                        }\n                    }\n                }\n            }\n        }\n\n        // 3. Si a√∫n no hay, usar el primer servicio disponible\n        if (!finalServiceId) {\n            console.log(`üîç [TOOL] No service found in context, fetching default service...`)\n            const { data: services } = await supabase\n                .from('products')\n                .select('id')\n                .eq('user_id', userId)\n                .eq('product_type', 'service')\n                .limit(1)\n                .single()\n\n            if (services) {\n                finalServiceId = services.id\n                console.log(`‚úÖ [TOOL] Using default service: ${finalServiceId}`)\n            } else {\n                return {\n                    success: false,\n                    error: 'No hay servicios disponibles para agendar'\n                }\n            }\n        }\n    }\n\n    // Combinar fecha y hora en ISO 8601\n    // IMPORTANTE: La fecha y hora que recibimos (ej: \"2026-02-12\", \"15:00\")\n    // son en la ZONA HORARIA DEL USUARIO/EMPRESA.\n    // Supabase espera UTC. Debemos convertir.\n\n    // 1. Obtener configuraci√≥n para saber timezone\n    const { getAppointmentSettings } = await import('./appointment-manager.ts')\n    const settings = await getAppointmentSettings(supabase, userId)\n    const timezone = settings?.working_hours?.timezone || 'America/Mexico_City'\n\n    // 2. Crear fecha en esa zona horaria\n    // \"2026-02-12T15:00:00\" -> Interpretar como hora CDMX\n    // NOTA: Deno deploy no siempre tiene feriados o timezones complejos nativos,\n    // pero podemos usar un hack simple si asumimos offsets fijos o usamos una librer√≠a si est√° disponible.\n    // Por ahora, asumiremos que el servidor corre en UTC y haremos el offset manual\n    // para America/Mexico_City (UTC-6 en invierno, UTC-5 en verano - aunque MX ya no cambia horario en la mayor√≠a)\n    // Asumiremos UTC-6 fijo para CDMX por simplicidad si no hay librer√≠a, \n    // PERO lo ideal es dejar que la base de datos maneje la inserci√≥n si pudi√©ramos pasar \"AT TOP TIME ZONE\".\n    // \n    // Mejor enfoque: Construir la fecha con el offset expl√≠cito.\n    // CDMX es UTC-6.\n\n    const targetTime = new Date(`${date}T${time}:00`)\n    // Asumiendo que targetTime se cre√≥ en UTC (por defecto en Deno Deploy)\n    // Le sumamos 6 horas para \"cancelar\" el hecho de que era local y convertirlo a UTC real\n    // Ejemplo: Usuario quiere 15:00 CDMX.\n    // UTC equivalente: 21:00 UTC.\n    // new Date(\"2026-02-12T15:00:00\") -> crea 15:00 UTC (incorrecto, esto ser√≠a 9:00 AM CDMX)\n    // Queremos enviar 21:00 UTC.\n\n    // Soluci√≥n robusta sin librer√≠as externas pesadas:\n    // Usar el offset manual temporalmente.\n    const offsetHours = 6 // UTC-6 para M√©xico Central (Est√°ndar)\n    const utcDate = new Date(targetTime.getTime() + (offsetHours * 60 * 60 * 1000))\n    const startTime = utcDate.toISOString()\n\n    console.log(`‚è∞ [TOOL] Time conversion:`)\n    console.log(`   Input (Local): ${date} ${time}`)\n    console.log(`   Timezone: ${timezone} (Assuming UTC-6)`)\n    console.log(`   Output (UTC): ${startTime}`)\n\n    const { createAppointment } = await import('./appointment-manager.ts')\n    const { sendMessage } = await import('./evolution.ts')\n\n    // Obtener tel√©fono del contacto\n    const { data: contact } = await supabase\n        .from('contacts')\n        .select('phone_number')\n        .eq('id', contactId)\n        .single()\n\n    if (!contact) {\n        throw new Error('Contact not found')\n    }\n\n    // Crear funci√≥n de env√≠o de mensajes\n    const sendMessageFn = async (remoteJid: string, text: string) => {\n        // Esta funci√≥n ser√° proporcionada por el contexto\n        console.log(`üì§ [TOOL] Would send message to ${remoteJid}`)\n    }\n\n    const result = await createAppointment(\n        supabase,\n        {\n            userId,\n            contactId,\n            serviceId: finalServiceId!, // Non-null assertion: ya verificamos arriba\n            startTime,\n            notes\n        },\n        sendMessageFn,\n        contact.phone_number\n    )\n\n\n    return result\n}\n\n/**\n * Consulta las citas del usuario\n */\nexport async function consultarMisCitas(\n    supabase: SupabaseClient,\n    userId: string,\n    contactId: number\n): Promise<any> {\n    console.log(`üìÖ [TOOL] Fetching appointments for contact ${contactId}`)\n\n    const now = new Date().toISOString()\n\n    const { data: appointments, error } = await supabase\n        .from('meetings')\n        .select(`\n            id,\n            start_time,\n            end_time,\n            status,\n            notes,\n            summary,\n            products:product_id (\n                product_name,\n                service_duration_minutes\n            )\n        `)\n        .eq('user_id', userId)\n        .eq('contact_id', contactId)\n        .gte('start_time', now)  // Solo citas futuras\n        .order('start_time', { ascending: true })\n        .limit(10)\n\n    if (error) {\n        console.error(`‚ùå [TOOL] Error fetching appointments:`, error)\n        return {\n            success: false,\n            error: error.message\n        }\n    }\n\n    if (!appointments || appointments.length === 0) {\n        return {\n            success: true,\n            appointments: [],\n            message: 'No tienes citas programadas'\n        }\n    }\n\n    console.log(`‚úÖ [TOOL] Found ${appointments.length} appointment(s)`)\n\n    return {\n        success: true,\n        appointments: appointments.map(apt => {\n            const date = new Date(apt.start_time)\n            const formattedTime = date.toLocaleString('es-MX', {\n                timeZone: 'America/Mexico_City',\n                weekday: 'long',\n                year: 'numeric',\n                month: 'long',\n                day: 'numeric',\n                hour: '2-digit',\n                minute: '2-digit',\n                hour12: true\n            })\n\n            return {\n                id: apt.id,\n                serviceName: apt.products?.product_name || 'Servicio',\n                startTime: apt.start_time, // Keep ISO for debugging\n                formattedTime: formattedTime, // For LLM to read correct local time\n                endTime: apt.end_time,\n                status: apt.status,\n                notes: apt.notes,\n                isAIBooked: apt.summary === 'Cita Agendada por IA'\n            }\n        })\n    }\n}\n\n/**\n * Modifica/reprograma una cita existente\n */\nexport async function modificarCita(\n    supabase: SupabaseClient,\n    userId: string,\n    contactId: number,\n    appointmentId: number,\n    newDate?: string,\n    newTime?: string\n): Promise<any> {\n    const id = Number(appointmentId)\n    console.log(`üìÖ [TOOL] Modifying appointment #${id}`)\n\n    // Obtener la cita actual\n    const { data: currentAppointment, error: fetchError } = await supabase\n        .from('meetings')\n        .select('*, products:product_id(service_duration_minutes)')\n        .eq('id', id)\n        .eq('user_id', userId)\n        .eq('contact_id', contactId)\n        .single()\n\n    if (fetchError || !currentAppointment) {\n        console.error(`‚ùå [TOOL] Appointment not found:`, fetchError)\n        return {\n            success: false,\n            error: 'No se encontr√≥ la cita'\n        }\n    }\n\n    // Calcular nuevo start_time\n    let newStartTime: string\n    const offsetHours = 6 // UTC-6 para M√©xico\n\n    if (newDate && newTime) {\n        // Ambos proporcionados\n        const targetTime = new Date(`${newDate}T${newTime}:00`)\n        const utcDate = new Date(targetTime.getTime() + (offsetHours * 60 * 60 * 1000))\n        newStartTime = utcDate.toISOString()\n    } else if (newDate) {\n        // Solo fecha nueva, mantener hora original\n        const currentStart = new Date(currentAppointment.start_time)\n        // Adjust back to local to extract time components accurately\n        const localCurrent = new Date(currentStart.getTime() - (offsetHours * 60 * 60 * 1000))\n        const h = localCurrent.getUTCHours().toString().padStart(2, '0')\n        const m = localCurrent.getUTCMinutes().toString().padStart(2, '0')\n\n        const targetTime = new Date(`${newDate}T${h}:${m}:00`)\n        const utcDate = new Date(targetTime.getTime() + (offsetHours * 60 * 60 * 1000))\n        newStartTime = utcDate.toISOString()\n    } else if (newTime) {\n        // Solo hora nueva, mantener fecha original\n        const currentStart = new Date(currentAppointment.start_time)\n        const localCurrent = new Date(currentStart.getTime() - (offsetHours * 60 * 60 * 1000))\n        const y = localCurrent.getUTCFullYear()\n        const mo = (localCurrent.getUTCMonth() + 1).toString().padStart(2, '0')\n        const d = localCurrent.getUTCDate().toString().padStart(2, '0')\n\n        const targetTime = new Date(`${y}-${mo}-${d}T${newTime}:00`)\n        const utcDate = new Date(targetTime.getTime() + (offsetHours * 60 * 60 * 1000))\n        newStartTime = utcDate.toISOString()\n    } else {\n        return {\n            success: false,\n            error: 'Debes proporcionar al menos una nueva fecha o hora'\n        }\n    }\n\n    // Calcular nuevo end_time\n    const durationMinutes = currentAppointment.products?.service_duration_minutes || 60\n    const newEndTime = new Date(new Date(newStartTime).getTime() + durationMinutes * 60 * 1000).toISOString()\n\n    // Actualizar la cita\n    const { data: updatedAppointment, error: updateError } = await supabase\n        .from('meetings')\n        .update({\n            start_time: newStartTime,\n            end_time: newEndTime,\n            notes: currentAppointment.notes ? `${currentAppointment.notes} (Reprogramada)` : 'Reprogramada'\n        })\n        .eq('id', appointmentId)\n        .select()\n        .single()\n\n    if (updateError) {\n        console.error(`‚ùå [TOOL] Error updating appointment:`, updateError)\n        return {\n            success: false,\n            error: updateError.message\n        }\n    }\n\n    console.log(`‚úÖ [TOOL] Appointment #${appointmentId} rescheduled`)\n\n    // Format times for LLM response\n    const formatTime = (isoString: string) => {\n        return new Date(isoString).toLocaleString('es-MX', {\n            timeZone: 'America/Mexico_City',\n            weekday: 'long',\n            year: 'numeric',\n            month: 'long',\n            day: 'numeric',\n            hour: '2-digit',\n            minute: '2-digit',\n            hour12: true\n        })\n    }\n\n    return {\n        success: true,\n        appointmentId: updatedAppointment.id,\n        newStartTime: newStartTime,\n        newEndTime: newEndTime,\n        formattedStartTime: formatTime(newStartTime),\n        formattedEndTime: formatTime(newEndTime)\n    }\n}\n\n/**\n * Consulta promociones activas\n * Si no hay promociones, sugiere productos destacados de manera inteligente\n */\nexport async function consultarPromociones(\n    supabase: SupabaseClient,\n    userId: string\n): Promise<any> {\n    console.log(`üéÅ [TOOL] Consulting active promotions...`)\n\n    try {\n        // 1. Buscar promociones activas\n        const now = new Date().toISOString()\n\n        const { data: promotions, error: promoError } = await supabase\n            .from('smart_promotions')\n            .select('id, title, description, benefits, call_to_action, discount, image_urls')\n            .eq('user_id', userId)\n            .eq('is_active', true)\n            .or(`no_schedule.eq.true,and(start_at.lte.${now},end_at.gte.${now})`)\n            .limit(5)\n\n        if (promoError) {\n            console.error(`‚ùå [TOOL] Error fetching promotions:`, promoError)\n        }\n\n        // 2. Si HAY promociones, devolverlas\n        if (promotions && promotions.length > 0) {\n            console.log(`‚úÖ [TOOL] Found ${promotions.length} active promotion(s)`)\n\n            const formattedPromos = promotions.map((p: any) => ({\n                title: p.title,\n                description: p.description,\n                benefits: p.benefits,\n                callToAction: p.call_to_action,\n                discount: p.discount,\n                imageUrls: p.image_urls\n            }))\n\n            return {\n                hasPromotions: true,\n                promotions: formattedPromos,\n                message: `Tenemos ${promotions.length} promoci√≥n${promotions.length > 1 ? 'es' : ''} activa${promotions.length > 1 ? 's' : ''} en este momento.`\n            }\n        }\n\n        // 3. NO HAY PROMOCIONES - Buscar productos para sugerir\n        console.log(`‚ÑπÔ∏è [TOOL] No active promotions found - fetching featured products...`)\n\n        const productSearch = await buscarProductos(supabase, userId, '', 3) // Buscar 3 productos cualquiera\n\n        // 4. Si hay productos, sugerirlos como alternativa\n        if (productSearch.status === 'SUCCESS' && productSearch.exact_matches && productSearch.exact_matches.length > 0) {\n            console.log(`‚úÖ [TOOL] Suggesting ${productSearch.exact_matches.length} products as alternative`)\n\n            const products = productSearch.exact_matches.slice(0, 3)\n\n            return {\n                hasPromotions: false,\n                promotions: [],\n                hasSuggestedProducts: true,\n                suggestedProducts: products,\n                message: `En este momento no tenemos promociones activas, pero aqu√≠ te muestro algunos de nuestros productos que podr√≠an interesarte:`\n            }\n        }\n\n        // 5. No hay ni promociones ni productos\n        console.log(`‚ö†Ô∏è [TOOL] No promotions or products available`)\n\n        return {\n            hasPromotions: false,\n            promotions: [],\n            hasSuggestedProducts: false,\n            suggestedProducts: [],\n            message: `En este momento no tenemos promociones activas. Si necesitas algo espec√≠fico, con gusto te ayudo a buscarlo.`\n        }\n\n    } catch (error) {\n        console.error(`‚ùå [TOOL] Error in consultarPromociones:`, error)\n        return {\n            hasPromotions: false,\n            promotions: [],\n            error: error instanceof Error ? error.message : 'Error consultando promociones'\n        }\n    }\n}\n"}]