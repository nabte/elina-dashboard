{"name":"utils/appointment-manager.ts","content":"// Appointment Management System for ELINA V5\r\n// Handles appointment scheduling, slot management, and reminders\r\n\r\nimport { SupabaseClient } from 'https://esm.sh/@supabase/supabase-js@2'\r\n\r\nexport interface AppointmentSettings {\r\n    is_enabled: boolean\r\n    buffer_minutes: number\r\n    max_days_ahead: number\r\n    working_hours?: any\r\n}\r\n\r\nexport interface AppointmentSlot {\r\n    start_time: string\r\n    end_time: string\r\n    service_id: number\r\n    service_name: string\r\n    duration_minutes: number\r\n}\r\n\r\nexport interface CreateAppointmentParams {\r\n    userId: string\r\n    contactId: number\r\n    serviceId: number\r\n    startTime: string\r\n    notes?: string\r\n}\r\n\r\nexport interface AppointmentResult {\r\n    success: boolean\r\n    appointmentId?: number\r\n    serviceName?: string\r\n    startTime?: string\r\n    error?: string\r\n}\r\n\r\n/**\r\n * Gets appointment settings for a user\r\n */\r\nexport async function getAppointmentSettings(\r\n    supabase: SupabaseClient,\r\n    userId: string\r\n): Promise<AppointmentSettings | null> {\r\n    try {\r\n        const { data, error } = await supabase\r\n            .from('appointment_settings')\r\n            .select('*')\r\n            .eq('user_id', userId)\r\n            .single()\r\n\r\n        if (error) {\r\n            console.error(`‚ùå [APPOINTMENT] Error fetching settings:`, error)\r\n            return null\r\n        }\r\n\r\n        return data as AppointmentSettings\r\n    } catch (error) {\r\n        console.error(`‚ùå [APPOINTMENT] Error:`, error)\r\n        return null\r\n    }\r\n}\r\n\r\n/**\r\n * Gets available appointment slots\r\n */\r\nexport async function getAvailableSlots(\r\n    userId: string,\r\n    daysAhead: number = 7\r\n): Promise<AppointmentSlot[]> {\r\n    try {\r\n        console.log(`üìÖ [APPOINTMENT] Fetching slots for next ${daysAhead} days...`)\r\n        const allSlots: AppointmentSlot[] = []\r\n        const slotsUrl = `${Deno.env.get('SUPABASE_URL')}/functions/v1/get-available-slots`\r\n        const anonKey = Deno.env.get('SUPABASE_ANON_KEY')\r\n\r\n        // Generate dates for the next N days\r\n        const dates: string[] = []\r\n        const today = new Date()\r\n\r\n        for (let i = 0; i < daysAhead; i++) {\r\n            const date = new Date(today)\r\n            date.setDate(today.getDate() + i)\r\n            dates.push(date.toISOString().split('T')[0])\r\n        }\r\n\r\n        // Fetch slots for each date in parallel (limited for performance)\r\n        const fetchPromises = dates.map(async (date) => {\r\n            try {\r\n                const response = await fetch(slotsUrl, {\r\n                    method: 'POST',\r\n                    headers: {\r\n                        'Authorization': `Bearer ${anonKey}`,\r\n                        'Content-Type': 'application/json'\r\n                    },\r\n                    body: JSON.stringify({\r\n                        user_id: userId,\r\n                        date: date\r\n                    })\r\n                })\r\n\r\n                if (!response.ok) {\r\n                    console.warn(`‚ö†Ô∏è [APPOINTMENT] Failed to fetch slots for ${date}: ${response.status}`)\r\n                    return []\r\n                }\r\n\r\n                const data = await response.json()\r\n\r\n                if (data.available_slots && Array.isArray(data.available_slots)) {\r\n                    // Map response format to AppointmentSlot format\r\n                    return data.available_slots.map((s: any) => ({\r\n                        start_time: `${date}T${s.start}:00`, // Ensure valid ISO format if strictly time\r\n                        end_time: `${date}T${s.end}:00`,\r\n                        service_id: 0, // Default or generic\r\n                        service_name: 'Cita General', // Default\r\n                        duration_minutes: s.duration_minutes || 60\r\n                    }))\r\n                }\r\n\r\n                return []\r\n            } catch (err) {\r\n                console.error(`‚ùå [APPOINTMENT] Error fetching date ${date}:`, err)\r\n                return []\r\n            }\r\n        })\r\n\r\n        const results = await Promise.all(fetchPromises)\r\n\r\n        // Flatten results\r\n        results.forEach(slots => {\r\n            allSlots.push(...slots)\r\n        })\r\n\r\n        return allSlots\r\n\r\n    } catch (error) {\r\n        console.error(`‚ùå [APPOINTMENT] Error fetching slots:`, error)\r\n        return []\r\n    }\r\n}\r\n\r\n/**\r\n * Formats appointment slots for AI context\r\n */\r\n/**\r\n * Formats appointment slots for AI context\r\n */\r\nexport function formatAppointmentContext(slots: AppointmentSlot[], slug?: string): string {\r\n    if (!slots || slots.length === 0) {\r\n        let noSlotsMsg = '[CITAS] No hay horarios disponibles en los pr√≥ximos d√≠as.'\r\n        if (slug) {\r\n            noSlotsMsg += `\\nPuedes revisar disponibilidad completa aqu√≠: [APPOINTMENT_CALENDAR_LINK]`\r\n        }\r\n        return noSlotsMsg\r\n    }\r\n\r\n    let context = 'üìÖ [HORARIOS DISPONIBLES PARA CITAS]\\n\\n'\r\n\r\n    // Agrupar por d√≠a\r\n    const slotsByDay: Record<string, AppointmentSlot[]> = {}\r\n\r\n    for (const slot of slots) {\r\n        const date = new Date(slot.start_time)\r\n        const dayKey = date.toLocaleDateString('es-MX', {\r\n            weekday: 'long',\r\n            day: 'numeric',\r\n            month: 'long'\r\n        })\r\n\r\n        // Capitalizar primer letra\r\n        const formattedDayKey = dayKey.charAt(0).toUpperCase() + dayKey.slice(1)\r\n\r\n        if (!slotsByDay[formattedDayKey]) {\r\n            slotsByDay[formattedDayKey] = []\r\n        }\r\n        slotsByDay[formattedDayKey].push(slot)\r\n    }\r\n\r\n    // Formatear por d√≠a con rangos\r\n    const dayEntries = Object.entries(slotsByDay)\r\n    // Limitar a los primeros 3 d√≠as para no saturar contexto\r\n    const daysToShow = dayEntries.slice(0, 3)\r\n\r\n    for (const [day, daySlots] of daysToShow) {\r\n        context += `üìÜ ${day}:\\n`\r\n\r\n        // Ordenar slots por hora\r\n        daySlots.sort((a, b) => new Date(a.start_time).getTime() - new Date(b.start_time).getTime())\r\n\r\n        if (daySlots.length === 0) continue\r\n\r\n        // Encontrar primer y √∫ltimo slot del d√≠a\r\n        const firstSlot = daySlots[0]\r\n        const lastSlot = daySlots[daySlots.length - 1]\r\n\r\n        const startTime = new Date(firstSlot.start_time).toLocaleTimeString('es-MX', {\r\n            hour: '2-digit', minute: '2-digit', hour12: true\r\n        })\r\n\r\n        const endTime = new Date(lastSlot.start_time).toLocaleTimeString('es-MX', {\r\n            hour: '2-digit', minute: '2-digit', hour12: true\r\n        })\r\n\r\n        if (daySlots.length === 1) {\r\n            context += `   ‚Ä¢ A las ${startTime}\\n`\r\n        } else {\r\n            context += `   ‚Ä¢ Entre las ${startTime} y las ${endTime}\\n`\r\n        }\r\n\r\n        context += '\\n'\r\n    }\r\n\r\n    if (slug) {\r\n        context += `üîó Puedes ver el calendario completo y agendar aqu√≠:\\n[APPOINTMENT_CALENDAR_LINK]\\n\\n`\r\n    }\r\n\r\n    context += 'üìå INSTRUCCI√ìN IMPORTANTE:\\n'\r\n    context += 'Ofrece los horarios como RANGOS (ej: \"tengo espacio entre las 10 y las 12\").\\n'\r\n    context += 'Si el usuario pide una hora espec√≠fica dentro del rango, verifica si est√° disponible o agenda al horario m√°s cercano.\\n'\r\n    context += 'SIEMPRE incluye el enlace al calendario completo al final.\\n'\r\n\r\n    return context\r\n}\r\n\r\n/**\r\n * Creates an appointment and automatic reminders\r\n */\r\nexport async function createAppointment(\r\n    supabase: SupabaseClient,\r\n    params: CreateAppointmentParams,\r\n    sendMessage: (remoteJid: string, text: string) => Promise<void>,\r\n    contactPhone: string\r\n): Promise<AppointmentResult> {\r\n    try {\r\n        console.log(`\\nüìÖ [APPOINTMENT] Creating appointment...`)\r\n        console.log(`   User: ${params.userId}`)\r\n        console.log(`   Contact: ${params.contactId}`)\r\n        console.log(`   Service: ${params.serviceId}`)\r\n        console.log(`   Time: ${params.startTime}`)\r\n\r\n        // ========================================================================\r\n        // 1. GET SERVICE INFO (duration + name)\r\n        // ========================================================================\r\n        const { data: serviceData } = await supabase\r\n            .from('products')\r\n            .select('service_duration_minutes, product_name')\r\n            .eq('id', params.serviceId)\r\n            .single()\r\n\r\n        const durationMinutes = serviceData?.service_duration_minutes || 60 // Default 60 min\r\n        const serviceName = serviceData?.product_name || 'Servicio'\r\n\r\n        // Calculate end_time\r\n        const startTime = new Date(params.startTime)\r\n        const endTime = new Date(startTime.getTime() + durationMinutes * 60 * 1000)\r\n\r\n        console.log(`‚è±Ô∏è [APPOINTMENT] Service: ${serviceName}`)\r\n        console.log(`   Duration: ${durationMinutes} minutes`)\r\n        console.log(`   Start: ${params.startTime}`)\r\n        console.log(`   End: ${endTime.toISOString()}`)\r\n\r\n        // ========================================================================\r\n        // 2. CREATE APPOINTMENT (with AI metadata)\r\n        // ========================================================================\r\n        const { data: appointment, error: createError } = await supabase\r\n            .from('meetings')\r\n            .insert({\r\n                user_id: params.userId,\r\n                contact_id: params.contactId,\r\n                product_id: params.serviceId,\r\n                start_time: params.startTime,\r\n                end_time: endTime.toISOString(),\r\n                status: 'confirmed',\r\n                summary: 'Cita Agendada por IA',  // AI marker\r\n                notes: params.notes ? `${params.notes} (Agendado autom√°ticamente: ${serviceName})` : `Agendado autom√°ticamente: ${serviceName}`,\r\n                confirmation_status: 'confirmed'\r\n            })\r\n            .select()\r\n            .single()\r\n\r\n        if (createError) {\r\n            console.error(`‚ùå [APPOINTMENT] Creation failed:`, createError)\r\n            throw createError\r\n        }\r\n\r\n        console.log(`‚úÖ [APPOINTMENT] Created appointment #${appointment.id}`)\r\n\r\n        // ========================================================================\r\n        // 2. CREATE AUTOMATIC REMINDERS\r\n        // ========================================================================\r\n        const appointmentTime = new Date(params.startTime)\r\n        const now = new Date()\r\n\r\n        // Recordatorio 24h antes (solo si la cita es en m√°s de 24h)\r\n        const twentyFourHoursBefore = new Date(appointmentTime.getTime() - 24 * 60 * 60 * 1000)\r\n        if (twentyFourHoursBefore > now) {\r\n            await supabase.from('appointment_reminders').insert({\r\n                meeting_id: appointment.id,\r\n                reminder_time: twentyFourHoursBefore.toISOString(),\r\n                reminder_type: '24h_before',\r\n                status: 'pending'\r\n            })\r\n            console.log(`‚úÖ [APPOINTMENT] 24h reminder scheduled`)\r\n        }\r\n\r\n        // Recordatorio 2h antes (solo si la cita es en m√°s de 2h)\r\n        const twoHoursBefore = new Date(appointmentTime.getTime() - 2 * 60 * 60 * 1000)\r\n        if (twoHoursBefore > now) {\r\n            await supabase.from('appointment_reminders').insert({\r\n                meeting_id: appointment.id,\r\n                reminder_time: twoHoursBefore.toISOString(),\r\n                reminder_type: '2h_before',\r\n                status: 'pending'\r\n            })\r\n            console.log(`‚úÖ [APPOINTMENT] 2h reminder scheduled`)\r\n        }\r\n\r\n        // ========================================================================\r\n        // 3. SEND CONFIRMATION TO CUSTOMER\r\n        // ========================================================================\r\n        const confirmationMsg =\r\n            `‚úÖ *Cita Confirmada*\\n\\n` +\r\n            `üìÖ Fecha: ${appointmentTime.toLocaleDateString('es-MX', { weekday: 'long', day: 'numeric', month: 'long', year: 'numeric' })}\\n` +\r\n            `üïê Hora: ${appointmentTime.toLocaleTimeString('es-MX', { hour: '2-digit', minute: '2-digit', hour12: true })}\\n` +\r\n            `üîπ Servicio: ${serviceName}\\n` +\r\n            `‚è±Ô∏è Duraci√≥n: ${durationMinutes} minutos\\n\\n` +\r\n            `Recibir√°s recordatorios antes de tu cita.\\n` +\r\n            `ID de cita: #${appointment.id}`\r\n\r\n        await sendMessage(contactPhone + '@s.whatsapp.net', confirmationMsg)\r\n        console.log(`‚úÖ [APPOINTMENT] Confirmation sent to customer`)\r\n\r\n        // ========================================================================\r\n        // 4. NOTIFY OWNER (OPTIONAL)\r\n        // ========================================================================\r\n        const { data: profile } = await supabase\r\n            .from('profiles')\r\n            .select('contact_phone')\r\n            .eq('id', params.userId)\r\n            .single()\r\n\r\n        if (profile?.contact_phone) {\r\n            const { data: contact } = await supabase\r\n                .from('contacts')\r\n                .select('full_name, phone_number')\r\n                .eq('id', params.contactId)\r\n                .single()\r\n\r\n            const ownerNotification =\r\n                `üìÖ *Nueva Cita Agendada*\\n\\n` +\r\n                `Cliente: ${contact?.full_name || contact?.phone_number}\\n` +\r\n                `Servicio: ${serviceName}\\n` +\r\n                `Fecha: ${appointmentTime.toLocaleDateString('es-MX', { day: 'numeric', month: 'long' })}\\n` +\r\n                `Hora: ${appointmentTime.toLocaleTimeString('es-MX', { hour: '2-digit', minute: '2-digit' })}\\n` +\r\n                `ID: #${appointment.id}`\r\n\r\n            await sendMessage(profile.contact_phone + '@s.whatsapp.net', ownerNotification)\r\n            console.log(`‚úÖ [APPOINTMENT] Owner notified`)\r\n        }\r\n\r\n        return {\r\n            success: true,\r\n            appointmentId: appointment.id,\r\n            serviceName: serviceName,  // Use the serviceName we fetched earlier\r\n            startTime: params.startTime\r\n        }\r\n\r\n    } catch (error) {\r\n        console.error(`‚ùå [APPOINTMENT] Error creating appointment:`, error)\r\n        return {\r\n            success: false,\r\n            error: error instanceof Error ? error.message : 'Unknown error'\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Detects if the message contains an appointment request\r\n */\r\nexport function detectAppointmentIntent(text: string, context?: any): boolean {\r\n    const lowerText = text.toLowerCase().trim()\r\n\r\n    // 1. Palabras clave expl√≠citas de cita\r\n    const appointmentKeywords = /(?:cita|agendar|reservar|horario|turno|disponibilidad|agenda|appointment|schedule|book)/i\r\n    if (appointmentKeywords.test(lowerText)) return true\r\n\r\n    // 2. Si ya estamos hablando de citas (contexto activo), palabras de confirmaci√≥n o fechas cuentan como intent\r\n    if (context?.appointmentContext || context?.lastIntent === 'appointment_request') {\r\n        const confirmationKeywords = /^(si|ok|va|dale|acepto|confirmo|claro|por favor|hazlo|que si|seguro)$/i\r\n        const timeKeywords = /(ma√±ana|hoy|lunes|martes|miercoles|jueves|viernes|sabado|domingo|enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|alas|a las)/i\r\n\r\n        if (confirmationKeywords.test(lowerText) || timeKeywords.test(lowerText)) {\r\n            return true\r\n        }\r\n\r\n        // Si menciona un servicio y estamos en contexto de cita\r\n        if (text.length < 50 && (lowerText.includes('corte') || lowerText.includes('color') || lowerText.includes('peinado'))) {\r\n            return true\r\n        }\r\n    }\r\n\r\n    return false\r\n}\r\n"}