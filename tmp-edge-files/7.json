{"name":"memory/long-term.ts","content":"/**\r\n * ELINA V5 - Long-term Memory System\r\n * \r\n * Sistema de aprendizaje de largo plazo por cuenta\r\n */\r\n\r\nimport type { SupabaseClient } from 'https://esm.sh/@supabase/supabase-js@2'\r\nimport type { AccountLearning } from '../config/types.ts'\r\nimport { LEARNING_CONFIDENCE_THRESHOLD, RAG_MAX_RESULTS } from '../config/constants.ts'\r\n\r\n/**\r\n * Genera embedding para un texto usando OpenAI\r\n */\r\nasync function generateEmbedding(text: string): Promise<number[]> {\r\n    const openaiKey = Deno.env.get('OPENAI_API_KEY')\r\n    if (!openaiKey) {\r\n        throw new Error('OPENAI_API_KEY not found')\r\n    }\r\n\r\n    const response = await fetch('https://api.openai.com/v1/embeddings', {\r\n        method: 'POST',\r\n        headers: {\r\n            'Authorization': `Bearer ${openaiKey}`,\r\n            'Content-Type': 'application/json'\r\n        },\r\n        body: JSON.stringify({\r\n            model: 'text-embedding-3-small',\r\n            input: text\r\n        })\r\n    })\r\n\r\n    if (!response.ok) {\r\n        throw new Error(`OpenAI API error: ${response.statusText}`)\r\n    }\r\n\r\n    const data = await response.json()\r\n    return data.data[0].embedding\r\n}\r\n\r\n/**\r\n * Obtiene aprendizajes relevantes basados en el mensaje actual\r\n */\r\nexport async function getRelevantLearnings(\r\n    supabase: SupabaseClient,\r\n    userId: string,\r\n    currentMessage: string,\r\n    limit: number = RAG_MAX_RESULTS\r\n): Promise<AccountLearning[]> {\r\n    console.log(`üß† [MEMORY] Fetching relevant learnings for user ${userId}`)\r\n\r\n    try {\r\n        // 1. Generar embedding del mensaje actual\r\n        const embedding = await generateEmbedding(currentMessage)\r\n\r\n        // 2. Buscar aprendizajes similares\r\n        const { data, error } = await supabase.rpc('match_account_learnings', {\r\n            query_embedding: embedding,\r\n            match_threshold: LEARNING_CONFIDENCE_THRESHOLD,\r\n            match_count: limit,\r\n            filter_user_id: userId\r\n        })\r\n\r\n        if (error) {\r\n            console.error(`‚ùå [MEMORY] Error fetching learnings: ${error.message}`)\r\n            return []\r\n        }\r\n\r\n        const learnings = (data || []) as AccountLearning[]\r\n        console.log(`‚úÖ [MEMORY] Found ${learnings.length} relevant learnings`)\r\n\r\n        // 3. Actualizar usage_count y last_used\r\n        if (learnings.length > 0) {\r\n            await Promise.all(\r\n                learnings.map(learning =>\r\n                    supabase\r\n                        .from('account_learnings')\r\n                        .update({\r\n                            usage_count: (learning.usageCount || 0) + 1,\r\n                            last_used: new Date().toISOString()\r\n                        })\r\n                        .eq('id', learning.id)\r\n                )\r\n            )\r\n        }\r\n\r\n        return learnings\r\n    } catch (error) {\r\n        console.error(`‚ùå [MEMORY] Error in getRelevantLearnings: ${error.message}`)\r\n        return []\r\n    }\r\n}\r\n\r\n/**\r\n * Guarda un nuevo aprendizaje\r\n */\r\nexport async function saveLearning(\r\n    supabase: SupabaseClient,\r\n    userId: string,\r\n    learningType: 'pattern' | 'objection' | 'product_insight' | 'best_practice',\r\n    content: string,\r\n    confidence: number = 0.5\r\n): Promise<void> {\r\n    console.log(`üíæ [MEMORY] Saving new learning: ${learningType}`)\r\n\r\n    try {\r\n        // 1. Generar embedding\r\n        const embedding = await generateEmbedding(content)\r\n\r\n        // 2. Guardar en base de datos\r\n        const { error } = await supabase.from('account_learnings').insert({\r\n            user_id: userId,\r\n            learning_type: learningType,\r\n            content,\r\n            confidence,\r\n            embedding,\r\n            usage_count: 0,\r\n            created_at: new Date().toISOString(),\r\n            updated_at: new Date().toISOString()\r\n        })\r\n\r\n        if (error) {\r\n            console.error(`‚ùå [MEMORY] Error saving learning: ${error.message}`)\r\n            throw error\r\n        }\r\n\r\n        console.log(`‚úÖ [MEMORY] Learning saved successfully`)\r\n    } catch (error) {\r\n        console.error(`‚ùå [MEMORY] Error in saveLearning: ${error.message}`)\r\n        throw error\r\n    }\r\n}\r\n\r\n/**\r\n * Actualiza la confianza de un aprendizaje\r\n */\r\nexport async function updateLearningConfidence(\r\n    supabase: SupabaseClient,\r\n    learningId: string,\r\n    newConfidence: number\r\n): Promise<void> {\r\n    const { error } = await supabase\r\n        .from('account_learnings')\r\n        .update({\r\n            confidence: Math.max(0, Math.min(1, newConfidence)), // Clamp between 0 and 1\r\n            updated_at: new Date().toISOString()\r\n        })\r\n        .eq('id', learningId)\r\n\r\n    if (error) {\r\n        console.error(`‚ùå [MEMORY] Error updating learning confidence: ${error.message}`)\r\n        throw error\r\n    }\r\n}\r\n\r\n/**\r\n * Elimina aprendizajes con baja confianza y poco uso\r\n */\r\nexport async function cleanupOldLearnings(\r\n    supabase: SupabaseClient,\r\n    userId: string,\r\n    minConfidence: number = 0.3,\r\n    minUsageCount: number = 1,\r\n    daysOld: number = 90\r\n): Promise<number> {\r\n    console.log(`üßπ [MEMORY] Cleaning up old learnings for user ${userId}`)\r\n\r\n    const cutoffDate = new Date()\r\n    cutoffDate.setDate(cutoffDate.getDate() - daysOld)\r\n\r\n    const { data, error } = await supabase\r\n        .from('account_learnings')\r\n        .delete()\r\n        .eq('user_id', userId)\r\n        .lt('confidence', minConfidence)\r\n        .lt('usage_count', minUsageCount)\r\n        .lt('created_at', cutoffDate.toISOString())\r\n        .select('id')\r\n\r\n    if (error) {\r\n        console.error(`‚ùå [MEMORY] Error cleaning up learnings: ${error.message}`)\r\n        return 0\r\n    }\r\n\r\n    const deletedCount = data?.length || 0\r\n    console.log(`‚úÖ [MEMORY] Cleaned up ${deletedCount} old learnings`)\r\n\r\n    return deletedCount\r\n}\r\n\r\n/**\r\n * Formatea aprendizajes para incluir en el prompt\r\n */\r\nexport function formatLearningsForPrompt(learnings: AccountLearning[]): string {\r\n    if (learnings.length === 0) {\r\n        return ''\r\n    }\r\n\r\n    let formatted = '## Aprendizajes Previos\\n'\r\n    formatted += 'Estos son patrones y mejores pr√°cticas que has aprendido con el tiempo:\\n\\n'\r\n\r\n    for (const learning of learnings) {\r\n        const emoji = {\r\n            pattern: 'üîÑ',\r\n            objection: 'üõ°Ô∏è',\r\n            product_insight: 'üí°',\r\n            best_practice: '‚≠ê'\r\n        }[learning.learningType] || 'üìù'\r\n\r\n        formatted += `${emoji} **${learning.learningType}**: ${learning.content}\\n`\r\n    }\r\n\r\n    return formatted\r\n}\r\n"}