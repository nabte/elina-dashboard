{"name":"utils/message-buffer.ts","content":"/**\r\n * ELINA V5 - Message Buffer (Supabase Table)\r\n *\r\n * Agrupa m√∫ltiples mensajes consecutivos del mismo usuario en una sola respuesta.\r\n * Usa tabla message_buffer en Supabase para coordinar entre requests independientes.\r\n *\r\n * Flujo:\r\n * 1. Llega mensaje ‚Üí INSERT en message_buffer\r\n * 2. Esperar BUFFER_WINDOW_MS\r\n * 3. Consultar si mi mensaje es el m√°s reciente para este contacto\r\n *    - S√≠ ‚Üí Tomar todos, DELETE, devolver texto combinado\r\n *    - No ‚Üí Otro mensaje lleg√≥ despu√©s, retornar shouldProcess: false\r\n */\r\n\r\nconst BUFFER_WINDOW_MS = 4000 // 4 segundos para agrupar mensajes\r\n\r\nfunction sleep(ms: number): Promise<void> {\r\n    return new Promise(resolve => setTimeout(resolve, ms))\r\n}\r\n\r\n/**\r\n * Agrega un mensaje al buffer y decide si procesar o esperar\r\n */\r\nexport async function bufferMessage(\r\n    supabase: any,\r\n    accountId: string,\r\n    contactId: number,\r\n    messageText: string\r\n): Promise<{ shouldProcess: boolean; combinedText: string }> {\r\n\r\n    // 1. Insertar mensaje en el buffer\r\n    const { data: inserted, error: insertError } = await supabase\r\n        .from('message_buffer')\r\n        .insert({\r\n            account_id: accountId,\r\n            contact_id: contactId,\r\n            message_text: messageText\r\n        })\r\n        .select('id, created_at')\r\n        .single()\r\n\r\n    if (insertError || !inserted) {\r\n        console.error('‚ùå [BUFFER] Error inserting into buffer:', insertError)\r\n        // Fallback: procesar el mensaje solo sin buffering\r\n        return { shouldProcess: true, combinedText: messageText }\r\n    }\r\n\r\n    const myId = inserted.id\r\n    console.log(`üì• [BUFFER] Message buffered (id: ${myId}), waiting ${BUFFER_WINDOW_MS}ms...`)\r\n\r\n    // 2. Esperar la ventana de buffer\r\n    await sleep(BUFFER_WINDOW_MS)\r\n\r\n    // 3. Verificar si llegaron mensajes m√°s recientes para este contacto\r\n    const { data: latest, error: latestError } = await supabase\r\n        .from('message_buffer')\r\n        .select('id')\r\n        .eq('account_id', accountId)\r\n        .eq('contact_id', contactId)\r\n        .order('id', { ascending: false })\r\n        .limit(1)\r\n        .single()\r\n\r\n    if (latestError || !latest) {\r\n        // Buffer fue limpiado por otro request, no procesar\r\n        console.log(`‚è≠Ô∏è [BUFFER] Buffer already consumed by another request`)\r\n        return { shouldProcess: false, combinedText: '' }\r\n    }\r\n\r\n    // Si mi mensaje NO es el m√°s reciente, otro lleg√≥ despu√©s ‚Üí no procesar\r\n    if (latest.id !== myId) {\r\n        console.log(`‚è≠Ô∏è [BUFFER] Newer message exists (my: ${myId}, latest: ${latest.id}), skipping`)\r\n        return { shouldProcess: false, combinedText: '' }\r\n    }\r\n\r\n    // 4. Soy el m√°s reciente ‚Üí tomar todos los mensajes y procesarlos\r\n    const { data: allMessages, error: fetchError } = await supabase\r\n        .from('message_buffer')\r\n        .select('id, message_text, created_at')\r\n        .eq('account_id', accountId)\r\n        .eq('contact_id', contactId)\r\n        .order('created_at', { ascending: true })\r\n\r\n    if (fetchError || !allMessages || allMessages.length === 0) {\r\n        console.error('‚ùå [BUFFER] Error fetching buffered messages:', fetchError)\r\n        return { shouldProcess: true, combinedText: messageText }\r\n    }\r\n\r\n    // 5. Combinar todos los mensajes\r\n    const combinedText = allMessages\r\n        .map((m: any) => m.message_text)\r\n        .join('\\n')\r\n\r\n    // 6. Limpiar el buffer para este contacto\r\n    const ids = allMessages.map((m: any) => m.id)\r\n    const { error: deleteError } = await supabase\r\n        .from('message_buffer')\r\n        .delete()\r\n        .in('id', ids)\r\n\r\n    if (deleteError) {\r\n        console.error('‚ö†Ô∏è [BUFFER] Error cleaning buffer (non-critical):', deleteError)\r\n    }\r\n\r\n    console.log(`‚úÖ [BUFFER] Combined ${allMessages.length} messages into one`)\r\n    return { shouldProcess: true, combinedText }\r\n}\r\n\r\n/**\r\n * Limpia mensajes viejos del buffer (seguridad, llamar peri√≥dicamente)\r\n */\r\nexport async function cleanOldBuffers(supabase: any): Promise<number> {\r\n    const cutoff = new Date(Date.now() - 60000).toISOString() // 60 segundos\r\n    const { data, error } = await supabase\r\n        .from('message_buffer')\r\n        .delete()\r\n        .lt('created_at', cutoff)\r\n        .select('id')\r\n\r\n    if (error) {\r\n        console.error('‚ö†Ô∏è [BUFFER] Error cleaning old buffers:', error)\r\n        return 0\r\n    }\r\n    return data?.length || 0\r\n}\r\n"}