{"name":"utils/text-formatter.ts","content":"/**\r\n * ELINA V5 - Text Formatter\r\n * \r\n * Formatea texto para WhatsApp con estructura clara y saltos de l√≠nea apropiados\r\n */\r\n\r\n/**\r\n * Formatea texto para que sea m√°s legible en WhatsApp\r\n * - Asegura saltos de l√≠nea apropiados\r\n * - Estructura listas y p√°rrafos\r\n * - Limpia espacios excesivos\r\n */\r\nexport function formatTextForWhatsApp(text: string): string {\r\n    if (!text) return ''\r\n\r\n    let formatted = text\r\n        // Limpiar markdown residual\r\n        .replace(/\\*\\*([^*]+)\\*\\*/g, '*$1*') // ** a *\r\n        .replace(/\\[([^\\]]+)\\]\\([^)]+\\)/g, '$1') // Links [text](url) a text\r\n\r\n        // Asegurar espacio despu√©s de puntos seguidos de letra\r\n        .replace(/\\.([A-Z√Å√â√ç√ì√ö√ë])/g, '. $1')\r\n\r\n        // üé® NUEVO: Asegurar salto de l√≠nea antes de emojis de vi√±eta (üîπ, üî∏, ‚ú®, etc.)\r\n        .replace(/([^\\n])\\s*(üîπ|üî∏|‚ú®|üì¶|üíé|‚≠ê|üéØ|üî•|üí°|üìç|üí∞|üèÜ|üéÅ|‚ö°)/g, '$1\\n$2')\r\n\r\n        // üé® NUEVO: Asegurar salto de l√≠nea despu√©s de precio (formato $XXX.XX o $XXX)\r\n        .replace(/(\\$[\\d,]+\\.?\\d*)\\s+(?=[üîπüî∏‚ú®üì¶üíé‚≠êüéØüî•üí°üìçüí∞üèÜüéÅ‚ö°¬ø?A-Z])/g, '$1\\n')\r\n\r\n        // Asegurar salto de l√≠nea despu√©s de dos puntos si sigue lista\r\n        .replace(/:(\\s*)-/g, ':\\n-')\r\n        .replace(/:(\\s*)\\d+\\./g, ':\\n$1$2.')\r\n\r\n        // Asegurar salto antes de vi√±etas si no lo hay\r\n        .replace(/([^\\n])\\n?-\\s/g, '$1\\n- ')\r\n        .replace(/([^\\n])\\n?‚Ä¢\\s/g, '$1\\n‚Ä¢ ')\r\n\r\n        // Asegurar salto antes de n√∫meros de lista\r\n        .replace(/([^\\n])\\n?(\\d+)\\.\\s/g, '$1\\n$2. ')\r\n\r\n        // üé® NUEVO: Asegurar salto antes de preguntas (¬ø...?)\r\n        .replace(/([^\\n])\\s*(¬ø[^?]+\\?)/g, '$1\\n$2')\r\n\r\n        // Limpiar espacios m√∫ltiples\r\n        .replace(/[ \\t]{2,}/g, ' ')\r\n\r\n        // Normalizar saltos de l√≠nea (m√°ximo 2 seguidos)\r\n        .replace(/\\n{3,}/g, '\\n\\n')\r\n\r\n        // Limpiar espacios al inicio/fin de l√≠neas\r\n        .split('\\n')\r\n        .map(line => line.trim())\r\n        .join('\\n')\r\n\r\n        .trim()\r\n\r\n    return formatted\r\n}\r\n\r\n/**\r\n * Distribuye texto entre m√∫ltiples items de media (como n8n)\r\n * Retorna array de objetos con media_url y caption\r\n */\r\nexport interface MediaWithCaption {\r\n    type: 'image' | 'video'\r\n    url: string\r\n    caption: string\r\n}\r\n\r\nexport function distributeTextAcrossMedia(\r\n    fullText: string,\r\n    mediaUrls: Array<{ type: 'image' | 'video', url: string }>,\r\n    maxMedia: number = 3\r\n): MediaWithCaption[] {\r\n    if (mediaUrls.length === 0) {\r\n        return []\r\n    }\r\n\r\n    // ============================================================================\r\n    // EXACT n8n V4 LOGIC: Extract URLs from text with regex, not from list\r\n    // ============================================================================\r\n\r\n    // 1. Find ALL URLs in the text using regex (like n8n V4)\r\n    const mediaRegex = /https?:\\/\\/[^\\s\"'<>]+\\.(?:png|jpg|jpeg|gif|webp|mp4)/gi\r\n    const matches = [...fullText.matchAll(mediaRegex)]\r\n\r\n    // If no URLs found in text, return empty\r\n    if (matches.length === 0) {\r\n        return []\r\n    }\r\n\r\n    // 2. Limit to max 3 media\r\n    const maxMediaCount = Math.min(matches.length, maxMedia)\r\n    const results: MediaWithCaption[] = []\r\n    let lastIndex = 0\r\n\r\n    // 3. For each URL found in text:\r\n    for (let i = 0; i < maxMediaCount; i++) {\r\n        const match = matches[i]\r\n        const url = match[0]\r\n        const isVideo = url.toLowerCase().endsWith('.mp4')\r\n\r\n        // Get text BEFORE this URL\r\n        let textBefore = fullText.substring(lastIndex, match.index)\r\n            .replace(/Imagen:\\s*$/i, \"\")  // Remove \"Imagen:\" label\r\n            .replace(/Video:\\s*$/i, \"\")   // Remove \"Video:\" label\r\n            .trim()\r\n\r\n        // CRITICAL: If this is the LAST media we're sending (e.g., 3rd)\r\n        if (i === maxMediaCount - 1) {\r\n            // Get ALL remaining text after this URL\r\n            let restOfText = fullText.substring(match.index + url.length)\r\n\r\n            // CLEAN IT: Remove any remaining URLs and labels\r\n            restOfText = restOfText\r\n                .replace(mediaRegex, \"\")           // Remove all URLs\r\n                .replace(/Imagen:\\s*/gi, \"\")       // Remove \"Imagen:\" labels\r\n                .replace(/Video:\\s*/gi, \"\")        // Remove \"Video:\" labels\r\n                .replace(/\\n{3,}/g, \"\\n\\n\")        // Clean extra newlines\r\n                .trim()\r\n\r\n            // APPEND remaining text to this caption\r\n            if (restOfText) {\r\n                textBefore = (textBefore + \"\\n\\n\" + restOfText).trim()\r\n            }\r\n        }\r\n\r\n        results.push({\r\n            type: isVideo ? 'video' : 'image',\r\n            url: url,\r\n            caption: formatTextForWhatsApp(textBefore)\r\n        })\r\n\r\n        lastIndex = match.index + url.length\r\n    }\r\n\r\n    return results\r\n}\r\n\r\n/**\r\n * EXACT n8n V4 CODE: \"IMG - Split a 3 env√≠os\"\r\n * Splits text with media URLs into multiple messages (max 3)\r\n * Each message has a media_url and its corresponding caption\r\n */\r\nexport interface MediaMessage {\r\n    type: 'image' | 'video' | 'text'\r\n    media_url: string\r\n    url_imagen?: string\r\n    caption: string\r\n    'mensaje texto '?: string\r\n}\r\n\r\nexport function splitMediaIntoMessages(\r\n    textoCompleto: string,\r\n    mediaType: 'image' | 'video' = 'image'\r\n): MediaMessage[] {\r\n    // REGEX EXACTO de n8n V4\r\n    const mediaRegex = /https?:\\/\\/[^\\s\"'<>]+\\.(?:png|jpg|jpeg|gif|webp|mp4)/gi\r\n    const matches = [...textoCompleto.matchAll(mediaRegex)]\r\n\r\n    // Si no hay multimedia, enviamos el texto tal cual\r\n    if (matches.length === 0) {\r\n        return [{\r\n            type: 'text',\r\n            media_url: '',\r\n            caption: textoCompleto,\r\n            'mensaje texto ': textoCompleto\r\n        }]\r\n    }\r\n\r\n    const results: MediaMessage[] = []\r\n    let lastIndex = 0\r\n    const maxMedia = Math.min(matches.length, 3)\r\n\r\n    for (let i = 0; i < maxMedia; i++) {\r\n        const match = matches[i]\r\n        const url = match[0]\r\n        const isVideo = url.toLowerCase().endsWith('.mp4')\r\n\r\n        // Extraemos el texto previo a la imagen actual y limpiamos etiquetas\r\n        let textBefore = textoCompleto.substring(lastIndex, match.index)\r\n            .replace(/Imagen:\\s*$/i, \"\") // Quitar \"Imagen:\" si est√° justo antes\r\n            .trim()\r\n\r\n        // Si es la √∫ltima imagen que vamos a mandar (ej. la 3¬™)\r\n        if (i === maxMedia - 1) {\r\n            // Tomamos el resto del mensaje que queda despu√©s de esta URL\r\n            let restOfText = textoCompleto.substring(match.index + url.length)\r\n\r\n            // LIMPIEZA CR√çTICA: Borramos CUALQUIER otra URL de imagen/video que haya sobrado\r\n            // Tambi√©n limpiamos las palabras \"Imagen:\" residuales que queden solas\r\n            restOfText = restOfText\r\n                .replace(mediaRegex, \"\")\r\n                .replace(/Imagen:\\s*/gi, \"\")\r\n                .replace(/\\n{3,}/g, \"\\n\\n\") // Evitar demasiados saltos de l√≠nea vac√≠os\r\n                .trim()\r\n\r\n            if (restOfText) {\r\n                textBefore = (textBefore + \"\\n\\n\" + restOfText).trim()\r\n            }\r\n        }\r\n\r\n        results.push({\r\n            type: isVideo ? 'video' : 'image',\r\n            media_url: url,\r\n            url_imagen: url,\r\n            caption: textBefore,\r\n            'mensaje texto ': textBefore\r\n        })\r\n\r\n        lastIndex = match.index + url.length\r\n    }\r\n\r\n    return results\r\n}\r\n\r\n"}