{"name":"index.ts","content":"/**\r\n * ELINA V5 - Main Orchestrator\r\n * \r\n * Voy a usar supabase-ELINA\r\n * Confirmo: project_ref = mytvwfbijlgbihlegmfg\r\n */\r\n\r\nimport { serve } from 'https://deno.land/std@0.168.0/http/server.ts'\r\nimport { createSupabaseAdminClient } from './utils/supabase.ts'\r\nimport { corsHeaders } from './utils/cors.ts'\r\nimport { loadAccountConfig, validateAccountConfig } from './config/account-config.ts'\r\nimport { shouldIgnoreMessage } from './core/filters.ts'\r\nimport { detectIntent, isCriticalIntent } from './intent/detector.ts'\r\nimport { runConversationalAgent } from './agents/conversational.ts'\r\nimport { sendMessage, sendImage, sendAudio } from './utils/evolution.ts'\r\nimport {\r\n    getProfileByInstance,\r\n    ensureContact,\r\n    loadConversationContext,\r\n    saveChatHistory\r\n} from './utils/context.ts'\r\n\r\nconsole.log('ğŸš€ ELINA V5 - Edge Function Started')\r\n\r\nserve(async (req) => {\r\n    // Handle CORS preflight\r\n    if (req.method === 'OPTIONS') {\r\n        return new Response('ok', { headers: corsHeaders })\r\n    }\r\n\r\n    const startTime = performance.now()\r\n\r\n    try {\r\n        const supabase = createSupabaseAdminClient()\r\n        const payload = await req.json()\r\n\r\n        console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”')\r\n        console.log('ğŸ”” [WEBHOOK] New message received')\r\n        console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”')\r\n\r\n        // ========================================================================\r\n        // 1. EXTRACT BASIC DATA\r\n        // ========================================================================\r\n        const data = payload?.data\r\n        if (!data) {\r\n            console.error('âŒ [ERROR] Invalid payload: missing data')\r\n            return new Response(JSON.stringify({ error: 'Invalid payload' }), {\r\n                headers: { ...corsHeaders, 'Content-Type': 'application/json' },\r\n                status: 400\r\n            })\r\n        }\r\n\r\n        const { key, message, pushName } = data\r\n        let remoteJid = key?.remoteJid\r\n\r\n        // Handle LID (Linked Devices)\r\n        if (remoteJid?.includes('@lid')) {\r\n            remoteJid = key?.remoteJidAlt || remoteJid\r\n        }\r\n\r\n        // Clean suffix\r\n        remoteJid = remoteJid?.replace('@s.whatsapp.net', '')\r\n\r\n        const messageId = key?.id\r\n        const instanceName = payload?.instance\r\n        const isSimulation = payload?.isSimulation === true\r\n\r\n        console.log(`ğŸ“‹ [INFO] Instance: ${instanceName}`)\r\n        console.log(`ğŸ“‹ [INFO] Remote JID: ${remoteJid}`)\r\n        console.log(`ğŸ“‹ [INFO] Message ID: ${messageId}`)\r\n        console.log(`ğŸ“‹ [INFO] Simulation: ${isSimulation}`)\r\n\r\n        // Validate required fields\r\n        if (!remoteJid || !messageId || !instanceName) {\r\n            console.error('âŒ [ERROR] Missing required fields')\r\n            return new Response(JSON.stringify({ error: 'Missing required fields' }), {\r\n                headers: corsHeaders,\r\n                status: 400\r\n            })\r\n        }\r\n\r\n        // Ignore status broadcasts and own messages\r\n        if (remoteJid === 'status@broadcast' || key?.fromMe) {\r\n            console.log('â­ï¸ [INFO] Ignoring status broadcast or own message')\r\n            return new Response(JSON.stringify({ ignored: true }), {\r\n                headers: corsHeaders,\r\n                status: 200\r\n            })\r\n        }\r\n\r\n        // ========================================================================\r\n        // 2. LOAD ACCOUNT CONFIGURATION\r\n        // ========================================================================\r\n        console.log(`\\nğŸ“‹ [CONFIG] Loading account configuration...`)\r\n\r\n        const profile = await getProfileByInstance(supabase, instanceName)\r\n        const config = await loadAccountConfig(supabase, profile.id)\r\n\r\n        // Validate configuration\r\n        const validation = validateAccountConfig(config)\r\n        if (!validation.valid) {\r\n            console.error(`âŒ [CONFIG] Invalid configuration: ${validation.errors.join(', ')}`)\r\n            return new Response(JSON.stringify({ error: 'Invalid account configuration', details: validation.errors }), {\r\n                headers: corsHeaders,\r\n                status: 500\r\n            })\r\n        }\r\n\r\n        console.log(`âœ… [CONFIG] Configuration loaded for: ${config.companyName}`)\r\n\r\n        // ========================================================================\r\n        // 3. ENSURE CONTACT EXISTS\r\n        // ========================================================================\r\n        console.log(`\\nğŸ‘¤ [CONTACT] Ensuring contact exists...`)\r\n\r\n        const contact = await ensureContact(supabase, profile.id, remoteJid, pushName)\r\n        console.log(`âœ… [CONTACT] Contact ID: ${contact.id}`)\r\n\r\n        // ========================================================================\r\n        // 4. CHECK FILTERS\r\n        // ========================================================================\r\n        console.log(`\\nğŸ” [FILTER] Checking filters...`)\r\n\r\n        const filterResult = await shouldIgnoreMessage(supabase, config, contact.id)\r\n        if (filterResult.ignore) {\r\n            console.log(`ğŸš« [FILTER] Message ignored: ${filterResult.reason}`)\r\n            return new Response(JSON.stringify({\r\n                ignored: true,\r\n                reason: filterResult.reason\r\n            }), {\r\n                headers: corsHeaders,\r\n                status: 200\r\n            })\r\n        }\r\n\r\n        console.log(`âœ… [FILTER] Message should be processed`)\r\n\r\n        // ========================================================================\r\n        // 5. EXTRACT MESSAGE TEXT\r\n        // ========================================================================\r\n        let messageText = message.conversation ||\r\n            message.extendedTextMessage?.text ||\r\n            ''\r\n\r\n        if (!messageText) {\r\n            console.log('â­ï¸ [INFO] No text message found (media only or unsupported type)')\r\n            return new Response(JSON.stringify({ ignored: true, reason: 'No text content' }), {\r\n                headers: corsHeaders,\r\n                status: 200\r\n            })\r\n        }\r\n\r\n        console.log(`\\nğŸ’¬ [MESSAGE] Text: \"${messageText.substring(0, 100)}${messageText.length > 100 ? '...' : ''}\"`)\r\n\r\n        // ========================================================================\r\n        // 5.5 MESSAGE BUFFERING (Group rapid consecutive messages)\r\n        // Uses Supabase table to coordinate between independent requests\r\n        // ========================================================================\r\n        if (!isSimulation) {\r\n            console.log(`\\nâ³ [BUFFER] Checking for rapid consecutive messages...`)\r\n            const { bufferMessage } = await import('./utils/message-buffer.ts')\r\n            const bufferResult = await bufferMessage(supabase, profile.id, contact.id, messageText)\r\n\r\n            if (!bufferResult.shouldProcess) {\r\n                // A newer message arrived â€” this request should NOT process\r\n                console.log(`â­ï¸ [BUFFER] Deferring to newer message, this request ends here`)\r\n                return new Response(JSON.stringify({ buffered: true, reason: 'Deferred to newer message' }), {\r\n                    headers: { ...corsHeaders, 'Content-Type': 'application/json' },\r\n                    status: 200\r\n                })\r\n            }\r\n\r\n            messageText = bufferResult.combinedText\r\n            if (bufferResult.combinedText.includes('\\n')) {\r\n                console.log(`âœ… [BUFFER] Processing ${bufferResult.combinedText.split('\\n').length} combined messages`)\r\n            }\r\n        }\r\n\r\n        // ========================================================================\r\n        // 6. CHECK AUTO RESPONSES\r\n        // ========================================================================\r\n        console.log(`\\nğŸ¤– [AUTOMATION] Checking auto-responses...`)\r\n        const { checkAutoResponses } = await import('./utils/automation.ts')\r\n        const autoResponse = checkAutoResponses(messageText, config)\r\n\r\n        if (autoResponse) {\r\n            console.log(`âœ… [AUTOMATION] Auto-response triggered: ${autoResponse.triggerText}`)\r\n\r\n            // ğŸ”„ NUEVO: Solo enviar si NO es simulaciÃ³n\r\n            if (!isSimulation) {\r\n                await sendMessage(config, remoteJid, autoResponse.responseText)\r\n            }\r\n\r\n            // Save history\r\n            await saveChatHistory(\r\n                supabase,\r\n                profile.id,\r\n                contact.id,\r\n                messageText,\r\n                autoResponse.responseText,\r\n                {\r\n                    primary: 'auto_response' as any,\r\n                    confidence: 1.0,\r\n                    sentiment: { polarity: 'neutral', score: 0 },\r\n                    entities: {}\r\n                }\r\n            )\r\n\r\n            return new Response(JSON.stringify({\r\n                success: true,\r\n                intent: 'auto_response',\r\n                response: autoResponse.responseText\r\n            }), { headers: corsHeaders })\r\n        }\r\n\r\n        // ========================================================================\r\n        // 6. DETECT INTENT\r\n        // ========================================================================\r\n        console.log(`\\nğŸ¯ [INTENT] Detecting intent...`)\r\n\r\n        const conversationHistory = await loadConversationContext(\r\n            supabase,\r\n            config,\r\n            contact,\r\n            messageText,\r\n            { primary: 'unknown' }\r\n        ).then(ctx => ctx.recentMessages)\r\n\r\n        const intent = await detectIntent(messageText, config, conversationHistory)\r\n\r\n        console.log(`âœ… [INTENT] Detected: ${intent.primary}`)\r\n        console.log(`   - Confidence: ${intent.confidence}`)\r\n        console.log(`   - Sentiment: ${intent.sentiment.polarity} (${intent.sentiment.score})`)\r\n\r\n        // Handle critical intents\r\n        if (isCriticalIntent(intent.primary)) {\r\n            console.log(`ğŸš¨ [CRITICAL] Critical intent detected: ${intent.primary}`)\r\n            // TODO: Notify account owner\r\n        }\r\n\r\n        // ========================================================================\r\n        // 7. LOAD FULL CONTEXT\r\n        // ========================================================================\r\n        console.log(`\\nğŸ“š [CONTEXT] Loading conversation context...`)\r\n\r\n        const context = await loadConversationContext(\r\n            supabase,\r\n            config,\r\n            contact,\r\n            messageText,\r\n            intent\r\n        )\r\n\r\n        console.log(`âœ… [CONTEXT] Context loaded`)\r\n        console.log(`   - Recent messages: ${context.recentMessages.length}`)\r\n        console.log(`   - Account learnings: ${context.accountLearnings?.length || 0}`)\r\n        console.log(`   - User preferences: ${context.userPreferences?.length || 0}`)\r\n\r\n        // ========================================================================\r\n        // 8. RUN CONVERSATIONAL AGENT\r\n        // ========================================================================\r\n        console.log(`\\nğŸ¤– [AGENT] Running conversational agent...`)\r\n\r\n        const agentResponse = await runConversationalAgent(\r\n            supabase,\r\n            config,\r\n            messageText,\r\n            intent,\r\n            context\r\n        )\r\n\r\n        // ========================================================================\r\n        // 8.5. EXECUTE TOOL CALLS (if any)\r\n        // ========================================================================\r\n        let executedToolResults: any[] = []  // ğŸ”¥ Guardar para recopilar media despuÃ©s\r\n\r\n        if (agentResponse.toolCalls && agentResponse.toolCalls.length > 0) {\r\n            console.log(`\\nğŸ”§ [TOOLS] Agent requested ${agentResponse.toolCalls.length} tool call(s)`)\r\n\r\n            const { executeToolCalls } = await import('./utils/tool-executor.ts')\r\n\r\n            const toolResults = await executeToolCalls(\r\n                supabase,\r\n                config,\r\n                contact.id,\r\n                agentResponse.toolCalls\r\n            )\r\n\r\n            executedToolResults = toolResults  // ğŸ”¥ Guardar para usar despuÃ©s\r\n\r\n            console.log(`âœ… [TOOLS] Tool calls executed, re-calling agent with results`)\r\n\r\n            // Re-llamar al agente con los resultados de las herramientas\r\n            const finalAgentResponse = await runConversationalAgent(\r\n                supabase,\r\n                config,\r\n                messageText,\r\n                intent,\r\n                context,\r\n                agentResponse.toolCalls,  // â† Pasar tool_calls originales\r\n                toolResults               // â† Pasar resultados\r\n            )\r\n\r\n            // Usar la respuesta final\r\n            agentResponse.text = finalAgentResponse.text\r\n            agentResponse.metadata = finalAgentResponse.metadata\r\n        }\r\n\r\n        if (!agentResponse.text || agentResponse.text.trim() === '') {\r\n            console.warn('âš ï¸ [AGENT] Empty response received. Using fallback.')\r\n            agentResponse.text = 'Lo siento, tuve un problema procesando tu mensaje. Â¿PodrÃ­as repetirlo?'\r\n        }\r\n\r\n        console.log(`âœ… [AGENT] Response generated`)\r\n        console.log(`   - Length: ${agentResponse.text.length} chars`)\r\n        console.log(`   - Tokens used: ${agentResponse.metadata.tokensUsed}`)\r\n        console.log(`   - Duration: ${agentResponse.metadata.duration?.toFixed(0)}ms`)\r\n\r\n        // ========================================================================\r\n        // 9. PROCESS PLACEHOLDERS & EXTRACT MEDIA\r\n        // ========================================================================\r\n        console.log(`\\nğŸ§© [PLACEHOLDERS] Processing placeholders...`)\r\n\r\n        const { processPlaceholders } = await import('./utils/placeholders.ts')\r\n\r\n        const placeholderResult = await processPlaceholders(\r\n            supabase,\r\n            config.userId,\r\n            agentResponse.text\r\n        )\r\n\r\n        let finalText = placeholderResult.finalText\r\n\r\n        // Variable to hold product media for later use\r\n        let productMediaForSending: Array<{ url: string, type: 'image' | 'video' }> = []\r\n\r\n        // ========================================================================\r\n        // 10. RECOPILAR MEDIA & CALCULATE TOTALS (CÃ“DIGO HACE EL TRABAJO)\r\n        // ========================================================================\r\n        console.log(`\\nğŸ–¼ï¸ [MEDIA] Collecting media from products and text... (v2.0 - UPDATED)`)\r\n\r\n        const mediaToSend: Array<{ url: string, type: 'image' | 'video', source: 'product' | 'text' }> = []\r\n\r\n        // --- A. PRIMERO: Media de productos (garantizada si el producto tiene media) ---\r\n        // Esto asegura que si un producto fue mencionado y tiene media, SE ENVÃA SIEMPRE\r\n        if (placeholderResult.productMedia && placeholderResult.productMedia.length > 0) {\r\n            console.log(`   - Found ${placeholderResult.productMedia.length} media from products (via placeholders)`)\r\n\r\n            placeholderResult.productMedia.forEach(media => {\r\n                mediaToSend.push({\r\n                    url: media.url,\r\n                    type: media.type,\r\n                    source: 'product'\r\n                })\r\n            })\r\n        }\r\n\r\n        // ğŸ”¥ FALLBACK: TambiÃ©n buscar media en tool results (por si el LLM olvidÃ³ usar placeholders)\r\n        if (executedToolResults.length > 0) {\r\n            console.log(`   - Checking tool results for additional product media...`)\r\n\r\n            for (const toolResult of executedToolResults) {\r\n                if (toolResult.role === 'tool' && toolResult.content) {\r\n                    try {\r\n                        const content = JSON.parse(toolResult.content)\r\n\r\n                        // Si es resultado de buscar_productos\r\n                        if (content.products && Array.isArray(content.products)) {\r\n                            console.log(`   - Found ${content.products.length} products in tool result`)\r\n\r\n                            content.products.forEach((product: any) => {\r\n                                if (product.media_url && product.media_url.trim()) {\r\n                                    const isVideo = /\\.(mp4|mov|avi|webm)$/i.test(product.media_url)\r\n\r\n                                    // Evitar duplicados (comparar URL)\r\n                                    if (!mediaToSend.find(m => m.url === product.media_url)) {\r\n                                        mediaToSend.push({\r\n                                            url: product.media_url,\r\n                                            type: isVideo ? 'video' : 'image',\r\n                                            source: 'product'\r\n                                        })\r\n                                        console.log(`   - Added media from product ID ${product.id}: ${product.media_url}`)\r\n                                    }\r\n                                }\r\n                            })\r\n                        }\r\n                    } catch (e) {\r\n                        // No es JSON vÃ¡lido, continuar\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // --- B. SEGUNDO: ExtracciÃ³n adicional del texto (por si el LLM agregÃ³ media extra) ---\r\n        // 1. Detectar URLs de Markdown: ![alt](url)\r\n        const markdownRegex = /!\\[([^\\]]*)\\]\\((https:\\/\\/creativersezone\\.b-cdn\\.net\\/[^\\)]+\\.(jpg|jpeg|png|gif|webp|mp4|mov|avi|webm))\\)/gi\r\n        const markdownMatches = [...finalText.matchAll(markdownRegex)]\r\n\r\n        for (const match of markdownMatches) {\r\n            const url = match[2]\r\n            const isVideo = /\\.(mp4|mov|avi|webm)$/i.test(url)\r\n\r\n            // Solo agregar si no estÃ¡ ya en la lista (evitar duplicados con product media)\r\n            if (!mediaToSend.find(m => m.url === url)) {\r\n                mediaToSend.push({\r\n                    url: url,\r\n                    type: isVideo ? 'video' : 'image',\r\n                    source: 'text'\r\n                })\r\n            }\r\n        }\r\n\r\n        // 2. Detectar URLs puras (Raw)\r\n        const mediaUrlRegex = /https:\\/\\/creativersezone\\.b-cdn\\.net\\/[^\\s\\)]+\\.(jpg|jpeg|png|gif|webp|mp4|mov|avi|webm)/gi\r\n        let matches = finalText.match(mediaUrlRegex)\r\n\r\n        if (matches) {\r\n            for (const url of matches) {\r\n                const isVideo = /\\.(mp4|mov|avi|webm)$/i.test(url)\r\n\r\n                // Solo agregar si no estÃ¡ ya en la lista\r\n                if (!mediaToSend.find(m => m.url === url)) {\r\n                    mediaToSend.push({\r\n                        url: url,\r\n                        type: isVideo ? 'video' : 'image',\r\n                        source: 'text'\r\n                    })\r\n                }\r\n            }\r\n        }\r\n\r\n        // --- C. Limpieza de URLs y Markdown de Imagen del texto (GLOBAL) ---\r\n        // Remover markdown de imagen COMPLETO\r\n        finalText = finalText.replace(markdownRegex, '')\r\n\r\n        // Remover URLs sueltas globalmente\r\n        finalText = finalText.replace(mediaUrlRegex, '')\r\n\r\n        // --- D. Regla de Negocio: MÃ¡ximo 3 media files ---\r\n        const MAX_MEDIA = 3\r\n        const finalMediaToSend = mediaToSend.slice(0, MAX_MEDIA)\r\n\r\n        if (mediaToSend.length > MAX_MEDIA) {\r\n            console.log(`   âš ï¸ Limitando media: ${mediaToSend.length} encontrados -> enviando ${MAX_MEDIA}`)\r\n        }\r\n\r\n        // --- C. CÃ¡lculos de Subtotales y Totales (LÃ³gica n8n V4) ---\r\n        console.log(`\\nğŸ§® [CALCS] Running n8n-style calculations...`)\r\n\r\n        // Regex para detectar lÃ­neas de item y calcular subtotal\r\n        // Ejemplo: \"5 piezas Subtotal: $[subtotal_calculado]\"\r\n        const subtotalRegex = /(\\d+)\\s*piezas?\\s*Subtotal:\\s*\\$\\[subtotal_calculado\\]/gi\r\n        let totalAcumulado = 0\r\n\r\n        finalText = finalText.replace(subtotalRegex, (match, qtyStr, offset) => {\r\n            const qty = parseInt(qtyStr, 10)\r\n            // Buscar el precio anterior mÃ¡s cercano en el texto\r\n            const textBefore = finalText.substring(0, offset)\r\n            const pricesFound = textBefore.match(/\\$([\\d,]+(?:\\.\\d{2})?)/g)\r\n\r\n            if (pricesFound && pricesFound.length > 0) {\r\n                const lastPriceStr = pricesFound[pricesFound.length - 1].replace(/[$,]/g, \"\")\r\n                const price = parseFloat(lastPriceStr)\r\n\r\n                if (!isNaN(price)) {\r\n                    const subtotal = qty * price\r\n                    totalAcumulado += subtotal\r\n                    return `${qty} piezas Subtotal: $${subtotal.toLocaleString('es-MX', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`\r\n                }\r\n            }\r\n            return match // Si no se encuentra precio, dejar igual\r\n        })\r\n\r\n        // Reemplazar placeholder de Total General\r\n        finalText = finalText.replace(/\\$\\[TOTAL_CALCULADO\\]/gi, \"$\" + totalAcumulado.toLocaleString(\"es-MX\", { minimumFractionDigits: 2, maximumFractionDigits: 2 }))\r\n\r\n        // --- D. Formato de Texto (Limpieza) ---\r\n        finalText = finalText\r\n            // Convertir negritas de Markdown (**) a WhatsApp (*)\r\n            .replace(/\\*\\*([^*]+)\\*\\*/g, '*$1*')\r\n            // Eliminar corchetes vacÃ­os si quedaron de links mal formados \"[]()\"\r\n            .replace(/\\[\\s*\\]\\(\\s*\\)/g, '')\r\n            // Eliminar espacios mÃºltiples\r\n            .replace(/\\s{2,}/g, ' ')\r\n            // Asegurar saltos de lÃ­nea limpios (mÃ¡ximo 2)\r\n            .replace(/\\n{3,}/g, '\\n\\n')\r\n            .trim()\r\n\r\n        const productMediaCount = mediaToSend.filter(m => m.source === 'product').length\r\n        const textMediaCount = mediaToSend.filter(m => m.source === 'text').length\r\n\r\n        console.log(`   - Found ${mediaToSend.length} total media URL(s)`)\r\n        console.log(`     â€¢ ${productMediaCount} from products (guaranteed)`)\r\n        console.log(`     â€¢ ${textMediaCount} from text (LLM generated)`)\r\n        console.log(`   - Sending ${finalMediaToSend.length} media file(s)`)\r\n        console.log(`   - Cleaned text length: ${finalText.length}`)\r\n\r\n        // ğŸ”¥ CRITICAL: Save media for later use in sending section\r\n        productMediaForSending = finalMediaToSend.map(m => ({ url: m.url, type: m.type }))\r\n\r\n        // ========================================================================\r\n        // 11. SEND RESPONSE WITH MEDIA (N8N V4 STYLE)\r\n        // ========================================================================\r\n        console.log(`\\nğŸ“¤ [SEND] Sending response...`)\r\n\r\n        // ğŸ”„ NUEVO: Solo enviar mensajes reales si NO es simulaciÃ³n\r\n        if (!isSimulation) {\r\n\r\n        if (finalMediaToSend.length > 0) {\r\n            console.log(`   - Sending ${finalMediaToSend.length} media message(s)`)\r\n\r\n            // ========================================================================\r\n            // DISTRIBUCIÃ“N INTELIGENTE DE TEXTO ENTRE CAPTIONS (n8n V4 logic)\r\n            // ========================================================================\r\n\r\n            // Si tenemos productMedia (productos garantizados), usar distribuciÃ³n inteligente\r\n            if (placeholderResult.productMedia && placeholderResult.productMedia.length > 0) {\r\n                console.log(`   - Using smart text distribution across product media`)\r\n\r\n                const { distributeTextAcrossProductMedia } = await import('./utils/text-formatter.ts')\r\n\r\n                const mediaWithCaptions = distributeTextAcrossProductMedia(\r\n                    finalText,\r\n                    placeholderResult.productMedia.slice(0, 3), // Max 3\r\n                    placeholderResult.productsMap,\r\n                    3\r\n                )\r\n\r\n                console.log(`   - Generated ${mediaWithCaptions.length} media with captions`)\r\n\r\n                // Enviar cada media con su caption\r\n                for (let i = 0; i < mediaWithCaptions.length; i++) {\r\n                    const item = mediaWithCaptions[i]\r\n\r\n                    console.log(`   - Sending media ${i + 1}/${mediaWithCaptions.length} (Product ID: ${item.productId})`)\r\n                    console.log(`     Caption length: ${item.caption.length} chars`)\r\n\r\n                    if (item.type === 'video') {\r\n                        const { sendVideo } = await import('./utils/evolution.ts')\r\n                        await sendVideo(config, remoteJid, item.url, item.caption)\r\n                    } else {\r\n                        await sendImage(config, remoteJid, item.url, item.caption)\r\n                    }\r\n\r\n                    // Delay entre mensajes\r\n                    if (i < mediaWithCaptions.length - 1) {\r\n                        await new Promise(r => setTimeout(r, 600))\r\n                    }\r\n                }\r\n\r\n            } else {\r\n                // ========================================================================\r\n                // FALLBACK: Media sin productos (media del texto LLM)\r\n                // ========================================================================\r\n                console.log(`   - Using fallback: media without product distribution`)\r\n\r\n                if (finalMediaToSend.length === 1) {\r\n                    // UNA SOLA MEDIA - Todo el texto como caption\r\n                    const media = finalMediaToSend[0]\r\n                    console.log(`   - Sending single media with full text as caption`)\r\n\r\n                    if (media.type === 'video') {\r\n                        const { sendVideo } = await import('./utils/evolution.ts')\r\n                        await sendVideo(config, remoteJid, media.url, finalText)\r\n                    } else {\r\n                        await sendImage(config, remoteJid, media.url, finalText)\r\n                    }\r\n\r\n                } else {\r\n                    // MÃšLTIPLES MEDIA - Sin caption, texto al final\r\n                    console.log(`   - Sending multiple media, text will be sent after`)\r\n\r\n                    for (let i = 0; i < finalMediaToSend.length; i++) {\r\n                        const media = finalMediaToSend[i]\r\n\r\n                        if (media.type === 'video') {\r\n                            const { sendVideo } = await import('./utils/evolution.ts')\r\n                            await sendVideo(config, remoteJid, media.url, '')\r\n                        } else {\r\n                            await sendImage(config, remoteJid, media.url, '')\r\n                        }\r\n\r\n                        if (i < finalMediaToSend.length - 1) {\r\n                            await new Promise(r => setTimeout(r, 600))\r\n                        }\r\n                    }\r\n\r\n                    // Texto al final\r\n                    if (finalText.length > 0) {\r\n                        await new Promise(r => setTimeout(r, 600))\r\n                        await sendMessage(config, remoteJid, finalText, true)\r\n                    }\r\n                }\r\n            }\r\n\r\n        } else {\r\n            // Sin media - Enviar solo texto\r\n            await sendMessage(config, remoteJid, finalText, true)\r\n        }\r\n\r\n        // Si se requiere cotizaciÃ³n PDF\r\n        if (placeholderResult.shouldGenerateQuote) {\r\n            console.log(`ğŸ“„ [QUOTE] Generating quote PDF...`)\r\n            // TODO: Implementar generaciÃ³n real de PDF\r\n        }\r\n\r\n        } // ğŸ”„ FIN: Cierre de if (!isSimulation)\r\n\r\n        console.log(`âœ… [SEND] Response sent successfully${isSimulation ? ' (simulation mode - no messages sent)' : ''}`)\r\n\r\n        // ========================================================================\r\n        // 11. SAVE TO HISTORY\r\n        // ========================================================================\r\n        console.log(`\\nğŸ’¾ [HISTORY] Saving to chat history...`)\r\n\r\n        await saveChatHistory(\r\n            supabase,\r\n            profile.id,\r\n            contact.id,\r\n            messageText,\r\n            finalText, // Guardamos el texto final\r\n            intent\r\n        )\r\n\r\n        console.log(`âœ… [HISTORY] Saved successfully`)\r\n\r\n        // ========================================================================\r\n        // 12. FINAL METRICS\r\n        // ========================================================================\r\n        const totalDuration = performance.now() - startTime\r\n\r\n        console.log('\\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”')\r\n        console.log(`âœ… [SUCCESS] Message processed successfully`)\r\n        console.log(`â±ï¸  Total duration: ${totalDuration.toFixed(0)}ms`)\r\n        console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\\n')\r\n\r\n        return new Response(JSON.stringify({\r\n            success: true,\r\n            intent: intent.primary,\r\n            sentiment: intent.sentiment.polarity,\r\n            duration: totalDuration,\r\n            tokensUsed: agentResponse.metadata.tokensUsed,\r\n            quoteGenerated: placeholderResult.shouldGenerateQuote,\r\n            toolCalls: agentResponse.toolCalls,\r\n            userId: profile.id, // <--- Verify which user is being used\r\n            text: agentResponse.text, // <--- CRITICAL: Sending the AI response text\r\n            message: agentResponse.text, // <--- Compatibility\r\n            response: agentResponse.text // <--- Compatibility\r\n        }), {\r\n            headers: { ...corsHeaders, 'Content-Type': 'application/json' }\r\n        })\r\n\r\n    } catch (error) {\r\n        console.error('\\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”')\r\n        console.error('âŒ [ERROR] Fatal error processing message')\r\n        console.error(`   Message: ${error.message}`)\r\n        console.error(`   Stack: ${error.stack}`)\r\n        console.error('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\\n')\r\n\r\n        return new Response(JSON.stringify({\r\n            error: error.message,\r\n            stack: error.stack\r\n        }), {\r\n            headers: { ...corsHeaders, 'Content-Type': 'application/json' },\r\n            status: 500\r\n        })\r\n    }\r\n})\r\n"}