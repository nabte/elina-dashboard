{"name":"utils/context.ts","content":"/**\r\n * ELINA V5 - Context Loader\r\n * \r\n * Carga todo el contexto necesario para la conversaci√≥n\r\n */\r\n\r\nimport type { SupabaseClient } from 'https://esm.sh/@supabase/supabase-js@2'\r\nimport type { AccountConfig, ConversationContext, Message, Contact, Product } from '../config/types.ts'\r\nimport { getRelevantLearnings } from '../memory/long-term.ts'\r\n\r\n/**\r\n * Obtiene el perfil por nombre de instancia\r\n */\r\nexport async function getProfileByInstance(\r\n    supabase: SupabaseClient,\r\n    instanceName: string\r\n) {\r\n    const { data, error } = await supabase\r\n        .from('profiles')\r\n        .select('*')\r\n        .eq('evolution_instance_name', instanceName)\r\n        .single()\r\n\r\n    if (error || !data) {\r\n        throw new Error(`Profile not found for instance: ${instanceName}`)\r\n    }\r\n\r\n    return data\r\n}\r\n\r\n/**\r\n * Asegura que el contacto existe en la base de datos\r\n */\r\nexport async function ensureContact(\r\n    supabase: SupabaseClient,\r\n    userId: string,\r\n    phoneNumber: string,\r\n    fullName?: string\r\n): Promise<Contact> {\r\n    // Buscar contacto existente\r\n    const { data: existing, error: searchError } = await supabase\r\n        .from('contacts')\r\n        .select('*')\r\n        .eq('user_id', userId)\r\n        .eq('phone_number', phoneNumber)\r\n        .maybeSingle()\r\n\r\n    if (existing) {\r\n        return existing as Contact\r\n    }\r\n\r\n    // Crear nuevo contacto\r\n    const { data: newContact, error: insertError } = await supabase\r\n        .from('contacts')\r\n        .insert({\r\n            user_id: userId,\r\n            phone_number: phoneNumber,\r\n            full_name: fullName || phoneNumber,\r\n            labels: [],\r\n            created_at: new Date().toISOString()\r\n        })\r\n        .select()\r\n        .single()\r\n\r\n    if (insertError || !newContact) {\r\n        throw new Error(`Failed to create contact: ${insertError?.message}`)\r\n    }\r\n\r\n    return newContact as Contact\r\n}\r\n\r\n/**\r\n * Obtiene el historial de chat reciente\r\n * \r\n * IMPORTANTE: Filtra datos transaccionales antiguos (> 30 min)\r\n * para evitar asumir cantidades/precios de cotizaciones pasadas\r\n */\r\nexport async function getChatHistory(\r\n    supabase: SupabaseClient,\r\n    userId: string,\r\n    contactId: number,\r\n    limit: number = 10\r\n): Promise<Message[]> {\r\n    // Calcular timestamp de hace 30 minutos\r\n    const thirtyMinutesAgo = new Date(Date.now() - 30 * 60 * 1000).toISOString();\r\n\r\n    const { data, error } = await supabase\r\n        .from('chat_history')\r\n        .select('message_type, content, created_at')\r\n        .eq('user_id', userId)\r\n        .eq('contact_id', contactId)\r\n        .gte('created_at', thirtyMinutesAgo) // FILTRO TEMPORAL: solo √∫ltimos 30 min\r\n        .order('created_at', { ascending: false })\r\n        .limit(limit)\r\n\r\n    if (error) {\r\n        console.error(`‚ùå [CONTEXT] Error fetching chat history: ${error.message}`)\r\n        return []\r\n    }\r\n\r\n    const messageCount = data?.length || 0;\r\n    console.log(`üìö [CONTEXT] Loaded ${messageCount} messages from last 30 minutes`);\r\n\r\n    // Convertir a formato Message y revertir orden (m√°s antiguo primero)\r\n    return (data || [])\r\n        .reverse()\r\n        .map(msg => ({\r\n            role: msg.message_type === 'user' ? 'user' : 'assistant',\r\n            content: msg.content,\r\n            timestamp: new Date(msg.created_at)\r\n        })) as Message[]\r\n}\r\n\r\n/**\r\n * Guarda un mensaje en el historial\r\n */\r\nexport async function saveChatHistory(\r\n    supabase: SupabaseClient,\r\n    userId: string,\r\n    contactId: number,\r\n    userMessage: string,\r\n    assistantMessage: string,\r\n    intent: any\r\n): Promise<void> {\r\n    // Guardar mensaje del usuario\r\n    await supabase.from('chat_history').insert({\r\n        user_id: userId,\r\n        contact_id: contactId,\r\n        message_type: 'user',\r\n        content: userMessage,\r\n        created_at: new Date().toISOString()\r\n    })\r\n\r\n    // Guardar respuesta del asistente\r\n    await supabase.from('chat_history').insert({\r\n        user_id: userId,\r\n        contact_id: contactId,\r\n        message_type: 'assistant',\r\n        content: assistantMessage,\r\n        metadata: {\r\n            intent: intent.primary,\r\n            sentiment: intent.sentiment.polarity\r\n        },\r\n        created_at: new Date().toISOString()\r\n    })\r\n}\r\n\r\n/**\r\n * Carga el contexto completo de la conversaci√≥n\r\n * \r\n * IMPORTANTE: Filtra datos transaccionales antiguos si detecta nueva solicitud\r\n */\r\nexport async function loadConversationContext(\r\n    supabase: SupabaseClient,\r\n    config: AccountConfig,\r\n    contact: Contact,\r\n    currentMessage: string,\r\n    intent: any\r\n): Promise<ConversationContext> {\r\n    console.log(`üìö [CONTEXT] Loading conversation context`)\r\n\r\n    // Importar din√°micamente para evitar dependencias circulares\r\n    const { loadConversationState } = await import('./conversation-state.ts')\r\n    const { isNewTransactionalRequest, filterTransactionalContext } = await import('./context-filter.ts')\r\n\r\n    // Cargar todo en paralelo\r\n    const [\r\n        recentMessages,\r\n        accountLearnings,\r\n        userPreferences,\r\n        topProducts,\r\n        conversationState\r\n    ] = await Promise.all([\r\n        getChatHistory(supabase, config.userId, contact.id, 10),\r\n        getRelevantLearnings(supabase, config.userId, currentMessage, 5),\r\n        getUserPreferences(supabase, contact.id),\r\n        config.hasProducts ? getTopProducts(supabase, config.userId, 5) : Promise.resolve([]),\r\n        loadConversationState(supabase, contact.id.toString())\r\n    ])\r\n\r\n    // Detectar si es nueva solicitud transaccional\r\n    const isNewRequest = isNewTransactionalRequest(currentMessage, recentMessages);\r\n\r\n    // Filtrar contexto si es nueva solicitud\r\n    const filteredMessages = filterTransactionalContext(recentMessages, isNewRequest);\r\n\r\n    if (isNewRequest && filteredMessages.length < recentMessages.length) {\r\n        console.log(`üßπ [CONTEXT] Filtered ${recentMessages.length - filteredMessages.length} old quote messages`);\r\n    }\r\n\r\n    return {\r\n        recentMessages: filteredMessages,\r\n        accountLearnings,\r\n        userPreferences,\r\n        topProducts,\r\n        conversationState: conversationState || null,\r\n        ragContext: undefined, // Set later in index.ts after RAG retrieval\r\n        activePromotions: [], // TODO: Cargar promociones activas\r\n        appointmentSlots: [] // TODO: Cargar slots si es necesario\r\n    }\r\n}\r\n\r\n/**\r\n * Obtiene las preferencias del usuario\r\n */\r\nasync function getUserPreferences(\r\n    supabase: SupabaseClient,\r\n    contactId: number\r\n) {\r\n    const { data, error } = await supabase\r\n        .from('user_preferences')\r\n        .select('*')\r\n        .eq('contact_id', contactId)\r\n\r\n    if (error) {\r\n        console.error(`‚ùå [CONTEXT] Error fetching preferences: ${error.message}`)\r\n        return []\r\n    }\r\n\r\n    return data || []\r\n}\r\n\r\n/**\r\n * Obtiene los productos m√°s populares\r\n */\r\nasync function getTopProducts(\r\n    supabase: SupabaseClient,\r\n    userId: string,\r\n    limit: number\r\n): Promise<Product[]> {\r\n    const { data, error } = await supabase\r\n        .from('products')\r\n        .select('*')\r\n        .eq('user_id', userId)\r\n        .limit(limit)\r\n\r\n    if (error) {\r\n        console.error(`‚ùå [CONTEXT] Error fetching products: ${error.message}`)\r\n        return []\r\n    }\r\n\r\n    return (data || []) as Product[]\r\n}\r\n"}