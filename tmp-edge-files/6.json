{"name":"intent/detector.ts","content":"/**\r\n * ELINA V5 - Intent Detection System\r\n * \r\n * Sistema avanzado de detecci√≥n de intenciones con an√°lisis de sentimientos\r\n */\r\n\r\nimport type { AccountConfig, Intent, IntentDetectionResult, SentimentAnalysis, Message } from '../config/types.ts'\r\nimport { INTENT_CONFIDENCE_THRESHOLD } from '../config/constants.ts'\r\n\r\n/**\r\n * Detecta la intenci√≥n del mensaje del usuario\r\n */\r\nexport async function detectIntent(\r\n    message: string,\r\n    config: AccountConfig,\r\n    conversationHistory: Message[] = []\r\n): Promise<IntentDetectionResult> {\r\n    console.log(`üéØ [INTENT] Detecting intent for message: \"${message.substring(0, 50)}...\"`)\r\n\r\n    // 1. Detecci√≥n basada en reglas (r√°pido)\r\n    const ruleBasedIntent = detectIntentByRules(message, config)\r\n\r\n    // 2. Si la confianza es alta, usar el resultado de reglas\r\n    if (ruleBasedIntent.confidence >= INTENT_CONFIDENCE_THRESHOLD) {\r\n        console.log(`‚úÖ [INTENT] Rule-based detection: ${ruleBasedIntent.primary} (${ruleBasedIntent.confidence})`)\r\n        return ruleBasedIntent\r\n    }\r\n\r\n    // 3. Si no, usar LLM para mayor precisi√≥n (m√°s lento)\r\n    console.log(`ü§ñ [INTENT] Using LLM for intent detection (low confidence: ${ruleBasedIntent.confidence})`)\r\n    return await detectIntentByLLM(message, config, conversationHistory)\r\n}\r\n\r\n/**\r\n * Detecci√≥n de intenci√≥n basada en reglas y patrones\r\n */\r\nfunction detectIntentByRules(\r\n    message: string,\r\n    config: AccountConfig\r\n): IntentDetectionResult {\r\n    const lowerMessage = message.toLowerCase().trim()\r\n    const sentiment = analyzeSentiment(message)\r\n\r\n    // Saludos\r\n    if (/^(hola|buenos d√≠as|buenas tardes|buenas noches|hey|qu√© tal|saludos|buen d√≠a)/i.test(message)) {\r\n        return {\r\n            primary: 'greeting' as Intent,\r\n            confidence: 0.95,\r\n            sentiment,\r\n            entities: {}\r\n        }\r\n    }\r\n\r\n    // Despedidas\r\n    if (/^(adi√≥s|hasta luego|nos vemos|chao|bye|gracias|ok gracias)/i.test(message)) {\r\n        return {\r\n            primary: 'farewell' as Intent,\r\n            confidence: 0.9,\r\n            sentiment,\r\n            entities: {}\r\n        }\r\n    }\r\n\r\n    // Quejas (CR√çTICO)\r\n    if (/\\b(queja|reclamo|molesto|enojado|mal servicio|p√©simo|horrible|terrible|decepcionado|fraude|estafa)\\b/i.test(lowerMessage)) {\r\n        return {\r\n            primary: 'complaint' as Intent,\r\n            confidence: 0.95,\r\n            sentiment: { polarity: 'negative', score: -0.8 },\r\n            entities: {}\r\n        }\r\n    }\r\n\r\n    // Urgencias (CR√çTICO)\r\n    if (/\\b(urgente|emergencia|ayuda|problema grave|necesito ya|inmediato)\\b/i.test(lowerMessage)) {\r\n        return {\r\n            primary: 'urgent_issue' as Intent,\r\n            confidence: 0.9,\r\n            sentiment: { polarity: 'negative', score: -0.6 },\r\n            entities: {}\r\n        }\r\n    }\r\n\r\n    // Cancelaciones\r\n    if (/\\b(cancelar|anular|ya no quiero|mejor no|desistir)\\b/i.test(lowerMessage)) {\r\n        return {\r\n            primary: 'cancellation' as Intent,\r\n            confidence: 0.85,\r\n            sentiment,\r\n            entities: {}\r\n        }\r\n    }\r\n\r\n    // Citas (solo si est√° habilitado)\r\n    if (config.hasAppointments || config.appointmentsEnabled) {\r\n        if (/\\b(cita|agendar|reservar|turno|hora|consulta|appointment)\\b/i.test(lowerMessage)) {\r\n            return {\r\n                primary: 'appointment_request' as Intent,\r\n                confidence: 0.9,\r\n                sentiment,\r\n                entities: extractEntities(message)\r\n            }\r\n        }\r\n    }\r\n\r\n    // Cotizaciones\r\n    if (config.quotesEnabled || config.hasQuotes) {\r\n        if (/\\b(cotizaci√≥n|presupuesto|precio total|cu√°nto ser√≠a todo|quote)\\b/i.test(lowerMessage)) {\r\n            return {\r\n                primary: 'quote_request' as Intent,\r\n                confidence: 0.85,\r\n                sentiment,\r\n                entities: extractEntities(message)\r\n            }\r\n        }\r\n    }\r\n\r\n    // Productos\r\n    if (config.hasProducts) {\r\n        if (/\\b(producto|art√≠culo|precio|costo|cu√°nto|disponible|stock|inventario|comprar|vend(es|en)|tien(es|en)|ofrec(es|en)|manej(as|an)|cat√°logo|qu√© si vend)\\b/i.test(lowerMessage)) {\r\n            return {\r\n                primary: 'product_inquiry' as Intent,\r\n                confidence: 0.8,\r\n                sentiment,\r\n                entities: extractEntities(message)\r\n            }\r\n        }\r\n    }\r\n\r\n    // Servicios\r\n    if (config.hasServices) {\r\n        if (/\\b(servicio|ofreces|haces|realizas|cu√°nto cobras)\\b/i.test(lowerMessage)) {\r\n            return {\r\n                primary: 'service_inquiry' as Intent,\r\n                confidence: 0.8,\r\n                sentiment,\r\n                entities: extractEntities(message)\r\n            }\r\n        }\r\n    }\r\n\r\n    // Confirmaciones\r\n    if (/^(s√≠|si|yes|ok|est√° bien|perfecto|de acuerdo|confirmo|acepto)\\b/i.test(message)) {\r\n        return {\r\n            primary: 'confirmation' as Intent,\r\n            confidence: 0.85,\r\n            sentiment: { polarity: 'positive', score: 0.6 },\r\n            entities: {}\r\n        }\r\n    }\r\n\r\n    // Default: pregunta general\r\n    return {\r\n        primary: 'general_question' as Intent,\r\n        confidence: 0.5,\r\n        sentiment,\r\n        entities: extractEntities(message)\r\n    }\r\n}\r\n\r\n/**\r\n * Detecci√≥n de intenci√≥n usando LLM (m√°s preciso pero m√°s lento)\r\n */\r\nasync function detectIntentByLLM(\r\n    message: string,\r\n    config: AccountConfig,\r\n    conversationHistory: Message[]\r\n): Promise<IntentDetectionResult> {\r\n    const openrouterKey = Deno.env.get('OPENROUTER_API_KEY')\r\n    if (!openrouterKey) {\r\n        console.warn(`‚ö†Ô∏è [INTENT] OPENROUTER_API_KEY not found, falling back to rule-based`)\r\n        return detectIntentByRules(message, config)\r\n    }\r\n\r\n    const prompt = `Analiza el siguiente mensaje y determina la intenci√≥n principal del usuario.\r\n\r\nMensaje: \"${message}\"\r\n\r\nContexto de negocio:\r\n- Tipo: ${config.businessType}\r\n- Tiene productos: ${config.hasProducts}\r\n- Tiene servicios: ${config.hasServices}\r\n- Tiene citas: ${config.appointmentsEnabled}\r\n- Tiene cotizaciones: ${config.quotesEnabled}\r\n\r\nResponde SOLO con un JSON en este formato:\r\n{\r\n  \"intent\": \"greeting|farewell|product_inquiry|service_inquiry|appointment_request|quote_request|complaint|urgent_issue|cancellation|confirmation|general_question|unknown\",\r\n  \"confidence\": 0.0-1.0,\r\n  \"sentiment\": \"positive|neutral|negative\",\r\n  \"entities\": {\r\n    \"products\": [\"producto1\", \"producto2\"],\r\n    \"dates\": [\"2026-02-10\"],\r\n    \"prices\": [100, 200]\r\n  }\r\n}`\r\n\r\n    try {\r\n        const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {\r\n            method: 'POST',\r\n            headers: {\r\n                'Authorization': `Bearer ${openrouterKey}`,\r\n                'HTTP-Referer': 'https://elina.ai',\r\n                'X-Title': 'ELINA V5 Intent Detection',\r\n                'Content-Type': 'application/json'\r\n            },\r\n            body: JSON.stringify({\r\n                model: 'openai/gpt-4o-mini', // M√°s barato para detecci√≥n de intenci√≥n\r\n                messages: [{ role: 'user', content: prompt }],\r\n                temperature: 0.3,\r\n                max_tokens: 200\r\n            })\r\n        })\r\n\r\n        if (!response.ok) {\r\n            throw new Error(`OpenRouter API error: ${response.statusText}`)\r\n        }\r\n\r\n        const data = await response.json()\r\n        const content = data.choices[0].message.content\r\n\r\n        // Extraer JSON de la respuesta\r\n        const jsonMatch = content.match(/\\{[\\s\\S]*\\}/)\r\n        if (!jsonMatch) {\r\n            throw new Error('No JSON found in LLM response')\r\n        }\r\n\r\n        const result = JSON.parse(jsonMatch[0])\r\n\r\n        return {\r\n            primary: result.intent as Intent,\r\n            confidence: result.confidence || 0.7,\r\n            sentiment: {\r\n                polarity: result.sentiment || 'neutral',\r\n                score: result.sentiment === 'positive' ? 0.6 : result.sentiment === 'negative' ? -0.6 : 0\r\n            },\r\n            entities: result.entities || {}\r\n        }\r\n    } catch (error) {\r\n        console.error(`‚ùå [INTENT] LLM detection failed: ${error.message}`)\r\n        return detectIntentByRules(message, config)\r\n    }\r\n}\r\n\r\n/**\r\n * Analiza el sentimiento del mensaje\r\n */\r\nexport function analyzeSentiment(message: string): SentimentAnalysis {\r\n    const lowerMessage = message.toLowerCase()\r\n\r\n    // Palabras positivas\r\n    const positiveWords = ['excelente', 'genial', 'perfecto', 'gracias', 'bueno', 'bien', 'feliz', 'contento', 'encantado', 'maravilloso']\r\n    const positiveCount = positiveWords.filter(word => lowerMessage.includes(word)).length\r\n\r\n    // Palabras negativas\r\n    const negativeWords = ['mal', 'p√©simo', 'horrible', 'terrible', 'molesto', 'enojado', 'decepcionado', 'problema', 'queja', 'reclamo']\r\n    const negativeCount = negativeWords.filter(word => lowerMessage.includes(word)).length\r\n\r\n    // Calcular polaridad\r\n    if (positiveCount > negativeCount) {\r\n        return {\r\n            polarity: 'positive',\r\n            score: Math.min(0.8, 0.3 + (positiveCount * 0.2))\r\n        }\r\n    } else if (negativeCount > positiveCount) {\r\n        return {\r\n            polarity: 'negative',\r\n            score: Math.max(-0.8, -0.3 - (negativeCount * 0.2))\r\n        }\r\n    }\r\n\r\n    return {\r\n        polarity: 'neutral',\r\n        score: 0\r\n    }\r\n}\r\n\r\n/**\r\n * Extrae entidades del mensaje (productos, fechas, precios, etc.)\r\n */\r\nfunction extractEntities(message: string): {\r\n    products?: string[]\r\n    services?: string[]\r\n    dates?: string[]\r\n    prices?: number[]\r\n    phoneNumbers?: string[]\r\n} {\r\n    const entities: any = {}\r\n\r\n    // Extraer precios (ej: $100, 100 pesos, $1,000.00)\r\n    const priceRegex = /\\$?\\d{1,3}(?:,\\d{3})*(?:\\.\\d{2})?(?:\\s*(?:pesos|mxn|usd|d√≥lares))?/gi\r\n    const prices = message.match(priceRegex)\r\n    if (prices) {\r\n        entities.prices = prices.map(p => parseFloat(p.replace(/[$,]/g, '')))\r\n    }\r\n\r\n    // Extraer fechas (ej: 10/02/2026, 10 de febrero, ma√±ana)\r\n    const dateKeywords = ['ma√±ana', 'hoy', 'pasado ma√±ana', 'lunes', 'martes', 'mi√©rcoles', 'jueves', 'viernes', 's√°bado', 'domingo']\r\n    const foundDates = dateKeywords.filter(keyword => message.toLowerCase().includes(keyword))\r\n    if (foundDates.length > 0) {\r\n        entities.dates = foundDates\r\n    }\r\n\r\n    // Extraer n√∫meros de tel√©fono (ej: 5512345678, +52 55 1234 5678)\r\n    const phoneRegex = /(?:\\+?52\\s?)?(?:\\d{2,3}\\s?)?\\d{4}\\s?\\d{4}/g\r\n    const phones = message.match(phoneRegex)\r\n    if (phones) {\r\n        entities.phoneNumbers = phones\r\n    }\r\n\r\n    return entities\r\n}\r\n\r\n/**\r\n * Verifica si la intenci√≥n es cr√≠tica y requiere atenci√≥n humana\r\n */\r\nexport function isCriticalIntent(intent: Intent): boolean {\r\n    const criticalIntents: Intent[] = [\r\n        'complaint' as Intent,\r\n        'urgent_issue' as Intent,\r\n        'cancellation' as Intent,\r\n        'refund_request' as Intent\r\n    ]\r\n\r\n    return criticalIntents.includes(intent)\r\n}\r\n"}