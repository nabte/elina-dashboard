{"name":"utils/conversation-state.ts","content":"import { SupabaseClient } from 'https://esm.sh/@supabase/supabase-js@2'\r\nimport type {\r\n    ConversationContextState,\r\n    MentionedProduct,\r\n    CartItem\r\n} from '../config/types.ts'\r\n\r\n/**\r\n * Loads conversation state for a contact\r\n */\r\nexport async function loadConversationState(\r\n    supabase: SupabaseClient,\r\n    contactId: string\r\n): Promise<ConversationContextState | null> {\r\n    try {\r\n        const { data, error } = await supabase\r\n            .from('conversation_contexts') // Changed from conversation_states\r\n            .select('state')\r\n            .eq('contact_id', contactId)\r\n            .single()\r\n\r\n        if (error || !data) {\r\n            return null\r\n        }\r\n\r\n        const state = typeof data.state === 'string'\r\n            ? JSON.parse(data.state)\r\n            : data.state\r\n\r\n        // Check if state is stale (older than 24 hours)\r\n        const updatedAt = new Date(state.updatedAt)\r\n        const hoursSince = (Date.now() - updatedAt.getTime()) / 3600000\r\n\r\n        if (hoursSince > 24) {\r\n            console.log(`⏰ [STATE] Conversation state is stale (${hoursSince.toFixed(1)}h old), ignoring`)\r\n            return null\r\n        }\r\n\r\n        console.log(`✅ [STATE] Loaded conversation state: ${state.lastProductsMentioned?.length || 0} products mentioned`)\r\n        return state\r\n\r\n    } catch (error) {\r\n        console.error(`❌ [STATE] Error loading conversation state:`, error)\r\n        return null\r\n    }\r\n}\r\n\r\n/**\r\n * Saves conversation state for a contact\r\n */\r\nexport async function saveConversationState(\r\n    supabase: SupabaseClient,\r\n    contactId: string,\r\n    state: Partial<ConversationContextState>\r\n): Promise<void> {\r\n    try {\r\n        // Load existing state and merge\r\n        const existing = await loadConversationState(supabase, contactId)\r\n        const merged: ConversationContextState = {\r\n            lastProductsMentioned: state.lastProductsMentioned || existing?.lastProductsMentioned || [],\r\n            tentativeCart: state.tentativeCart || existing?.tentativeCart || [],\r\n            lastIntent: state.lastIntent || existing?.lastIntent || 'unknown',\r\n            lastAgentResponse: state.lastAgentResponse || existing?.lastAgentResponse,\r\n            appointmentContext: state.appointmentContext || existing?.appointmentContext,\r\n            potentialService: state.potentialService || existing?.potentialService,\r\n            updatedAt: new Date().toISOString()\r\n        }\r\n\r\n        await supabase.from('conversation_contexts').upsert({ // Changed from conversation_states\r\n            contact_id: contactId,\r\n            state: merged,\r\n            updated_at: merged.updatedAt\r\n        })\r\n\r\n        console.log(`✅ [STATE] Saved conversation state for contact ${contactId}`)\r\n\r\n    } catch (error) {\r\n        console.error(`❌ [STATE] Error saving conversation state:`, error)\r\n    }\r\n}\r\n\r\n/**\r\n * Detects contextual references in user message\r\n * Examples: \"el primero\", \"el segundo\", \"ese\", \"esa\"\r\n */\r\nexport function detectContextualReference(message: string): {\r\n    hasReference: boolean\r\n    position?: number\r\n    type: 'positional' | 'demonstrative' | 'none'\r\n} {\r\n    const lowerMessage = message.toLowerCase()\r\n\r\n    // Positional references: \"el primero\", \"el segundo\", \"la tercera\"\r\n    const positionalPatterns = [\r\n        { pattern: /\\b(el|la)\\s+primer[oa]?\\b/i, position: 1 },\r\n        { pattern: /\\b(el|la)\\s+segund[oa]?\\b/i, position: 2 },\r\n        { pattern: /\\b(el|la)\\s+tercer[oa]?\\b/i, position: 3 },\r\n        { pattern: /\\b(el|la)\\s+cuart[oa]?\\b/i, position: 4 },\r\n        { pattern: /\\b(el|la)\\s+quint[oa]?\\b/i, position: 5 }\r\n    ]\r\n\r\n    for (const { pattern, position } of positionalPatterns) {\r\n        if (pattern.test(lowerMessage)) {\r\n            return { hasReference: true, position, type: 'positional' }\r\n        }\r\n    }\r\n\r\n    // Demonstrative references: \"ese\", \"esa\", \"esos\", \"aquel\"\r\n    if (/\\b(ese|esa|esos|esas|aquel|aquella|aquellos|aquellas)\\b/i.test(lowerMessage)) {\r\n        // Assume they mean the last one mentioned (position 1)\r\n        return { hasReference: true, position: 1, type: 'demonstrative' }\r\n    }\r\n\r\n    return { hasReference: false, type: 'none' }\r\n}\r\n\r\n/**\r\n * Resolves a contextual reference to a product ID\r\n */\r\nexport function resolveReference(\r\n    reference: ReturnType<typeof detectContextualReference>,\r\n    state: ConversationContextState | null\r\n): number | null {\r\n    if (!reference.hasReference || !state || !state.lastProductsMentioned.length) {\r\n        return null\r\n    }\r\n\r\n    const product = state.lastProductsMentioned.find(p => p.position === reference.position)\r\n    return product?.id || null\r\n}\r\n\r\n/**\r\n * Extracts product IDs from agent response (for tracking what was shown)\r\n */\r\nexport function extractMentionedProducts(\r\n    responseText: string,\r\n    productMap: Record<string, any>\r\n): MentionedProduct[] {\r\n    const mentioned: MentionedProduct[] = []\r\n    const productIdRegex = /\\[PRODUCT_(?:CARD|NAME|PRICE|MEDIA):(\\d+)\\]/g\r\n    const foundIds = new Set<number>()\r\n\r\n    let match\r\n    let position = 1\r\n    while ((match = productIdRegex.exec(responseText)) !== null) {\r\n        const id = parseInt(match[1], 10)\r\n        if (!foundIds.has(id) && productMap[id]) {\r\n            foundIds.add(id)\r\n            mentioned.push({\r\n                id,\r\n                position: position++,\r\n                name: productMap[id].productName,\r\n                price: productMap[id].price,\r\n                mentionedAt: new Date().toISOString()\r\n            })\r\n        }\r\n    }\r\n\r\n    return mentioned\r\n}\r\n"}