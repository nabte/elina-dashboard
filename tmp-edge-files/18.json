{"name":"utils/rag-system.ts","content":"/**\r\n * RAG System with Semantic Embeddings\r\n * Retrieval-Augmented Generation for context-aware responses\r\n */\r\n\r\nimport { SupabaseClient } from 'https://esm.sh/@supabase/supabase-js@2'\r\n\r\n\r\nconst OPENAI_API_KEY = Deno.env.get('OPENAI_API_KEY')!\r\nconst EMBEDDING_MODEL = 'text-embedding-3-small'\r\nconst SIMILARITY_THRESHOLD = 0.35\r\nconst MAX_CONTEXT_MESSAGES = 5\r\nconst MAX_PRODUCT_RESULTS = 3\r\n\r\nexport interface RAGContext {\r\n    relevantMessages: Array<{\r\n        content: string\r\n        type: string\r\n        similarity: number\r\n        created_at: string\r\n    }>\r\n    relevantProducts: Array<{\r\n        product_name: string\r\n        description: string\r\n        price: number\r\n        similarity: number\r\n    }>\r\n    contextSummary: string\r\n    relevantKnowledge: Array<{\r\n        content: string\r\n        similarity: number\r\n        metadata: any\r\n    }>\r\n}\r\n\r\n/**\r\n * Generates embedding for text using OpenAI API with caching\r\n * @param supabase Supabase client\r\n * @param text Text to generate embedding for\r\n * @param userId Optional user ID for tracking\r\n * @returns Embedding vector\r\n */\r\nasync function generateEmbedding(\r\n    supabase: SupabaseClient,\r\n    text: string,\r\n    userId?: string\r\n): Promise<number[]> {\r\n    try {\r\n        // Generate hash for cache lookup using Web Crypto API\r\n        const encoder = new TextEncoder()\r\n        const textData = encoder.encode(text)\r\n        const hashBuffer = await crypto.subtle.digest('SHA-256', textData)\r\n        const hashArray = Array.from(new Uint8Array(hashBuffer))\r\n        const textHash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('')\r\n\r\n\r\n        // Check cache first\r\n        const { data: cached } = await supabase\r\n            .from('embedding_cache')\r\n            .select('embedding')\r\n            .eq('text_hash', textHash)\r\n            .eq('model', EMBEDDING_MODEL)\r\n            .single()\r\n\r\n        if (cached?.embedding) {\r\n            // console.log(`‚úÖ [RAG] Using cached embedding`)\r\n\r\n            // Update usage stats\r\n            await supabase\r\n                .from('embedding_cache')\r\n                .update({\r\n                    last_used_at: new Date().toISOString(),\r\n                    usage_count: supabase.rpc('increment', { row_id: textHash })\r\n                })\r\n                .eq('text_hash', textHash)\r\n\r\n            return cached.embedding\r\n        }\r\n\r\n        // console.log(`üîÑ [RAG] Generating new embedding...`)\r\n\r\n        // Generate new embedding\r\n        const response = await fetch('https://api.openai.com/v1/embeddings', {\r\n            method: 'POST',\r\n            headers: {\r\n                'Authorization': `Bearer ${OPENAI_API_KEY}`,\r\n                'Content-Type': 'application/json'\r\n            },\r\n            body: JSON.stringify({\r\n                model: EMBEDDING_MODEL,\r\n                input: text\r\n            })\r\n        })\r\n\r\n        if (!response.ok) {\r\n            const error = await response.text()\r\n            throw new Error(`OpenAI API error: ${error}`)\r\n        }\r\n\r\n        const data = await response.json()\r\n        const embedding = data.data[0].embedding\r\n\r\n        // Cache the embedding\r\n        await supabase\r\n            .from('embedding_cache')\r\n            .insert({\r\n                text_hash: textHash,\r\n                text_content: text,\r\n                embedding,\r\n                model: EMBEDDING_MODEL,\r\n                user_id: userId\r\n            })\r\n            .select()\r\n\r\n        // console.log(`‚úÖ [RAG] Embedding generated and cached`)\r\n        return embedding\r\n\r\n    } catch (error) {\r\n        console.error(`‚ùå [RAG] Error generating embedding:`, error)\r\n        throw error\r\n    }\r\n}\r\n\r\n/**\r\n * Searches for relevant messages in chat history using semantic similarity\r\n * @param supabase Supabase client\r\n * @param userId User ID\r\n * @param contactId Contact ID\r\n * @param queryEmbedding Query embedding vector\r\n * @returns Relevant messages\r\n */\r\nasync function searchRelevantMessages(\r\n    supabase: SupabaseClient,\r\n    userId: string,\r\n    contactId: number,\r\n    queryEmbedding: number[]\r\n): Promise<RAGContext['relevantMessages']> {\r\n    try {\r\n        // console.log(`üîç [RAG] Searching relevant messages...`)\r\n\r\n        // Use pgvector similarity search\r\n        const { data: messages, error } = await supabase.rpc('search_similar_messages', {\r\n            query_embedding: queryEmbedding,\r\n            match_threshold: SIMILARITY_THRESHOLD,\r\n            match_count: MAX_CONTEXT_MESSAGES,\r\n            p_user_id: userId,\r\n            p_contact_id: contactId.toString()\r\n        })\r\n\r\n        if (error) {\r\n            console.error(`‚ùå [RAG] Error searching messages:`, error)\r\n            return []\r\n        }\r\n\r\n        if (!messages || messages.length === 0) {\r\n            // console.log(`‚ÑπÔ∏è [RAG] No relevant messages found`)\r\n            return []\r\n        }\r\n\r\n        // console.log(`‚úÖ [RAG] Found ${messages.length} relevant messages`)\r\n        return messages.map((msg: any) => ({\r\n            content: msg.content,\r\n            type: msg.message_type,\r\n            similarity: msg.similarity,\r\n            created_at: msg.created_at\r\n        }))\r\n\r\n    } catch (error) {\r\n        console.error(`‚ùå [RAG] Error in message search:`, error)\r\n        return []\r\n    }\r\n}\r\n\r\n/**\r\n * Searches for relevant products using semantic similarity\r\n * @param supabase Supabase client\r\n * @param userId User ID\r\n * @param queryEmbedding Query embedding vector\r\n * @returns Relevant products\r\n */\r\nasync function searchRelevantProducts(\r\n    supabase: SupabaseClient,\r\n    userId: string,\r\n    queryEmbedding: number[]\r\n): Promise<RAGContext['relevantProducts']> {\r\n    try {\r\n        // console.log(`üîç [RAG] Searching relevant products...`)\r\n\r\n        // Use pgvector similarity search on products\r\n        const { data: products, error } = await supabase.rpc('search_similar_products', {\r\n            query_embedding: queryEmbedding,\r\n            match_threshold: SIMILARITY_THRESHOLD,\r\n            match_count: MAX_PRODUCT_RESULTS,\r\n            p_user_id: userId\r\n        })\r\n\r\n        if (error) {\r\n            console.error(`‚ùå [RAG] Error searching products:`, error)\r\n            return []\r\n        }\r\n\r\n        if (!products || products.length === 0) {\r\n            // console.log(`‚ÑπÔ∏è [RAG] No relevant products found`)\r\n            return []\r\n        }\r\n\r\n        // console.log(`‚úÖ [RAG] Found ${products.length} relevant products`)\r\n        return products.map((prod: any) => ({\r\n            product_name: prod.product_name,\r\n            description: prod.description,\r\n            price: prod.price,\r\n            similarity: prod.similarity\r\n        }))\r\n\r\n    } catch (error) {\r\n        console.error(`‚ùå [RAG] Error in product search:`, error)\r\n        return []\r\n    }\r\n}\r\n\r\n/**\r\n * Searches for relevant knowledge base entries using semantic similarity\r\n * @param supabase Supabase client\r\n * @param userId User ID\r\n * @param queryEmbedding Query embedding vector\r\n * @returns Relevant knowledge entries\r\n */\r\nasync function searchKnowledgeBase(\r\n    supabase: SupabaseClient,\r\n    userId: string,\r\n    queryEmbedding: number[]\r\n): Promise<RAGContext['relevantKnowledge']> {\r\n    try {\r\n        // console.log(`üîç [RAG] Searching knowledge base for user: ${userId}`)\r\n        // console.log(`üîç [RAG] Query embedding length: ${queryEmbedding.length}`)\r\n        // console.log(`üîç [RAG] Threshold: ${SIMILARITY_THRESHOLD}, Match count: 3`)\r\n\r\n        const { data: knowledge, error } = await supabase.rpc('search_knowledge_base', {\r\n            query_embedding: queryEmbedding,\r\n            match_threshold: SIMILARITY_THRESHOLD,\r\n            match_count: 3,\r\n            p_user_id: userId\r\n        })\r\n\r\n        // console.log(`üîç [RAG] RPC call completed. Error:`, error, `Data:`, knowledge)\r\n\r\n        if (error) {\r\n            console.error(`‚ùå [RAG] RPC Error: ${error.message} (Code: ${error.code})`)\r\n            return []\r\n        }\r\n\r\n        if (!knowledge || knowledge.length === 0) {\r\n            console.log(`‚ÑπÔ∏è [RAG] No knowledge found with threshold ${SIMILARITY_THRESHOLD} for user ${userId}`)\r\n            return []\r\n        }\r\n\r\n        console.error(`üîç [RAG] Found ${knowledge.length} knowledge chunks`)\r\n        if (knowledge.length > 0) {\r\n            console.error(`üìÑ [RAG] First chunk: \"${knowledge[0]?.content?.substring(0, 100)}...\" (similarity: ${knowledge[0]?.similarity})`)\r\n        }\r\n        // console.log(`‚úÖ [RAG] Found ${knowledge.length} relevant knowledge chunks`)\r\n        // console.log(`‚úÖ [RAG] First chunk similarity: ${knowledge[0]?.similarity}`)\r\n        return knowledge.map((item: any) => ({\r\n            content: item.content,\r\n            similarity: item.similarity,\r\n            metadata: item.metadata\r\n        }))\r\n\r\n    } catch (error) {\r\n        console.error(`‚ùå [RAG] Error in knowledge base search:`, error)\r\n        return []\r\n    }\r\n}\r\n\r\n/**\r\n * Retrieves relevant context for a user message using RAG\r\n * @param supabase Supabase client\r\n * @param userId User ID\r\n * @param contactId Contact ID\r\n * @param messageText User message text\r\n * @returns RAG context with relevant messages and products\r\n */\r\nexport async function retrieveContext(\r\n    supabase: SupabaseClient,\r\n    userId: string,\r\n    contactId: number,\r\n    messageText: string\r\n): Promise<RAGContext> {\r\n    try {\r\n        // console.log(`\\nüß† [RAG] Retrieving context for message...`)\r\n\r\n        // Generate embedding for the query\r\n        const queryEmbedding = await generateEmbedding(supabase, messageText, userId)\r\n\r\n        // Search in parallel\r\n        const [relevantMessages, relevantProducts, relevantKnowledge] = await Promise.all([\r\n            searchRelevantMessages(supabase, userId, contactId, queryEmbedding),\r\n            searchRelevantProducts(supabase, userId, queryEmbedding),\r\n            searchKnowledgeBase(supabase, userId, queryEmbedding)\r\n        ])\r\n\r\n        // Build context summary\r\n        let contextSummary = ''\r\n\r\n        if (relevantMessages.length > 0) {\r\n            contextSummary += `\\n### Conversaciones Relevantes Anteriores:\\n`\r\n            relevantMessages.forEach((msg, idx) => {\r\n                contextSummary += `${idx + 1}. [${msg.type}] ${msg.content.substring(0, 150)}...\\n`\r\n            })\r\n        }\r\n\r\n        if (relevantProducts.length > 0) {\r\n            contextSummary += `\\n### Productos Relevantes:\\n`\r\n            relevantProducts.forEach((prod, idx) => {\r\n                contextSummary += `${idx + 1}. ${prod.product_name} - $${prod.price}\\n   ${prod.description.substring(0, 100)}...\\n`\r\n            })\r\n        }\r\n\r\n        if (relevantKnowledge.length > 0) {\r\n            contextSummary += `\\n### Base de Conocimiento:\\n`\r\n            relevantKnowledge.forEach((item, idx) => {\r\n                contextSummary += `${idx + 1}. ${item.content}\\n`\r\n            })\r\n        }\r\n\r\n        if (!contextSummary) {\r\n            contextSummary = 'No se encontr√≥ contexto relevante previo.'\r\n        }\r\n\r\n        // console.log(`‚úÖ [RAG] Context retrieved successfully`)\r\n        // console.log(`   - Messages: ${relevantMessages.length}`)\r\n        // console.log(`   - Products: ${relevantProducts.length}`)\r\n        // console.log(`   - Knowledge: ${relevantKnowledge.length}`)\r\n\r\n        return {\r\n            relevantMessages,\r\n            relevantProducts,\r\n            relevantKnowledge,\r\n            contextSummary\r\n        }\r\n\r\n    } catch (error) {\r\n        console.error(`‚ùå [RAG] Error retrieving context:`, error)\r\n        return {\r\n            relevantMessages: [],\r\n            relevantProducts: [],\r\n            relevantKnowledge: [],\r\n            contextSummary: 'Error al recuperar contexto.'\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Formats RAG context for inclusion in AI prompt\r\n * @param context RAG context\r\n * @returns Formatted context string\r\n */\r\nexport function formatContextForPrompt(context: RAGContext): string {\r\n    if (!context.relevantMessages.length && !context.relevantProducts.length && !context.relevantKnowledge.length) {\r\n        return ''\r\n    }\r\n\r\n    let formattedContext = '\\n\\n--- CONTEXTO RELEVANTE ---\\n'\r\n    formattedContext += context.contextSummary\r\n    formattedContext += '\\n--- FIN DEL CONTEXTO ---\\n\\n'\r\n\r\n    return formattedContext\r\n}\r\n"}