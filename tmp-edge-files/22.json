{"name":"utils/tools.ts","content":"/**\r\n * ELINA V5 - Tools Implementation\r\n * \r\n * Implementaci√≥n de las herramientas disponibles para el agente\r\n */\r\n\r\nimport type { SupabaseClient } from 'https://esm.sh/@supabase/supabase-js@2'\r\n\r\n/**\r\n * Genera respuesta de proceso de compra usando LLM con datos disponibles\r\n */\r\nasync function generatePurchaseResponse(\r\n    companyName: string,\r\n    contactData: string\r\n): Promise<string> {\r\n    try {\r\n        const prompt = `Genera una respuesta BREVE (m√°ximo 2-3 l√≠neas) sobre c√≥mo un cliente puede contratar/comprar.\r\n\r\nEmpresa: ${companyName}\r\nCanales disponibles:\r\n${contactData}\r\n\r\nREGLAS CR√çTICAS:\r\n1. M√°ximo 2-3 l√≠neas\r\n2. Incluye SOLO los canales mencionados arriba\r\n3. Tono amigable para WhatsApp\r\n4. NO inventes canales que no existen\r\n5. Formato simple, sin markdown complejo`\r\n\r\n        const response = await fetch('https://api.openai.com/v1/chat/completions', {\r\n            method: 'POST',\r\n            headers: {\r\n                'Authorization': `Bearer ${Deno.env.get('OPENAI_API_KEY')}`,\r\n                'Content-Type': 'application/json'\r\n            },\r\n            body: JSON.stringify({\r\n                model: 'gpt-4o-mini',\r\n                messages: [{ role: 'user', content: prompt }],\r\n                temperature: 0.7,\r\n                max_tokens: 100\r\n            })\r\n        })\r\n\r\n        if (!response.ok) throw new Error('LLM failed')\r\n\r\n        const data = await response.json()\r\n        return data.choices[0]?.message?.content?.trim() || `Cont√°ctanos:\\n${contactData}`\r\n\r\n    } catch (error) {\r\n        console.error('‚ùå [TOOL] Error generating response:', error)\r\n        return `Puedes contactarnos:\\n${contactData}`\r\n    }\r\n}\r\n\r\n/**\r\n * Sistema de cascada inteligente para obtener info de proceso de compra\r\n * Nivel 1: B√∫squeda sem√°ntica en FAQs (RAG)\r\n * Nivel 2: Generaci√≥n din√°mica con LLM usando datos del perfil\r\n * Nivel 3: Formato simple de datos disponibles\r\n * Nivel 4: Mensaje gen√©rico profesional\r\n */\r\nasync function fetchPurchaseProcessInfo(\r\n    supabase: SupabaseClient,\r\n    userId: string\r\n): Promise<string | null> {\r\n    try {\r\n        // NIVEL 1: B√∫squeda sem√°ntica en knowledge_base usando RAG\r\n        console.log(`üîç [PURCHASE_INFO] Nivel 1: Buscando en FAQs con RAG...`)\r\n\r\n        const { retrieveContext } = await import('./rag-system.ts')\r\n        const purchaseQuery = \"¬øC√≥mo puedo contratar, comprar o adquirir este producto o servicio? ¬øD√≥nde lo compro?\"\r\n\r\n        const ragContext = await retrieveContext(supabase, userId, 0, purchaseQuery)\r\n\r\n        if (ragContext.relevantKnowledge && ragContext.relevantKnowledge.length > 0) {\r\n            const topMatch = ragContext.relevantKnowledge[0]\r\n            // Umbral de confianza: 0.35 es suficientemente similar\r\n            if (topMatch.similarity >= 0.35) {\r\n                console.log(`‚úÖ [PURCHASE_INFO] FAQ encontrada (similarity: ${topMatch.similarity})`)\r\n                return `\\n\\nüìã **INFORMACI√ìN IMPORTANTE:**\\n${topMatch.content}`\r\n            }\r\n            console.log(`‚ö†Ô∏è [PURCHASE_INFO] FAQ similarity baja (${topMatch.similarity}), continuando...`)\r\n        }\r\n\r\n        // NIVEL 2: No hay FAQs relevantes - Buscar datos del perfil\r\n        console.log(`üîç [PURCHASE_INFO] Nivel 2: Obteniendo datos del perfil...`)\r\n\r\n        const { data: profile } = await supabase\r\n            .from('profiles')\r\n            .select('website, business_phone, business_address, social_media, company_name')\r\n            .eq('id', userId)\r\n            .single()\r\n\r\n        if (!profile) {\r\n            console.log(`‚ö†Ô∏è [PURCHASE_INFO] No se encontr√≥ perfil`)\r\n            return null\r\n        }\r\n\r\n        // Construir informaci√≥n de contacto disponible\r\n        const contactChannels: string[] = []\r\n        if (profile.website) contactChannels.push(`üåê Sitio web: ${profile.website}`)\r\n        if (profile.business_phone) contactChannels.push(`üìû Tel√©fono: ${profile.business_phone}`)\r\n        if (profile.business_address) contactChannels.push(`üìç Direcci√≥n: ${profile.business_address}`)\r\n        if (profile.social_media?.whatsapp) contactChannels.push(`üí¨ WhatsApp: ${profile.social_media.whatsapp}`)\r\n        if (profile.social_media?.instagram) contactChannels.push(`üì± Instagram: @${profile.social_media.instagram}`)\r\n        if (profile.social_media?.facebook) contactChannels.push(`üë• Facebook: ${profile.social_media.facebook}`)\r\n\r\n        if (contactChannels.length === 0) {\r\n            // NIVEL 4: No hay datos - Mensaje gen√©rico profesional\r\n            console.log(`‚ö†Ô∏è [PURCHASE_INFO] Nivel 4: Sin datos de contacto, mensaje gen√©rico`)\r\n            return '\\n\\nüìã Cont√°ctanos directamente para m√°s informaci√≥n sobre c√≥mo adquirir este producto o servicio.'\r\n        }\r\n\r\n        // NIVEL 2B: Generar respuesta inteligente con LLM\r\n        console.log(`ü§ñ [PURCHASE_INFO] Nivel 2B: Generando respuesta con LLM...`)\r\n        const contactData = contactChannels.join('\\n')\r\n        const companyName = profile.company_name || 'nuestra empresa'\r\n\r\n        const generatedResponse = await generatePurchaseResponse(companyName, contactData)\r\n        console.log(`‚úÖ [PURCHASE_INFO] Respuesta generada exitosamente`)\r\n\r\n        return `\\n\\nüìã **INFORMACI√ìN IMPORTANTE:**\\n${generatedResponse}`\r\n\r\n    } catch (error) {\r\n        console.error(`‚ùå [TOOL] Error fetching purchase info:`, error)\r\n        // NIVEL 3: Fallback en caso de error\r\n        return '\\n\\nüìã Para adquirir este producto, cont√°ctanos directamente.'\r\n    }\r\n}\r\n\r\n/**\r\n * Busca productos por query\r\n */\r\nexport async function buscarProductos(\r\n    supabase: SupabaseClient,\r\n    userId: string,\r\n    query: string,\r\n    limit: number = 5,\r\n    originalMessage?: string // Nuevo par√°metro para detectar intent de compra\r\n): Promise<any> {\r\n    console.log(`üîç [TOOL] Searching products: \"${query}\"`)\r\n\r\n    // Normalizaci√≥n de queries gen√©ricos (con posibles typos o caracteres extra)\r\n    // Si el usuario pone \"que vendes_\", \"catalogo\", \"lista\", lo tratamos como vac√≠o para mostrar todo.\r\n    const genericKeywords = ['que vendes', 'qu√© vendes', 'que tienes', 'qu√© tienes', 'catalogo', 'cat√°logo', 'productos', 'lista', 'precio', 'precios']\r\n    const normalizedQuery = query.toLowerCase().replace(/[^\\w\\s√±√°√©√≠√≥√∫]/g, '').trim() // Quitar caracteres raros como \"_\"\r\n\r\n    // Detectar si el usuario pregunta espec√≠ficamente por SERVICIOS\r\n    const serviceKeywords = ['servicio', 'servicios', 'cita', 'citas', 'que servicios', 'qu√© servicios']\r\n    const isAskingForServices = serviceKeywords.some(k => normalizedQuery.includes(k))\r\n\r\n    let effectiveQuery = query\r\n    if (genericKeywords.some(k => normalizedQuery.includes(k)) || normalizedQuery.length < 3 || isAskingForServices) {\r\n        effectiveQuery = '' // Forzar modo \"ver todo\" para keywords gen√©ricos O servicios\r\n    }\r\n\r\n    // CASO 1: Query vac√≠o -> Mostrar cat√°logo general (sin clasificar)\r\n    if (!effectiveQuery || effectiveQuery.trim() === '') {\r\n        // Si pregunta por servicios, filtrar solo servicios\r\n        if (isAskingForServices) {\r\n            const { data, error } = await supabase\r\n                .from('products')\r\n                .select('id, product_name, sku, price, stock, description, media_url, product_type, benefits, usage_instructions, faq')\r\n                .eq('user_id', userId)\r\n                .eq('product_type', 'service')\r\n                .order('created_at', { ascending: false })\r\n                .limit(limit)\r\n\r\n            if (error) {\r\n                console.error(`‚ùå [TOOL] Error fetching services:`, error)\r\n                return { status: \"ERROR\", message: \"Error consultando servicios.\" }\r\n            }\r\n\r\n            return {\r\n                status: \"SUCCESS\",\r\n                message: \"Aqu√≠ est√°n los servicios disponibles.\",\r\n                exact_match_found: true,\r\n                exact_matches: data?.map(p => {\r\n                    const benefits = p.benefits ? `\\n‚ú® Benefits: ${p.benefits}` : '';\r\n                    const usage = p.usage_instructions ? `\\nüìù Usage: ${p.usage_instructions}` : '';\r\n                    const faqContent = p.faq?.content ? `\\n‚ùì FAQ: ${p.faq.content}` : '';\r\n                    return {\r\n                        ...p,\r\n                        formatting_hint: `üõçÔ∏è *${p.product_name}* ‚Äî $${p.price}\\nüîπ ${p.description || ''}${benefits}${usage}${faqContent}\\n\\n`\r\n                    }\r\n                }) || [],\r\n                has_alternatives: false,\r\n                suggested_alternatives: []\r\n            }\r\n        } else {\r\n            // Modo MIXTO: Traer productos y servicios por separado para mostrar variedad\r\n            // 1. Productos F√≠sicos\r\n            const { data: products } = await supabase\r\n                .from('products')\r\n                .select('id, product_name, sku, price, stock, description, media_url, product_type, benefits, usage_instructions, faq')\r\n                .eq('user_id', userId)\r\n                .neq('product_type', 'service') // Excluir servicios\r\n                .order('created_at', { ascending: false })\r\n                .limit(3)\r\n\r\n            // 2. Servicios\r\n            const { data: services } = await supabase\r\n                .from('products')\r\n                .select('id, product_name, sku, price, stock, description, media_url, product_type, benefits, usage_instructions, faq')\r\n                .eq('user_id', userId)\r\n                .eq('product_type', 'service') // Solo servicios\r\n                .order('created_at', { ascending: false })\r\n                .limit(3)\r\n\r\n            const mixedData = [...(products || []), ...(services || [])]\r\n\r\n            return {\r\n                status: \"SUCCESS\",\r\n                message: \"Aqu√≠ tienes una selecci√≥n de nuestros productos y servicios.\",\r\n                exact_match_found: true,\r\n                exact_matches: mixedData.map(p => {\r\n                    const benefits = p.benefits ? `\\n‚ú® Benefits: ${p.benefits}` : '';\r\n                    const usage = p.usage_instructions ? `\\nüìù Usage: ${p.usage_instructions}` : '';\r\n                    const faqContent = p.faq?.content ? `\\n‚ùì FAQ: ${p.faq.content}` : '';\r\n\r\n                    return {\r\n                        ...p,\r\n                        formatting_hint: p.product_type === 'service'\r\n                            ? `üõçÔ∏è *${p.product_name}* ‚Äî $${p.price}\\nüîπ ${p.description || ''}${benefits}${usage}${faqContent}\\n\\n`\r\n                            : `üõçÔ∏è *${p.product_name}* ‚Äî $${p.price}\\nüîπ ${p.description || ''}\\n\\n` // Use same format for physical products\r\n                    }\r\n                }),\r\n                has_alternatives: false,\r\n                suggested_alternatives: []\r\n            }\r\n        }\r\n    }\r\n\r\n    // CASO 2: B√∫squeda Vectorial / Fulltext\r\n    const { data, error } = await supabase.rpc('search_products_fulltext', {\r\n        p_user_id: userId,\r\n        p_query: effectiveQuery, // Usar la query normalizada/efectiva\r\n        p_limit: limit\r\n    })\r\n\r\n    if (error) {\r\n        console.error(`‚ùå [TOOL] Error searching products:`, error)\r\n        return { status: \"ERROR\", message: \"Error en la b√∫squeda.\" }\r\n    }\r\n\r\n    const results = data || []\r\n\r\n    // Clasificaci√≥n por fidelidad (L√≥gica Proactiva de n8n)\r\n    const highConfidence = results\r\n\r\n    if (highConfidence.length === 0) {\r\n        // üìä Log b√∫squeda fallida para analytics (non-blocking)\r\n        supabase.from('product_search_misses').insert({\r\n            user_id: userId,\r\n            query: query,\r\n            original_message: originalMessage,\r\n            timestamp: new Date().toISOString()\r\n        }).then(() => {\r\n            console.log(`üìä [ANALYTICS] Search miss logged: \"${query}\"`)\r\n        }).catch((err: any) => {\r\n            console.error(`‚ùå [ANALYTICS] Failed to log search miss:`, err)\r\n        })\r\n\r\n        return {\r\n            status: \"NOT_FOUND\",\r\n            message: `No encontr√© productos que coincidan con '${query}'.`\r\n        }\r\n    }\r\n\r\n    // üéØ DETECCI√ìN AUTOM√ÅTICA: Si el mensaje original contiene palabras de compra/contrataci√≥n\r\n    // autom√°ticamente buscamos y agregamos info del proceso de compra\r\n    let purchaseInfo = null\r\n    if (originalMessage) {\r\n        const purchaseKeywords = ['contratar', 'comprar', 'adquirir', 'obtener', 'conseguir', 'me ayuda']\r\n        const hasPurchaseIntent = purchaseKeywords.some(kw =>\r\n            originalMessage.toLowerCase().includes(kw)\r\n        )\r\n\r\n        if (hasPurchaseIntent) {\r\n            console.log(`üõí [TOOL] Purchase intent detected, fetching process info...`)\r\n            purchaseInfo = await fetchPurchaseProcessInfo(supabase, userId)\r\n            if (purchaseInfo) {\r\n                console.log(`‚úÖ [TOOL] Purchase process info added automatically`)\r\n            }\r\n        }\r\n    }\r\n\r\n    // Estructura \"Anti-Alucinaci√≥n\" con Urgencia/Escasez\r\n    const result: any = {\r\n        status: \"SUCCESS\",\r\n        message: `Encontr√© ${highConfidence.length} coincidencias para '${query}'.`,\r\n        exact_match_found: highConfidence.length > 0,\r\n        exact_matches: highConfidence.map(r => {\r\n            let urgencyNote = ''\r\n\r\n            // üî• URGENCIA: Stock bajo (√∫ltimas unidades)\r\n            if (r.stock !== null && r.stock > 0 && r.stock <= 5) {\r\n                urgencyNote = `\\n‚ö†Ô∏è ¬°√öltimas ${r.stock} unidades disponibles!`\r\n            }\r\n\r\n            // üî• URGENCIA: Sin stock (agotado)\r\n            if (r.stock !== null && r.stock === 0) {\r\n                urgencyNote = `\\n‚ùå Agotado temporalmente`\r\n            }\r\n\r\n            return {\r\n                id: r.id,\r\n                name: r.product_name,\r\n                price: r.price,\r\n                stock: r.stock,\r\n                description: r.description,\r\n                media_url: r.media_url, // ‚úÖ ADDED: Include media_url for automatic media sending\r\n                enhanced_description: r.enhanced_description,\r\n                faq: r.faq,\r\n                benefits: r.benefits,\r\n                usage_instructions: r.usage_instructions,\r\n                formatting_hint: `üõçÔ∏è *${r.product_name}* ‚Äî $${r.price}${urgencyNote}\\nüîπ ${r.description || ''}\\n\\n`\r\n            }\r\n        }),\r\n        has_alternatives: false,\r\n        suggested_alternatives: []\r\n    }\r\n\r\n    // Si encontramos info de proceso de compra, agregarla al resultado\r\n    if (purchaseInfo) {\r\n        result.purchase_process_info = purchaseInfo\r\n        result.message += ' ' + purchaseInfo\r\n    }\r\n\r\n    return result\r\n}\r\n\r\n/**\r\n * Consulta disponibilidad de citas\r\n */\r\nexport async function consultarDisponibilidad(\r\n    supabase: SupabaseClient,\r\n    userId: string,\r\n    date?: string,\r\n    slug?: string // Propiedad opcional para link\r\n): Promise<any> {\r\n    console.log(`üìÖ [TOOL] Checking availability for date: ${date || 'next 7 days'}`)\r\n\r\n    const { getAvailableSlots, formatAppointmentContext } = await import('./appointment-manager.ts')\r\n    const slots = await getAvailableSlots(userId, 7)\r\n\r\n    return {\r\n        available: slots.length > 0,\r\n        // Proporcionar contexto formateado para que el LLM lo use directamente\r\n        formatted_response: formatAppointmentContext(slots, slug),\r\n        // Mantener slots crudos por si el LLM necesita datos estructurados precisos\r\n        raw_slots: slots.map(slot => ({\r\n            start_time: slot.start_time,\r\n            service_name: slot.service_name,\r\n            duration_minutes: slot.duration_minutes\r\n        }))\r\n    }\r\n}\r\n\r\n/**\r\n * Agenda una cita\r\n */\r\nexport async function agendarCita(\r\n    supabase: SupabaseClient,\r\n    userId: string,\r\n    contactId: number,\r\n    date: string,\r\n    time: string,\r\n    serviceId?: number,\r\n    notes?: string,\r\n    conversationState?: any  // ‚Üê Nuevo par√°metro para acceder al estado\r\n): Promise<any> {\r\n    console.log(`üìÖ [TOOL] Creating appointment...`)\r\n\r\n    // Si no se proporciona serviceId, intentar detectarlo del contexto\r\n    let finalServiceId = serviceId\r\n\r\n    if (!finalServiceId) {\r\n        console.log(`üîç [TOOL] No service_id provided, searching conversation context...`)\r\n\r\n        // 1. Revisar si hay un servicio en el estado de conversaci√≥n\r\n        if (conversationState?.potentialService?.id) {\r\n            finalServiceId = conversationState.potentialService.id\r\n            console.log(`‚úÖ [TOOL] Found service in conversation state: ${conversationState.potentialService.name} (${finalServiceId})`)\r\n        }\r\n\r\n        // 2. Si no hay en el estado, buscar en mensajes recientes (√∫ltimas 24h)\r\n        if (!finalServiceId) {\r\n            const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString()\r\n            const { data: recentMessages } = await supabase\r\n                .from('chat_history')\r\n                .select('message_text')\r\n                .eq('contact_id', contactId)\r\n                .gt('created_at', oneDayAgo)\r\n                .order('created_at', { ascending: false })\r\n                .limit(10)\r\n\r\n            if (recentMessages && recentMessages.length > 0) {\r\n                // Buscar menciones de servicios en los mensajes\r\n                const { data: services } = await supabase\r\n                    .from('products')\r\n                    .select('id, product_name')\r\n                    .eq('user_id', userId)\r\n                    .eq('product_type', 'service')\r\n\r\n                if (services) {\r\n                    // Buscar si alg√∫n servicio fue mencionado\r\n                    for (const service of services) {\r\n                        const serviceName = service.product_name.toLowerCase()\r\n                        const mentioned = recentMessages.some(msg =>\r\n                            msg.message_text?.toLowerCase().includes(serviceName)\r\n                        )\r\n                        if (mentioned) {\r\n                            finalServiceId = service.id\r\n                            console.log(`‚úÖ [TOOL] Found service mentioned in history: ${service.product_name} (${finalServiceId})`)\r\n                            break\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // 3. Si a√∫n no hay, usar el primer servicio disponible\r\n        if (!finalServiceId) {\r\n            console.log(`üîç [TOOL] No service found in context, fetching default service...`)\r\n            const { data: services } = await supabase\r\n                .from('products')\r\n                .select('id')\r\n                .eq('user_id', userId)\r\n                .eq('product_type', 'service')\r\n                .limit(1)\r\n                .single()\r\n\r\n            if (services) {\r\n                finalServiceId = services.id\r\n                console.log(`‚úÖ [TOOL] Using default service: ${finalServiceId}`)\r\n            } else {\r\n                return {\r\n                    success: false,\r\n                    error: 'No hay servicios disponibles para agendar'\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Combinar fecha y hora en ISO 8601\r\n    // IMPORTANTE: La fecha y hora que recibimos (ej: \"2026-02-12\", \"15:00\")\r\n    // son en la ZONA HORARIA DEL USUARIO/EMPRESA.\r\n    // Supabase espera UTC. Debemos convertir.\r\n\r\n    // 1. Obtener configuraci√≥n para saber timezone\r\n    const { getAppointmentSettings } = await import('./appointment-manager.ts')\r\n    const settings = await getAppointmentSettings(supabase, userId)\r\n    const timezone = settings?.working_hours?.timezone || 'America/Mexico_City'\r\n\r\n    // 2. Crear fecha en esa zona horaria\r\n    // \"2026-02-12T15:00:00\" -> Interpretar como hora CDMX\r\n    // NOTA: Deno deploy no siempre tiene feriados o timezones complejos nativos,\r\n    // pero podemos usar un hack simple si asumimos offsets fijos o usamos una librer√≠a si est√° disponible.\r\n    // Por ahora, asumiremos que el servidor corre en UTC y haremos el offset manual\r\n    // para America/Mexico_City (UTC-6 en invierno, UTC-5 en verano - aunque MX ya no cambia horario en la mayor√≠a)\r\n    // Asumiremos UTC-6 fijo para CDMX por simplicidad si no hay librer√≠a, \r\n    // PERO lo ideal es dejar que la base de datos maneje la inserci√≥n si pudi√©ramos pasar \"AT TOP TIME ZONE\".\r\n    // \r\n    // Mejor enfoque: Construir la fecha con el offset expl√≠cito.\r\n    // CDMX es UTC-6.\r\n\r\n    const targetTime = new Date(`${date}T${time}:00`)\r\n    // Asumiendo que targetTime se cre√≥ en UTC (por defecto en Deno Deploy)\r\n    // Le sumamos 6 horas para \"cancelar\" el hecho de que era local y convertirlo a UTC real\r\n    // Ejemplo: Usuario quiere 15:00 CDMX.\r\n    // UTC equivalente: 21:00 UTC.\r\n    // new Date(\"2026-02-12T15:00:00\") -> crea 15:00 UTC (incorrecto, esto ser√≠a 9:00 AM CDMX)\r\n    // Queremos enviar 21:00 UTC.\r\n\r\n    // Soluci√≥n robusta sin librer√≠as externas pesadas:\r\n    // Usar el offset manual temporalmente.\r\n    const offsetHours = 6 // UTC-6 para M√©xico Central (Est√°ndar)\r\n    const utcDate = new Date(targetTime.getTime() + (offsetHours * 60 * 60 * 1000))\r\n    const startTime = utcDate.toISOString()\r\n\r\n    console.log(`‚è∞ [TOOL] Time conversion:`)\r\n    console.log(`   Input (Local): ${date} ${time}`)\r\n    console.log(`   Timezone: ${timezone} (Assuming UTC-6)`)\r\n    console.log(`   Output (UTC): ${startTime}`)\r\n\r\n    const { createAppointment } = await import('./appointment-manager.ts')\r\n    const { sendMessage } = await import('./evolution.ts')\r\n\r\n    // Obtener tel√©fono del contacto\r\n    const { data: contact } = await supabase\r\n        .from('contacts')\r\n        .select('phone_number')\r\n        .eq('id', contactId)\r\n        .single()\r\n\r\n    if (!contact) {\r\n        throw new Error('Contact not found')\r\n    }\r\n\r\n    // Crear funci√≥n de env√≠o de mensajes\r\n    const sendMessageFn = async (remoteJid: string, text: string) => {\r\n        // Esta funci√≥n ser√° proporcionada por el contexto\r\n        console.log(`üì§ [TOOL] Would send message to ${remoteJid}`)\r\n    }\r\n\r\n    const result = await createAppointment(\r\n        supabase,\r\n        {\r\n            userId,\r\n            contactId,\r\n            serviceId: finalServiceId!, // Non-null assertion: ya verificamos arriba\r\n            startTime,\r\n            notes\r\n        },\r\n        sendMessageFn,\r\n        contact.phone_number\r\n    )\r\n\r\n\r\n    return result\r\n}\r\n\r\n/**\r\n * Consulta las citas del usuario\r\n */\r\nexport async function consultarMisCitas(\r\n    supabase: SupabaseClient,\r\n    userId: string,\r\n    contactId: number\r\n): Promise<any> {\r\n    console.log(`üìÖ [TOOL] Fetching appointments for contact ${contactId}`)\r\n\r\n    const now = new Date().toISOString()\r\n\r\n    const { data: appointments, error } = await supabase\r\n        .from('meetings')\r\n        .select(`\r\n            id,\r\n            start_time,\r\n            end_time,\r\n            status,\r\n            notes,\r\n            summary,\r\n            products:product_id (\r\n                product_name,\r\n                service_duration_minutes\r\n            )\r\n        `)\r\n        .eq('user_id', userId)\r\n        .eq('contact_id', contactId)\r\n        .gte('start_time', now)  // Solo citas futuras\r\n        .order('start_time', { ascending: true })\r\n        .limit(10)\r\n\r\n    if (error) {\r\n        console.error(`‚ùå [TOOL] Error fetching appointments:`, error)\r\n        return {\r\n            success: false,\r\n            error: error.message\r\n        }\r\n    }\r\n\r\n    if (!appointments || appointments.length === 0) {\r\n        return {\r\n            success: true,\r\n            appointments: [],\r\n            message: 'No tienes citas programadas'\r\n        }\r\n    }\r\n\r\n    console.log(`‚úÖ [TOOL] Found ${appointments.length} appointment(s)`)\r\n\r\n    return {\r\n        success: true,\r\n        appointments: appointments.map(apt => {\r\n            const date = new Date(apt.start_time)\r\n            const formattedTime = date.toLocaleString('es-MX', {\r\n                timeZone: 'America/Mexico_City',\r\n                weekday: 'long',\r\n                year: 'numeric',\r\n                month: 'long',\r\n                day: 'numeric',\r\n                hour: '2-digit',\r\n                minute: '2-digit',\r\n                hour12: true\r\n            })\r\n\r\n            return {\r\n                id: apt.id,\r\n                serviceName: apt.products?.product_name || 'Servicio',\r\n                startTime: apt.start_time, // Keep ISO for debugging\r\n                formattedTime: formattedTime, // For LLM to read correct local time\r\n                endTime: apt.end_time,\r\n                status: apt.status,\r\n                notes: apt.notes,\r\n                isAIBooked: apt.summary === 'Cita Agendada por IA'\r\n            }\r\n        })\r\n    }\r\n}\r\n\r\n/**\r\n * Modifica/reprograma una cita existente\r\n */\r\nexport async function modificarCita(\r\n    supabase: SupabaseClient,\r\n    userId: string,\r\n    contactId: number,\r\n    appointmentId: number,\r\n    newDate?: string,\r\n    newTime?: string\r\n): Promise<any> {\r\n    const id = Number(appointmentId)\r\n    console.log(`üìÖ [TOOL] Modifying appointment #${id}`)\r\n\r\n    // Obtener la cita actual\r\n    const { data: currentAppointment, error: fetchError } = await supabase\r\n        .from('meetings')\r\n        .select('*, products:product_id(service_duration_minutes)')\r\n        .eq('id', id)\r\n        .eq('user_id', userId)\r\n        .eq('contact_id', contactId)\r\n        .single()\r\n\r\n    if (fetchError || !currentAppointment) {\r\n        console.error(`‚ùå [TOOL] Appointment not found:`, fetchError)\r\n        return {\r\n            success: false,\r\n            error: 'No se encontr√≥ la cita'\r\n        }\r\n    }\r\n\r\n    // Calcular nuevo start_time\r\n    let newStartTime: string\r\n    const offsetHours = 6 // UTC-6 para M√©xico\r\n\r\n    if (newDate && newTime) {\r\n        // Ambos proporcionados\r\n        const targetTime = new Date(`${newDate}T${newTime}:00`)\r\n        const utcDate = new Date(targetTime.getTime() + (offsetHours * 60 * 60 * 1000))\r\n        newStartTime = utcDate.toISOString()\r\n    } else if (newDate) {\r\n        // Solo fecha nueva, mantener hora original\r\n        const currentStart = new Date(currentAppointment.start_time)\r\n        // Adjust back to local to extract time components accurately\r\n        const localCurrent = new Date(currentStart.getTime() - (offsetHours * 60 * 60 * 1000))\r\n        const h = localCurrent.getUTCHours().toString().padStart(2, '0')\r\n        const m = localCurrent.getUTCMinutes().toString().padStart(2, '0')\r\n\r\n        const targetTime = new Date(`${newDate}T${h}:${m}:00`)\r\n        const utcDate = new Date(targetTime.getTime() + (offsetHours * 60 * 60 * 1000))\r\n        newStartTime = utcDate.toISOString()\r\n    } else if (newTime) {\r\n        // Solo hora nueva, mantener fecha original\r\n        const currentStart = new Date(currentAppointment.start_time)\r\n        const localCurrent = new Date(currentStart.getTime() - (offsetHours * 60 * 60 * 1000))\r\n        const y = localCurrent.getUTCFullYear()\r\n        const mo = (localCurrent.getUTCMonth() + 1).toString().padStart(2, '0')\r\n        const d = localCurrent.getUTCDate().toString().padStart(2, '0')\r\n\r\n        const targetTime = new Date(`${y}-${mo}-${d}T${newTime}:00`)\r\n        const utcDate = new Date(targetTime.getTime() + (offsetHours * 60 * 60 * 1000))\r\n        newStartTime = utcDate.toISOString()\r\n    } else {\r\n        return {\r\n            success: false,\r\n            error: 'Debes proporcionar al menos una nueva fecha o hora'\r\n        }\r\n    }\r\n\r\n    // Calcular nuevo end_time\r\n    const durationMinutes = currentAppointment.products?.service_duration_minutes || 60\r\n    const newEndTime = new Date(new Date(newStartTime).getTime() + durationMinutes * 60 * 1000).toISOString()\r\n\r\n    // Actualizar la cita\r\n    const { data: updatedAppointment, error: updateError } = await supabase\r\n        .from('meetings')\r\n        .update({\r\n            start_time: newStartTime,\r\n            end_time: newEndTime,\r\n            notes: currentAppointment.notes ? `${currentAppointment.notes} (Reprogramada)` : 'Reprogramada'\r\n        })\r\n        .eq('id', appointmentId)\r\n        .select()\r\n        .single()\r\n\r\n    if (updateError) {\r\n        console.error(`‚ùå [TOOL] Error updating appointment:`, updateError)\r\n        return {\r\n            success: false,\r\n            error: updateError.message\r\n        }\r\n    }\r\n\r\n    console.log(`‚úÖ [TOOL] Appointment #${appointmentId} rescheduled`)\r\n\r\n    // Format times for LLM response\r\n    const formatTime = (isoString: string) => {\r\n        return new Date(isoString).toLocaleString('es-MX', {\r\n            timeZone: 'America/Mexico_City',\r\n            weekday: 'long',\r\n            year: 'numeric',\r\n            month: 'long',\r\n            day: 'numeric',\r\n            hour: '2-digit',\r\n            minute: '2-digit',\r\n            hour12: true\r\n        })\r\n    }\r\n\r\n    return {\r\n        success: true,\r\n        appointmentId: updatedAppointment.id,\r\n        newStartTime: newStartTime,\r\n        newEndTime: newEndTime,\r\n        formattedStartTime: formatTime(newStartTime),\r\n        formattedEndTime: formatTime(newEndTime)\r\n    }\r\n}\r\n\r\n/**\r\n * Consulta promociones activas\r\n * Si no hay promociones, sugiere productos destacados de manera inteligente\r\n */\r\nexport async function consultarPromociones(\r\n    supabase: SupabaseClient,\r\n    userId: string\r\n): Promise<any> {\r\n    console.log(`üéÅ [TOOL] Consulting active promotions...`)\r\n\r\n    try {\r\n        // 1. Buscar promociones activas\r\n        const now = new Date().toISOString()\r\n\r\n        const { data: promotions, error: promoError } = await supabase\r\n            .from('smart_promotions')\r\n            .select('id, title, description, benefits, call_to_action, discount, image_urls')\r\n            .eq('user_id', userId)\r\n            .eq('is_active', true)\r\n            .or(`no_schedule.eq.true,and(start_at.lte.${now},end_at.gte.${now})`)\r\n            .limit(5)\r\n\r\n        if (promoError) {\r\n            console.error(`‚ùå [TOOL] Error fetching promotions:`, promoError)\r\n        }\r\n\r\n        // 2. Si HAY promociones, devolverlas\r\n        if (promotions && promotions.length > 0) {\r\n            console.log(`‚úÖ [TOOL] Found ${promotions.length} active promotion(s)`)\r\n\r\n            const formattedPromos = promotions.map((p: any) => ({\r\n                title: p.title,\r\n                description: p.description,\r\n                benefits: p.benefits,\r\n                callToAction: p.call_to_action,\r\n                discount: p.discount,\r\n                imageUrls: p.image_urls\r\n            }))\r\n\r\n            return {\r\n                hasPromotions: true,\r\n                promotions: formattedPromos,\r\n                message: `Tenemos ${promotions.length} promoci√≥n${promotions.length > 1 ? 'es' : ''} activa${promotions.length > 1 ? 's' : ''} en este momento.`\r\n            }\r\n        }\r\n\r\n        // 3. NO HAY PROMOCIONES - Buscar productos para sugerir\r\n        console.log(`‚ÑπÔ∏è [TOOL] No active promotions found - fetching featured products...`)\r\n\r\n        const productSearch = await buscarProductos(supabase, userId, '', 3) // Buscar 3 productos cualquiera\r\n\r\n        // 4. Si hay productos, sugerirlos como alternativa\r\n        if (productSearch.status === 'SUCCESS' && productSearch.exact_matches && productSearch.exact_matches.length > 0) {\r\n            console.log(`‚úÖ [TOOL] Suggesting ${productSearch.exact_matches.length} products as alternative`)\r\n\r\n            const products = productSearch.exact_matches.slice(0, 3)\r\n\r\n            return {\r\n                hasPromotions: false,\r\n                promotions: [],\r\n                hasSuggestedProducts: true,\r\n                suggestedProducts: products,\r\n                message: `En este momento no tenemos promociones activas, pero aqu√≠ te muestro algunos de nuestros productos que podr√≠an interesarte:`\r\n            }\r\n        }\r\n\r\n        // 5. No hay ni promociones ni productos\r\n        console.log(`‚ö†Ô∏è [TOOL] No promotions or products available`)\r\n\r\n        return {\r\n            hasPromotions: false,\r\n            promotions: [],\r\n            hasSuggestedProducts: false,\r\n            suggestedProducts: [],\r\n            message: `En este momento no tenemos promociones activas. Si necesitas algo espec√≠fico, con gusto te ayudo a buscarlo.`\r\n        }\r\n\r\n    } catch (error) {\r\n        console.error(`‚ùå [TOOL] Error in consultarPromociones:`, error)\r\n        return {\r\n            hasPromotions: false,\r\n            promotions: [],\r\n            error: error instanceof Error ? error.message : 'Error consultando promociones'\r\n        }\r\n    }\r\n}\r\n"}