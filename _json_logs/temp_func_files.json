{
    "pcm/tools.ts":  {
                         "value":  "\r\nimport { SupabaseClient } from \u0027https://esm.sh/@supabase/supabase-js@2\u0027\r\n\r\nexport const toolsDefinition = [\r\n    {\r\n        type: \u0027function\u0027,\r\n        function: {\r\n            name: \u0027search_products\u0027,\r\n            description: \u0027Buscar productos en el inventario por nombre, cÃ³digo, SKU o descripciÃ³n. Ãšsala siempre que el usuario pregunte por precios, stock o informaciÃ³n de un producto.\u0027,\r\n            parameters: {\r\n                type: \u0027object\u0027,\r\n                properties: {\r\n                    query: {\r\n                        type: \u0027string\u0027,\r\n                        description: \u0027TÃ©rmino de bÃºsqueda (nombre, modelo, sku, etc). Ej: \"toner m477\", \"impresora canon\"\u0027,\r\n                    },\r\n                },\r\n                required: [\u0027query\u0027],\r\n            },\r\n        },\r\n    },\r\n    {\r\n        type: \u0027function\u0027,\r\n        function: {\r\n            name: \u0027create_appointment\u0027,\r\n            description: \u0027Registrar formalmente una cita en la agenda una vez que el cliente ha confirmado el horario. DEBES usar esta herramienta cuando el cliente confirme explÃ­citamente un horario propuesto.\u0027,\r\n            parameters: {\r\n                type: \u0027object\u0027,\r\n                properties: {\r\n                    start_time: {\r\n                        type: \u0027string\u0027,\r\n                        description: \u0027Fecha y hora de inicio en formato ISO 8601 (Ej: 2026-02-03T15:30:00).\u0027,\r\n                    },\r\n                    service_id: {\r\n                        type: \u0027number\u0027,\r\n                        description: \u0027ID del servicio extraÃ­do del placeholder [NOMBRE:ID]. Ejemplo: para [Serive1:8878] usar 8878\u0027,\r\n                    },\r\n                    notes: {\r\n                        type: \u0027string\u0027,\r\n                        description: \u0027Notas adicionales.\u0027,\r\n                    },\r\n                },\r\n                required: [\u0027start_time\u0027, \u0027service_id\u0027],\r\n            },\r\n        },\r\n    },\r\n]\r\n\r\nexport async function searchProducts(\r\n    supabase: SupabaseClient,\r\n    userId: string,\r\n    query: string\r\n) {\r\n    // Call the existing search-products-hybrid function\r\n    // We use the public URL or internal invoke\r\n\r\n    const functionUrl = `${Deno.env.get(\u0027SUPABASE_URL\u0027)}/functions/v1/search-products-hybrid`\r\n\r\n    try {\r\n        const response = await fetch(functionUrl, {\r\n            method: \u0027POST\u0027,\r\n            headers: {\r\n                \u0027Authorization\u0027: `Bearer ${Deno.env.get(\u0027SUPABASE_SERVICE_ROLE_KEY\u0027)}`,\r\n                \u0027Content-Type\u0027: \u0027application/json\u0027,\r\n            },\r\n            body: JSON.stringify({\r\n                user_id: userId,\r\n                query: query,\r\n                limit: 5 // Return top 5\r\n            }),\r\n        })\r\n\r\n        if (!response.ok) {\r\n            console.error(\u0027Error invoking search-products-hybrid:\u0027, await response.text())\r\n            return \"Error buscando productos.\"\r\n        }\r\n\r\n        const data = await response.json()\r\n        // Format for LLM to save tokens\r\n        if (!data.products || data.products.length === 0) {\r\n            return \"No se encontraron productos con ese tÃ©rmino.\"\r\n        }\r\n\r\n        return JSON.stringify(data.products.map((p: any) =\u003e ({\r\n            id: p.id,\r\n            name: p.product_name,\r\n            price: p.price,\r\n            stock: p.stock,\r\n            description: p.description,\r\n            url: p.media_url,\r\n            score: p.relevance_score // Optional, maybe helpful for LLM to know confidence\r\n        })))\r\n\r\n    } catch (err) {\r\n        console.error(\u0027Exception in searchProducts:\u0027, err)\r\n        return \"Error al conectar con la base de datos de productos.\"\r\n    }\r\n}\r\n\r\nexport async function createAppointment(\r\n    supabase: SupabaseClient,\r\n    userId: string,\r\n    contactInfo: { name: string, phone: string, id: number },\r\n    startTime: string,\r\n    serviceId: number,\r\n    notes: string = \"\"\r\n) {\r\n    console.log(`... [TOOL: Citas] Validando servicio ID ${serviceId} para ${contactInfo.name}`)\r\n\r\n    try {\r\n        // STEP 1: Validate service exists and belongs to user\r\n        const { data: service, error: serviceError } = await supabase\r\n            .from(\u0027products\u0027)\r\n            .select(\u0027id, product_name, description\u0027)\r\n            .eq(\u0027id\u0027, serviceId)\r\n            .eq(\u0027user_id\u0027, userId)\r\n            .eq(\u0027product_type\u0027, \u0027service\u0027)\r\n            .single()\r\n\r\n        if (serviceError || !service) {\r\n            console.error(\u0027!!! [ERROR] Servicio invÃ¡lido o no encontrado:\u0027, serviceId, serviceError)\r\n            return `âŒ Error: El servicio solicitado no existe o no estÃ¡ disponible. Por favor, elige uno de los servicios listados.`\r\n        }\r\n\r\n        console.log(`+++ [TOOL: Citas] Servicio validado: ${service.product_name}`)\r\n\r\n        // STEP 2: Create appointment with REAL data from DB\r\n        const start = new Date(startTime)\r\n        const end = new Date(start.getTime() + 60 * 60 * 1000)\r\n\r\n        const { data, error } = await supabase\r\n            .from(\u0027appointments\u0027)\r\n            .insert({\r\n                user_id: userId,\r\n                client_name: contactInfo.name || contactInfo.phone,\r\n                client_phone: contactInfo.phone,\r\n                start_time: start.toISOString(),\r\n                end_time: end.toISOString(),\r\n                status: \u0027confirmed\u0027,\r\n                notes: `Servicio: ${service.product_name}. ${notes}`.trim() || \u0027Cita agendada por ELINA IA\u0027,\r\n                created_by: \u0027ai\u0027,\r\n                metadata: {\r\n                    source: \u0027whatsapp\u0027,\r\n                    contact_id: contactInfo.id,\r\n                    service_id: service.id,\r\n                    service_name: service.product_name\r\n                }\r\n            })\r\n            .select()\r\n            .single()\r\n\r\n        if (error) {\r\n            console.error(\u0027!!! [ERROR] Error insertando cita:\u0027, error)\r\n            return `Error al guardar la cita: ${error.message}`\r\n        }\r\n\r\n        console.log(`+++ [TOOL: Citas] Cita creada con ID: ${data.id}`)\r\n        return `Â¡Cita confirmada y guardada exitosamente para el ${start.toLocaleString(\u0027es-MX\u0027)}!`\r\n\r\n    } catch (err) {\r\n        console.error(\u0027Exception in createAppointment:\u0027, err)\r\n        return \"Error tÃ©cnico al intentar agendar la cita.\"\r\n    }\r\n}\r\n",
                         "PSPath":  "H:\\DESAL\\ELina 26\\supabase\\functions\\process-chat-message\\tools.ts",
                         "PSParentPath":  "H:\\DESAL\\ELina 26\\supabase\\functions\\process-chat-message",
                         "PSChildName":  "tools.ts",
                         "PSDrive":  "H",
                         "PSProvider":  "Microsoft.PowerShell.Core\\FileSystem",
                         "ReadCount":  1
                     },
    "pcm/rag.ts":  {
                       "value":  "\r\nimport { SupabaseClient } from \u0027https://esm.sh/@supabase/supabase-js@2\u0027\r\n\r\nexport async function getRagContext(\r\n    supabase: SupabaseClient,\r\n    userId: string,\r\n    contactId: string,\r\n    text: string\r\n): Promise\u003cstring\u003e {\r\n    // 1. Get Embedding (Smart Router)\r\n    const embeddingUrl = `${Deno.env.get(\u0027SUPABASE_URL\u0027)}/functions/v1/smart-embedding-router`\r\n\r\n    let embedding = null\r\n    let needsRag = true\r\n\r\n    try {\r\n        const embedRes = await fetch(embeddingUrl, {\r\n            method: \u0027POST\u0027,\r\n            headers: {\r\n                \u0027Authorization\u0027: `Bearer ${Deno.env.get(\u0027SUPABASE_SERVICE_ROLE_KEY\u0027)}`,\r\n                \u0027Content-Type\u0027: \u0027application/json\u0027,\r\n            },\r\n            body: JSON.stringify({\r\n                text: text,\r\n                skip_rag: false\r\n            }),\r\n        })\r\n\r\n        if (embedRes.ok) {\r\n            const embedData = await embedRes.json()\r\n            embedding = embedData.embedding\r\n            needsRag = embedData.needs_rag\r\n        } else {\r\n            console.warn(\u0027Embedding fetch failed, falling back to full-text only\u0027)\r\n        }\r\n    } catch (e) {\r\n        console.error(\u0027Error fetching embedding:\u0027, e)\r\n    }\r\n\r\n    if (!needsRag) return \"\"\r\n\r\n    // 2. Search Context (RAG with Fallback)\r\n    const ragUrl = `${Deno.env.get(\u0027SUPABASE_URL\u0027)}/functions/v1/rag-with-fallback`\r\n    try {\r\n        const ragRes = await fetch(ragUrl, {\r\n            method: \u0027POST\u0027,\r\n            headers: {\r\n                \u0027Authorization\u0027: `Bearer ${Deno.env.get(\u0027SUPABASE_SERVICE_ROLE_KEY\u0027)}`,\r\n                \u0027Content-Type\u0027: \u0027application/json\u0027,\r\n            },\r\n            body: JSON.stringify({\r\n                query_text: text,\r\n                user_id: userId,\r\n                contact_id: contactId,\r\n                query_embedding: (embedding \u0026\u0026 embedding.length \u003e 0) ? embedding : null,\r\n                match_count: 5\r\n            })\r\n        })\r\n\r\n        if (!ragRes.ok) {\r\n            console.error(\u0027RAG Search failed:\u0027, await ragRes.text())\r\n            return \"\"\r\n        }\r\n\r\n        const results = await ragRes.json()\r\n        if (!results || results.length === 0) return \"\"\r\n\r\n        // Format Context\r\n        return results.map((r: any) =\u003e {\r\n            return `[Contexto IA]: ${r.content}`\r\n        }).join(\"\\n\\n\")\r\n\r\n    } catch (e) {\r\n        console.error(\"Error in RAG search:\", e)\r\n        return \"\"\r\n    }\r\n}\r\n\r\nexport async function detectObjections(\r\n    supabase: SupabaseClient,\r\n    userId: string,\r\n    messageText: string\r\n): Promise\u003c{ objection: string, response: string, confidence: number }[]\u003e {\r\n    // 1. Get active context and objections\r\n    const { data: salesContext, error } = await supabase\r\n        .from(\u0027sales_prompts\u0027)\r\n        .select(\u0027prompt\u0027)\r\n        .eq(\u0027user_id\u0027, userId)\r\n        .eq(\u0027is_active\u0027, true)\r\n        .order(\u0027created_at\u0027, { ascending: false })\r\n        .limit(1)\r\n        .single()\r\n\r\n    if (error || !salesContext || !salesContext.prompt || !salesContext.prompt.detected_objections) {\r\n        return []\r\n    }\r\n\r\n    const objections = salesContext.prompt.detected_objections.map((obj: any) =\u003e ({\r\n        objection_text: obj.objection,\r\n        suggested_response: obj.response\r\n    }))\r\n\r\n    if (objections.length === 0) {\r\n        return []\r\n    }\r\n\r\n    // 2. Get embedding for user message\r\n    const embeddingUrl = `${Deno.env.get(\u0027SUPABASE_URL\u0027)}/functions/v1/smart-embedding-router`\r\n\r\n    try {\r\n        const embedRes = await fetch(embeddingUrl, {\r\n            method: \u0027POST\u0027,\r\n            headers: {\r\n                \u0027Authorization\u0027: `Bearer ${Deno.env.get(\u0027SUPABASE_SERVICE_ROLE_KEY\u0027)}`,\r\n                \u0027Content-Type\u0027: \u0027application/json\u0027,\r\n            },\r\n            body: JSON.stringify({\r\n                text: messageText,\r\n                skip_rag: false\r\n            }),\r\n        })\r\n\r\n        if (!embedRes.ok) {\r\n            console.warn(\u0027Embedding fetch failed for objections, using keyword matching\u0027)\r\n            return keywordMatchObjections(messageText, objections)\r\n        }\r\n\r\n        const embedData = await embedRes.json()\r\n        const messageEmbedding = embedData.embedding\r\n\r\n        if (!messageEmbedding) {\r\n            return keywordMatchObjections(messageText, objections)\r\n        }\r\n\r\n        // 3. Calculate similarity for each objection\r\n        const matches: { objection: string, response: string, confidence: number }[] = []\r\n\r\n        for (const obj of objections) {\r\n            // Get embedding for objection text\r\n            const objEmbedRes = await fetch(embeddingUrl, {\r\n                method: \u0027POST\u0027,\r\n                headers: {\r\n                    \u0027Authorization\u0027: `Bearer ${Deno.env.get(\u0027SUPABASE_SERVICE_ROLE_KEY\u0027)}`,\r\n                    \u0027Content-Type\u0027: \u0027application/json\u0027,\r\n                },\r\n                body: JSON.stringify({\r\n                    text: obj.objection_text,\r\n                    skip_rag: true\r\n                }),\r\n            })\r\n\r\n            if (objEmbedRes.ok) {\r\n                const objEmbedData = await objEmbedRes.json()\r\n                const objectionEmbedding = objEmbedData.embedding\r\n\r\n                if (objectionEmbedding) {\r\n                    // Calculate cosine similarity\r\n                    const similarity = cosineSimilarity(messageEmbedding, objectionEmbedding)\r\n\r\n                    // Only include if similarity \u003e 0.7 (70% match)\r\n                    if (similarity \u003e 0.7) {\r\n                        matches.push({\r\n                            objection: obj.objection_text,\r\n                            response: obj.suggested_response,\r\n                            confidence: similarity\r\n                        })\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Sort by confidence (highest first)\r\n        matches.sort((a, b) =\u003e b.confidence - a.confidence)\r\n\r\n        return matches.slice(0, 3) // Return top 3 matches\r\n\r\n    } catch (e) {\r\n        console.error(\u0027Error in objection detection:\u0027, e)\r\n        return keywordMatchObjections(messageText, objections)\r\n    }\r\n}\r\n\r\n// Fallback: Simple keyword matching\r\nfunction keywordMatchObjections(messageText: string, objections: any[]): { objection: string, response: string, confidence: number }[] {\r\n    const lowerMessage = messageText.toLowerCase()\r\n    const matches: { objection: string, response: string, confidence: number }[] = []\r\n\r\n    for (const obj of objections) {\r\n        const lowerObjection = obj.objection_text.toLowerCase()\r\n\r\n        // Check if message contains objection keywords\r\n        const keywords = lowerObjection.split(\u0027 \u0027).filter((w: string) =\u003e w.length \u003e 3)\r\n        const matchCount = keywords.filter((k: string) =\u003e lowerMessage.includes(k)).length\r\n\r\n        if (matchCount \u003e 0) {\r\n            const confidence = matchCount / keywords.length\r\n            if (confidence \u003e 0.5) {\r\n                matches.push({\r\n                    objection: obj.objection_text,\r\n                    response: obj.suggested_response,\r\n                    confidence: confidence\r\n                })\r\n            }\r\n        }\r\n    }\r\n\r\n    matches.sort((a, b) =\u003e b.confidence - a.confidence)\r\n    return matches.slice(0, 3)\r\n}\r\n\r\n// Cosine similarity calculation\r\nfunction cosineSimilarity(vecA: number[], vecB: number[]): number {\r\n    if (vecA.length !== vecB.length) return 0\r\n\r\n    let dotProduct = 0\r\n    let normA = 0\r\n    let normB = 0\r\n\r\n    for (let i = 0; i \u003c vecA.length; i++) {\r\n        dotProduct += vecA[i] * vecB[i]\r\n        normA += vecA[i] * vecA[i]\r\n        normB += vecB[i] * vecB[i]\r\n    }\r\n\r\n    const denominator = Math.sqrt(normA) * Math.sqrt(normB)\r\n    return denominator === 0 ? 0 : dotProduct / denominator\r\n}\r\n",
                       "PSPath":  "H:\\DESAL\\ELina 26\\supabase\\functions\\process-chat-message\\rag.ts",
                       "PSParentPath":  "H:\\DESAL\\ELina 26\\supabase\\functions\\process-chat-message",
                       "PSChildName":  "rag.ts",
                       "PSDrive":  "H",
                       "PSProvider":  "Microsoft.PowerShell.Core\\FileSystem",
                       "ReadCount":  1
                   },
    "tags/index.ts":  {
                          "value":  "\r\nimport { serve } from \"https://deno.land/std@0.168.0/http/server.ts\"\r\nimport { createSupabaseAdminClient } from \"../_shared/supabase-client.ts\"\r\nimport { corsHeaders } from \"../_shared/cors.ts\"\r\nimport OpenAI from \"https://esm.sh/openai@4.51.0\"\r\n\r\nconsole.log(\"Apply Auto Tags Function Started v2.0 (Corrected Schema)\")\r\n\r\nconst openai = new OpenAI({\r\n    apiKey: Deno.env.get(\"GEMINI_API_KEY\")!,\r\n    baseURL: \"https://generativelanguage.googleapis.com/v1beta/openai/\"\r\n})\r\n\r\ninterface AutomatedLabel {\r\n    id: string\r\n    name: string // The tag name\r\n    prompt: string // The AI instruction\r\n    is_automated: boolean\r\n}\r\n\r\nserve(async (req) =\u003e {\r\n    if (req.method === \u0027OPTIONS\u0027) {\r\n        return new Response(\u0027ok\u0027, { headers: corsHeaders })\r\n    }\r\n\r\n    try {\r\n        const supabase = createSupabaseAdminClient()\r\n        const payload = await req.json()\r\n\r\n        const { user_id, contact_id } = payload\r\n\r\n        if (!user_id || !contact_id) {\r\n            return new Response(JSON.stringify({ error: \u0027Missing user_id or contact_id\u0027 }), {\r\n                headers: { ...corsHeaders, \u0027Content-Type\u0027: \u0027application/json\u0027 },\r\n                status: 400\r\n            })\r\n        }\r\n\r\n        console.log(`\u003e\u003e\u003e [AUTO-TAGS] Analizando conversaciÃ³n: user=${user_id}, contact=${contact_id}`)\r\n\r\n        // 1. Get automated labels (using correct \u0027labels\u0027 table)\r\n        const { data: automatedLabels, error: labelsError } = await supabase\r\n            .from(\u0027labels\u0027)\r\n            .select(\u0027id, name, prompt, is_automated\u0027)\r\n            .eq(\u0027user_id\u0027, user_id)\r\n            .eq(\u0027is_automated\u0027, true)\r\n\r\n        // Filter out any labels without a prompt just in case\r\n        const validLabels = (automatedLabels || []).filter((l: any) =\u003e l.prompt \u0026\u0026 l.prompt.trim().length \u003e 0)\r\n\r\n        if (labelsError || validLabels.length === 0) {\r\n            console.log(\u0027--- [AUTO-TAGS] No hay etiquetas automatizadas activas\u0027)\r\n            return new Response(JSON.stringify({ message: \u0027No automated labels found\u0027 }), {\r\n                headers: { ...corsHeaders, \u0027Content-Type\u0027: \u0027application/json\u0027 },\r\n                status: 200\r\n            })\r\n        }\r\n\r\n        console.log(`+++ [AUTO-TAGS] ${validLabels.length} etiquetas automatizadas encontradas`)\r\n\r\n        // 2. Get recent chat history (last 20 messages)\r\n        const { data: history, error: historyError } = await supabase\r\n            .from(\u0027chat_history\u0027)\r\n            .select(\u0027*\u0027)\r\n            .eq(\u0027user_id\u0027, user_id)\r\n            .eq(\u0027contact_id\u0027, contact_id)\r\n            .order(\u0027created_at\u0027, { ascending: false })\r\n            .limit(20)\r\n\r\n        if (historyError || !history || history.length === 0) {\r\n            console.log(\u0027--- [AUTO-TAGS] No hay historial suficiente\u0027)\r\n            return new Response(JSON.stringify({ message: \u0027No chat history found\u0027 }), {\r\n                headers: { ...corsHeaders, \u0027Content-Type\u0027: \u0027application/json\u0027 },\r\n                status: 200\r\n            })\r\n        }\r\n\r\n        const reversedHistory = history.reverse()\r\n        console.log(`+++ [AUTO-TAGS] Historial con ${reversedHistory.length} mensajes`)\r\n\r\n        // 3. Get current contact labels\r\n        const { data: contact } = await supabase\r\n            .from(\u0027contacts\u0027)\r\n            .select(\u0027labels, full_name, phone_number\u0027)\r\n            .eq(\u0027id\u0027, contact_id)\r\n            .single()\r\n\r\n        const currentLabels: string[] = contact?.labels || []\r\n        console.log(`+++ [AUTO-TAGS] Etiquetas actuales: ${currentLabels.join(\u0027, \u0027) || \u0027ninguna\u0027}`)\r\n\r\n        // 4. Analyze conversation with AI for each label\r\n        const newLabels: string[] = []\r\n\r\n        // Prepare conversation text once\r\n        const conversationText = reversedHistory\r\n            .map(m =\u003e `${m.message_type === \u0027human\u0027 ? \u0027Cliente\u0027 : \u0027Asistente\u0027}: ${m.content}`)\r\n            .join(\u0027\\n\u0027)\r\n\r\n        for (const label of validLabels as AutomatedLabel[]) {\r\n            // Skip if already has this label (case insensitive check)\r\n            if (currentLabels.some(l =\u003e l.toLowerCase() === label.name.toLowerCase())) {\r\n                console.log(`--- [AUTO-TAGS] Contacto ya tiene etiqueta: ${label.name}`)\r\n                continue\r\n            }\r\n\r\n            // Build analysis prompt using the user\u0027s custom prompt\r\n            const analysisPrompt = `Analiza la siguiente conversaciÃ³n y determina si debe aplicarse la etiqueta \"${label.name}\".\r\n\r\nINSTRUCCIÃ“N ESPECÃFICA (DEFINIDA POR EL USUARIO):\r\n\"${label.prompt}\"\r\n\r\nCONVERSACIÃ“N:\r\n${conversationText}\r\n\r\nINSTRUCCIONES DE SALIDA:\r\n- Responde SOLO con \"SI\" o \"NO\"\r\n- SI: Si la conversaciÃ³n cumple con la instrucciÃ³n de la etiqueta.\r\n- NO: Si no cumple o hay dudas.\r\n\r\nRespuesta:`\r\n\r\n            try {\r\n                const response = await openai.chat.completions.create({\r\n                    model: \"gemini-2.0-flash-lite\",\r\n                    messages: [\r\n                        { role: \"system\", content: \"Eres un asistente que analiza conversaciones y determina si deben aplicarse etiquetas. Responde SOLO con SI o NO.\" },\r\n                        { role: \"user\", content: analysisPrompt }\r\n                    ],\r\n                    temperature: 0.1,\r\n                    max_tokens: 5\r\n                })\r\n\r\n                const decision = response.choices[0].message.content?.trim().toUpperCase()\r\n\r\n                if (decision === \u0027SI\u0027 || decision?.includes(\u0027SI\u0027)) {\r\n                    console.log(`+++ [AUTO-TAGS] Etiqueta APLICABLE: ${label.name}`)\r\n                    newLabels.push(label.name)\r\n                } else {\r\n                    console.log(`--- [AUTO-TAGS] Etiqueta NO APLICABLE: ${label.name}`)\r\n                }\r\n\r\n            } catch (err) {\r\n                console.error(`!!! [ERROR] Fallo anÃ¡lisis para ${label.name}:`, err)\r\n            }\r\n        }\r\n\r\n        // 5. Update contact labels if new labels found\r\n        if (newLabels.length \u003e 0) {\r\n            // Merge labels avoiding duplicates\r\n            const updatedLabels = [...new Set([...currentLabels, ...newLabels])]\r\n\r\n            const { error: updateError } = await supabase\r\n                .from(\u0027contacts\u0027)\r\n                .update({ labels: updatedLabels })\r\n                .eq(\u0027id\u0027, contact_id)\r\n\r\n            if (updateError) {\r\n                console.error(\u0027!!! [ERROR] Fallo al actualizar etiquetas:\u0027, updateError)\r\n                return new Response(JSON.stringify({ error: \u0027Failed to update labels\u0027 }), {\r\n                    headers: { ...corsHeaders, \u0027Content-Type\u0027: \u0027application/json\u0027 },\r\n                    status: 500\r\n                })\r\n            }\r\n\r\n            console.log(`+++ [AUTO-TAGS] Etiquetas agregadas: ${newLabels.join(\u0027, \u0027)}`)\r\n\r\n            return new Response(JSON.stringify({\r\n                success: true,\r\n                labels_added: newLabels,\r\n                total_labels: updatedLabels.length\r\n            }), {\r\n                headers: { ...corsHeaders, \u0027Content-Type\u0027: \u0027application/json\u0027 },\r\n                status: 200\r\n            })\r\n        }\r\n\r\n        console.log(\u0027--- [AUTO-TAGS] No se aplicaron nuevas etiquetas\u0027)\r\n\r\n        return new Response(JSON.stringify({\r\n            success: true,\r\n            labels_added: [],\r\n            message: \u0027No new labels applied\u0027\r\n        }), {\r\n            headers: { ...corsHeaders, \u0027Content-Type\u0027: \u0027application/json\u0027 },\r\n            status: 200\r\n        })\r\n\r\n    } catch (error: any) {\r\n        console.error(\u0027!!! [ERROR FATAL] apply-auto-tags:\u0027, error)\r\n        return new Response(JSON.stringify({ error: error.message }), {\r\n            headers: { ...corsHeaders, \u0027Content-Type\u0027: \u0027application/json\u0027 },\r\n            status: 500\r\n        })\r\n    }\r\n})\r\n",
                          "PSPath":  "H:\\DESAL\\ELina 26\\supabase\\functions\\apply-auto-tags\\index.ts",
                          "PSParentPath":  "H:\\DESAL\\ELina 26\\supabase\\functions\\apply-auto-tags",
                          "PSChildName":  "index.ts",
                          "PSDrive":  "H",
                          "PSProvider":  "Microsoft.PowerShell.Core\\FileSystem",
                          "ReadCount":  1
                      },
    "pcm/media.ts":  {
                         "value":  "\r\nimport OpenAI from \"https://esm.sh/openai@4.51.0\";\r\nimport { getMediaBase64 } from \u0027./evolution-client.ts\u0027\r\n\r\nconst openai = new OpenAI({ apiKey: Deno.env.get(\"OPENAI_API_KEY\")! });\r\n\r\n// ElevenLabs Config\r\nconst ELEVENLABS_API_KEY = Deno.env.get(\"ELEVEN_LABS_API_KEY\")\r\nconst ELEVENLABS_VOICE_ID = Deno.env.get(\"ELEVEN_LABS_VOICE_ID\") || \"21m00Tcm4TlvDq8ikWAM\" // Default Rachel\r\n\r\nfunction base64ToFile(base64: string, filename: string, mimeType: string): File {\r\n    const byteCharacters = atob(base64);\r\n    const byteNumbers = new Array(byteCharacters.length);\r\n    for (let i = 0; i \u003c byteCharacters.length; i++) {\r\n        byteNumbers[i] = byteCharacters.charCodeAt(i);\r\n    }\r\n    const byteArray = new Uint8Array(byteNumbers);\r\n    return new File([byteArray], filename, { type: mimeType });\r\n}\r\n\r\nexport async function processMedia(\r\n    instanceName: string,\r\n    apiKey: string,\r\n    messageId: string,\r\n    mediaType: \u0027audio\u0027 | \u0027image\u0027,\r\n    apiUrl?: string\r\n): Promise\u003cstring\u003e {\r\n    try {\r\n        console.log(`Processing media ${mediaType} for message ${messageId}`)\r\n        const media = await getMediaBase64(instanceName, apiKey, messageId, false, apiUrl)\r\n        if (!media) return \"\"\r\n\r\n        if (mediaType === \u0027audio\u0027) {\r\n            const file = base64ToFile(media.base64, \"audio.ogg\", \"audio/ogg\")\r\n            // Use Whisper (OpenAI) for transcription as requested\r\n            const transcription = await openai.audio.transcriptions.create({\r\n                file: file,\r\n                model: \"whisper-1\",\r\n            });\r\n            console.log(`Transcription: ${transcription.text}`)\r\n            return transcription.text\r\n        }\r\n\r\n        if (mediaType === \u0027image\u0027) {\r\n            const response = await openai.chat.completions.create({\r\n                model: \"gpt-4o-mini\",\r\n                messages: [\r\n                    {\r\n                        role: \"user\",\r\n                        content: [\r\n                            { type: \"text\", text: \"Describe esta imagen detalladamente.\" },\r\n                            {\r\n                                type: \"image_url\",\r\n                                image_url: {\r\n                                    url: `data:${media.mimetype || \u0027image/jpeg\u0027};base64,${media.base64}`\r\n                                }\r\n                            }\r\n                        ]\r\n                    }\r\n                ],\r\n                max_tokens: 300\r\n            });\r\n            return response.choices[0].message.content || \"\"\r\n        }\r\n\r\n        return \"\"\r\n\r\n    } catch (e) {\r\n        console.error(\"Error processing media:\", e)\r\n        return \"\"\r\n    }\r\n}\r\n\r\nimport { createSupabaseAdminClient } from \"./supabase-client.ts\"\r\n\r\nexport async function generateAudio(text: string): Promise\u003cstring | null\u003e {\r\n    if (!ELEVENLABS_API_KEY) {\r\n        console.error(\"Missing ELEVEN_LABS_API_KEY\")\r\n        return null\r\n    }\r\n\r\n    const url = `https://api.elevenlabs.io/v1/text-to-speech/${ELEVENLABS_VOICE_ID}`\r\n\r\n    try {\r\n        const res = await fetch(url, {\r\n            method: \u0027POST\u0027,\r\n            headers: {\r\n                \u0027xi-api-key\u0027: ELEVENLABS_API_KEY,\r\n                \u0027Content-Type\u0027: \u0027application/json\u0027\r\n            },\r\n            body: JSON.stringify({\r\n                text: text,\r\n                model_id: \"eleven_monolingual_v1\",\r\n                voice_settings: {\r\n                    stability: 0.5,\r\n                    similarity_boost: 0.75\r\n                }\r\n            })\r\n        })\r\n\r\n        if (!res.ok) {\r\n            console.error(\"ElevenLabs Error:\", await res.text())\r\n            return null\r\n        }\r\n\r\n        const arrayBuffer = await res.arrayBuffer()\r\n\r\n        // Upload to Supabase Storage\r\n        const supabase = createSupabaseAdminClient()\r\n        const fileName = `audio_${Date.now()}_${Math.random().toString(36).substring(7)}.mp3`\r\n\r\n        // Convert ArrayBuffer to Uint8Array for upload\r\n        const fileBody = new Uint8Array(arrayBuffer)\r\n\r\n        const { error: uploadError } = await supabase.storage\r\n            .from(\u0027audiostemp\u0027)\r\n            .upload(fileName, fileBody, {\r\n                contentType: \u0027audio/mpeg\u0027,\r\n                upsert: false\r\n            })\r\n\r\n        if (uploadError) {\r\n            console.error(\u0027Error uploading audio to Storage:\u0027, uploadError)\r\n            // Fallback to Base64 if storage fails (optional, but good for robustness)\r\n            const base64 = btoa(String.fromCharCode(...fileBody))\r\n            return `data:audio/mpeg;base64,${base64}`\r\n        }\r\n\r\n        // Get Public URL\r\n        const { data: { publicUrl } } = supabase.storage\r\n            .from(\u0027audiostemp\u0027)\r\n            .getPublicUrl(fileName)\r\n\r\n        return publicUrl\r\n\r\n    } catch (e) {\r\n        console.error(\"Error generating audio:\", e)\r\n        return null\r\n    }\r\n}\r\n",
                         "PSPath":  "H:\\DESAL\\ELina 26\\supabase\\functions\\process-chat-message\\media.ts",
                         "PSParentPath":  "H:\\DESAL\\ELina 26\\supabase\\functions\\process-chat-message",
                         "PSChildName":  "media.ts",
                         "PSDrive":  "H",
                         "PSProvider":  "Microsoft.PowerShell.Core\\FileSystem",
                         "ReadCount":  1
                     },
    "shared/evolution-client.ts":  {
                                       "value":  "\r\nexport const EVOLUTION_API_URL = Deno.env.get(\"EVOLUTION_API_URL\") || \"https://evolutionapi-evolution-api.mcjhhb.easypanel.host\";\r\n\r\nexport async function sendMessage(\r\n    instanceName: string,\r\n    apiKey: string,\r\n    remoteJid: string,\r\n    text: string,\r\n    apiUrl?: string\r\n) {\r\n    const baseUrl = apiUrl || EVOLUTION_API_URL\r\n    const url = `${baseUrl}/message/sendText/${instanceName}`\r\n    const body = {\r\n        number: remoteJid,\r\n        text: text\r\n    }\r\n\r\n    return await fetchEvolution(url, apiKey, body)\r\n}\r\n\r\nexport async function sendMedia(\r\n    instanceName: string,\r\n    apiKey: string,\r\n    remoteJid: string,\r\n    mediaUrl: string,\r\n    mediaType: \u0027image\u0027 | \u0027video\u0027 | \u0027document\u0027 | \u0027audio\u0027,\r\n    caption?: string,\r\n    fileName?: string,\r\n    apiUrl?: string\r\n) {\r\n    let endpoint = \u0027sendMedia\u0027;\r\n    // Evolution API v2 might have different endpoints, but usually sendMedia handles all or specific ones like sendAudio\r\n    // Based on n8n it uses specific operations. \r\n    // Let\u0027s stick to specific if possible, or generic media.\r\n    // n8n \"send-audio\" uses /message/sendAudio ? No, it calls \"send-audio\" buffer operation.\r\n    // But over HTTP it\u0027s usually /message/sendMedia or /message/sendAudio\r\n\r\n    if (mediaType === \u0027audio\u0027) endpoint = \u0027sendWhatsAppAudio\u0027; // Specific for voice notes often\r\n    else if (mediaType === \u0027document\u0027) endpoint = \u0027sendMedia\u0027; // PDF usually via sendMedia or sendDocument\r\n\r\n    const baseUrl = apiUrl || EVOLUTION_API_URL\r\n    const url = `${baseUrl}/message/${endpoint}/${instanceName}`\r\n\r\n    const body: any = {\r\n        number: remoteJid,\r\n        mediatype: mediaType,\r\n        mimetype: mediaType === \u0027audio\u0027 ? \u0027audio/mpeg\u0027 : (mediaType === \u0027document\u0027 ? \u0027application/pdf\u0027 : undefined),\r\n        caption: caption,\r\n        media: mediaUrl,\r\n        fileName: fileName\r\n    }\r\n\r\n    if (mediaType === \u0027audio\u0027) {\r\n        // Special handling for audio if needed\r\n        // Sometimes \"url\" field is used instead of \"media\" depending on version\r\n        // We assume standard body\r\n    }\r\n\r\n    return await fetchEvolution(url, apiKey, body)\r\n}\r\n\r\nasync function fetchEvolution(url: string, apiKey: string, body: any) {\r\n    try {\r\n        const res = await fetch(url, {\r\n            method: \u0027POST\u0027,\r\n            headers: {\r\n                \u0027apikey\u0027: apiKey,\r\n                \u0027Content-Type\u0027: \u0027application/json\u0027\r\n            },\r\n            body: JSON.stringify(body)\r\n        })\r\n\r\n        if (!res.ok) {\r\n            const err = await res.text()\r\n            console.error(\u0027Evolution API Error:\u0027, err)\r\n            throw new Error(`Evolution API Error: ${err}`)\r\n        }\r\n        return await res.json()\r\n    } catch (e) {\r\n        console.error(\u0027Fetch Evolution Error:\u0027, e)\r\n        return null\r\n    }\r\n}\r\n\r\nexport async function getMediaBase64(\r\n    instanceName: string,\r\n    apiKey: string,\r\n    messageId: string,\r\n    convertToMp4: boolean = false,\r\n    apiUrl?: string\r\n): Promise\u003c{ base64: string, mimetype?: string } | null\u003e {\r\n    const baseUrl = apiUrl || EVOLUTION_API_URL\r\n    const url = `${baseUrl}/chat/getBase64FromMediaMessage/${instanceName}`\r\n    const body = {\r\n        message: {\r\n            key: {\r\n                id: messageId\r\n            }\r\n        },\r\n        convertToMp4\r\n    }\r\n\r\n    try {\r\n        const res = await fetch(url, {\r\n            method: \u0027POST\u0027,\r\n            headers: {\r\n                \u0027apikey\u0027: apiKey,\r\n                \u0027Content-Type\u0027: \u0027application/json\u0027\r\n            },\r\n            body: JSON.stringify(body)\r\n        })\r\n\r\n        if (!res.ok) {\r\n            console.error(\u0027Error fetching media:\u0027, await res.text())\r\n            return null\r\n        }\r\n\r\n        const data = await res.json()\r\n        // Evolution returns { base64: \"...\", mimetype: \"...\" } or similar\r\n        return {\r\n            base64: data.base64,\r\n            mimetype: data.mimetype\r\n        }\r\n\r\n    } catch (e) {\r\n        console.error(\u0027Error in getMediaBase64:\u0027, e)\r\n        return null\r\n    }\r\n}\r\n",
                                       "PSPath":  "H:\\DESAL\\ELina 26\\supabase\\functions\\_shared\\evolution-client.ts",
                                       "PSParentPath":  "H:\\DESAL\\ELina 26\\supabase\\functions\\_shared",
                                       "PSChildName":  "evolution-client.ts",
                                       "PSDrive":  "H",
                                       "PSProvider":  "Microsoft.PowerShell.Core\\FileSystem",
                                       "ReadCount":  1
                                   },
    "pcm/redis-cache.ts":  {
                               "value":  "\r\n// Redis Cache Helper for Supabase Edge Functions\r\n// Uses Upstash Redis for serverless caching\r\n\r\nconst REDIS_URL = Deno.env.get(\u0027UPSTASH_REDIS_REST_URL\u0027)\r\nconst REDIS_TOKEN = Deno.env.get(\u0027UPSTASH_REDIS_REST_TOKEN\u0027)\r\n\r\ninterface CacheOptions {\r\n    ttl?: number // Time to live in seconds (default: 300 = 5 minutes)\r\n}\r\n\r\nexport class RedisCache {\r\n    private baseUrl: string\r\n    private token: string\r\n\r\n    constructor() {\r\n        if (!REDIS_URL || !REDIS_TOKEN) {\r\n            console.warn(\u0027[REDIS] Upstash credentials not found, cache disabled\u0027)\r\n            this.baseUrl = \u0027\u0027\r\n            this.token = \u0027\u0027\r\n        } else {\r\n            this.baseUrl = REDIS_URL\r\n            this.token = REDIS_TOKEN\r\n        }\r\n    }\r\n\r\n    private isEnabled(): boolean {\r\n        return this.baseUrl !== \u0027\u0027 \u0026\u0026 this.token !== \u0027\u0027\r\n    }\r\n\r\n    async get\u003cT\u003e(key: string): Promise\u003cT | null\u003e {\r\n        if (!this.isEnabled()) return null\r\n\r\n        try {\r\n            const response = await fetch(`${this.baseUrl}/get/${key}`, {\r\n                headers: {\r\n                    \u0027Authorization\u0027: `Bearer ${this.token}`\r\n                }\r\n            })\r\n\r\n            if (!response.ok) {\r\n                console.warn(`[REDIS] GET failed for key: ${key}`)\r\n                return null\r\n            }\r\n\r\n            const data = await response.json()\r\n\r\n            if (data.result === null) {\r\n                return null\r\n            }\r\n\r\n            // Parse JSON if it\u0027s a string\r\n            if (typeof data.result === \u0027string\u0027) {\r\n                try {\r\n                    return JSON.parse(data.result) as T\r\n                } catch {\r\n                    return data.result as T\r\n                }\r\n            }\r\n\r\n            return data.result as T\r\n        } catch (error) {\r\n            console.error(\u0027[REDIS] Error getting key:\u0027, key, error)\r\n            return null\r\n        }\r\n    }\r\n\r\n    async set(key: string, value: any, options: CacheOptions = {}): Promise\u003cboolean\u003e {\r\n        if (!this.isEnabled()) return false\r\n\r\n        try {\r\n            const ttl = options.ttl || 300 // Default 5 minutes\r\n            const serializedValue = typeof value === \u0027string\u0027 ? value : JSON.stringify(value)\r\n\r\n            const response = await fetch(`${this.baseUrl}/set/${key}`, {\r\n                method: \u0027POST\u0027,\r\n                headers: {\r\n                    \u0027Authorization\u0027: `Bearer ${this.token}`,\r\n                    \u0027Content-Type\u0027: \u0027application/json\u0027\r\n                },\r\n                body: JSON.stringify({\r\n                    value: serializedValue,\r\n                    ex: ttl // Expiration in seconds\r\n                })\r\n            })\r\n\r\n            if (!response.ok) {\r\n                console.warn(`[REDIS] SET failed for key: ${key}`)\r\n                return false\r\n            }\r\n\r\n            console.log(`[REDIS] Cached: ${key} (TTL: ${ttl}s)`)\r\n            return true\r\n        } catch (error) {\r\n            console.error(\u0027[REDIS] Error setting key:\u0027, key, error)\r\n            return false\r\n        }\r\n    }\r\n\r\n    async delete(key: string): Promise\u003cboolean\u003e {\r\n        if (!this.isEnabled()) return false\r\n\r\n        try {\r\n            const response = await fetch(`${this.baseUrl}/del/${key}`, {\r\n                method: \u0027POST\u0027,\r\n                headers: {\r\n                    \u0027Authorization\u0027: `Bearer ${this.token}`\r\n                }\r\n            })\r\n\r\n            if (!response.ok) {\r\n                console.warn(`[REDIS] DELETE failed for key: ${key}`)\r\n                return false\r\n            }\r\n\r\n            console.log(`[REDIS] Deleted: ${key}`)\r\n            return true\r\n        } catch (error) {\r\n            console.error(\u0027[REDIS] Error deleting key:\u0027, key, error)\r\n            return false\r\n        }\r\n    }\r\n\r\n    async invalidatePattern(pattern: string): Promise\u003cboolean\u003e {\r\n        if (!this.isEnabled()) return false\r\n\r\n        try {\r\n            // Get all keys matching pattern\r\n            const response = await fetch(`${this.baseUrl}/keys/${pattern}`, {\r\n                headers: {\r\n                    \u0027Authorization\u0027: `Bearer ${this.token}`\r\n                }\r\n            })\r\n\r\n            if (!response.ok) {\r\n                console.warn(`[REDIS] KEYS failed for pattern: ${pattern}`)\r\n                return false\r\n            }\r\n\r\n            const data = await response.json()\r\n            const keys = data.result || []\r\n\r\n            if (keys.length === 0) {\r\n                console.log(`[REDIS] No keys found for pattern: ${pattern}`)\r\n                return true\r\n            }\r\n\r\n            // Delete all matching keys\r\n            for (const key of keys) {\r\n                await this.delete(key)\r\n            }\r\n\r\n            console.log(`[REDIS] Invalidated ${keys.length} keys matching: ${pattern}`)\r\n            return true\r\n        } catch (error) {\r\n            console.error(\u0027[REDIS] Error invalidating pattern:\u0027, pattern, error)\r\n            return false\r\n        }\r\n    }\r\n\r\n    // Helper: Get or Set pattern (cache-aside)\r\n    async getOrSet\u003cT\u003e(\r\n        key: string,\r\n        fetchFn: () =\u003e Promise\u003cT\u003e,\r\n        options: CacheOptions = {}\r\n    ): Promise\u003cT\u003e {\r\n        // Try to get from cache\r\n        const cached = await this.get\u003cT\u003e(key)\r\n        if (cached !== null) {\r\n            console.log(`[REDIS] Cache HIT: ${key}`)\r\n            return cached\r\n        }\r\n\r\n        console.log(`[REDIS] Cache MISS: ${key}`)\r\n\r\n        // Fetch fresh data\r\n        const fresh = await fetchFn()\r\n\r\n        // Cache it\r\n        await this.set(key, fresh, options)\r\n\r\n        return fresh\r\n    }\r\n}\r\n\r\n// Export singleton instance\r\nexport const cache = new RedisCache()\r\n\r\n// Cache key builders\r\nexport const CacheKeys = {\r\n    profile: (instanceName: string) =\u003e `profile:${instanceName}`,\r\n    appointmentSettings: (userId: string) =\u003e `appointment_settings:${userId}`,\r\n    activePromo: (userId: string) =\u003e `active_promo:${userId}`,\r\n    products: (userId: string) =\u003e `products:${userId}`,\r\n    services: (userId: string) =\u003e `services:${userId}`,\r\n\r\n    // Pattern invalidators\r\n    userPattern: (userId: string) =\u003e `*:${userId}`,\r\n    profilePattern: (instanceName: string) =\u003e `profile:${instanceName}`\r\n}\r\n",
                               "PSPath":  "H:\\DESAL\\ELina 26\\supabase\\functions\\process-chat-message\\redis-cache.ts",
                               "PSParentPath":  "H:\\DESAL\\ELina 26\\supabase\\functions\\process-chat-message",
                               "PSChildName":  "redis-cache.ts",
                               "PSDrive":  "H",
                               "PSProvider":  "Microsoft.PowerShell.Core\\FileSystem",
                               "ReadCount":  1
                           },
    "shared/rag.ts":  {
                          "value":  "\r\nimport { SupabaseClient } from \u0027https://esm.sh/@supabase/supabase-js@2\u0027\r\n\r\nexport async function getRagContext(\r\n    supabase: SupabaseClient,\r\n    userId: string,\r\n    contactId: string,\r\n    text: string\r\n): Promise\u003cstring\u003e {\r\n    // 1. Get Embedding (Smart Router)\r\n    const embeddingUrl = `${Deno.env.get(\u0027SUPABASE_URL\u0027)}/functions/v1/smart-embedding-router`\r\n\r\n    let embedding = null\r\n    let needsRag = true\r\n\r\n    try {\r\n        const embedRes = await fetch(embeddingUrl, {\r\n            method: \u0027POST\u0027,\r\n            headers: {\r\n                \u0027Authorization\u0027: `Bearer ${Deno.env.get(\u0027SUPABASE_SERVICE_ROLE_KEY\u0027)}`,\r\n                \u0027Content-Type\u0027: \u0027application/json\u0027,\r\n            },\r\n            body: JSON.stringify({\r\n                text: text,\r\n                skip_rag: false\r\n            }),\r\n        })\r\n\r\n        if (embedRes.ok) {\r\n            const embedData = await embedRes.json()\r\n            embedding = embedData.embedding\r\n            needsRag = embedData.needs_rag\r\n        } else {\r\n            console.warn(\u0027Embedding fetch failed, falling back to full-text only\u0027)\r\n        }\r\n    } catch (e) {\r\n        console.error(\u0027Error fetching embedding:\u0027, e)\r\n    }\r\n\r\n    if (!needsRag) return \"\"\r\n\r\n    // 2. Search Context (RAG with Fallback)\r\n    const ragUrl = `${Deno.env.get(\u0027SUPABASE_URL\u0027)}/functions/v1/rag-with-fallback`\r\n    try {\r\n        const ragRes = await fetch(ragUrl, {\r\n            method: \u0027POST\u0027,\r\n            headers: {\r\n                \u0027Authorization\u0027: `Bearer ${Deno.env.get(\u0027SUPABASE_SERVICE_ROLE_KEY\u0027)}`,\r\n                \u0027Content-Type\u0027: \u0027application/json\u0027,\r\n            },\r\n            body: JSON.stringify({\r\n                query_text: text,\r\n                user_id: userId,\r\n                contact_id: contactId,\r\n                query_embedding: (embedding \u0026\u0026 embedding.length \u003e 0) ? embedding : null,\r\n                match_count: 5\r\n            })\r\n        })\r\n\r\n        if (!ragRes.ok) {\r\n            console.error(\u0027RAG Search failed:\u0027, await ragRes.text())\r\n            return \"\"\r\n        }\r\n\r\n        const results = await ragRes.json()\r\n        if (!results || results.length === 0) return \"\"\r\n\r\n        // Format Context\r\n        return results.map((r: any) =\u003e {\r\n            return `[Contexto IA]: ${r.content}`\r\n        }).join(\"\\n\\n\")\r\n\r\n    } catch (e) {\r\n        console.error(\"Error in RAG search:\", e)\r\n        return \"\"\r\n    }\r\n}\r\n",
                          "PSPath":  "H:\\DESAL\\ELina 26\\supabase\\functions\\_shared\\rag.ts",
                          "PSParentPath":  "H:\\DESAL\\ELina 26\\supabase\\functions\\_shared",
                          "PSChildName":  "rag.ts",
                          "PSDrive":  "H",
                          "PSProvider":  "Microsoft.PowerShell.Core\\FileSystem",
                          "ReadCount":  1
                      },
    "pcm/cors.ts":  {
                        "value":  "\r\nexport const corsHeaders = {\r\n    \u0027Access-Control-Allow-Origin\u0027: \u0027*\u0027,\r\n    \u0027Access-Control-Allow-Headers\u0027: \u0027authorization, x-client-info, apikey, content-type\u0027,\r\n}\r\n",
                        "PSPath":  "H:\\DESAL\\ELina 26\\supabase\\functions\\process-chat-message\\cors.ts",
                        "PSParentPath":  "H:\\DESAL\\ELina 26\\supabase\\functions\\process-chat-message",
                        "PSChildName":  "cors.ts",
                        "PSDrive":  "H",
                        "PSProvider":  "Microsoft.PowerShell.Core\\FileSystem",
                        "ReadCount":  1
                    },
    "pcm/evolution-client.ts":  {
                                    "value":  "\r\nexport const EVOLUTION_API_URL = Deno.env.get(\"EVOLUTION_API_URL\") || \"https://evolutionapi-evolution-api.mcjhhb.easypanel.host\";\r\n\r\n// Helper function to generate random humanized delay\r\nfunction getHumanizedDelay(): number {\r\n    // Random delay between 800ms and 2500ms for natural feel\r\n    return Math.floor(Math.random() * (2500 - 800 + 1)) + 800\r\n}\r\n\r\nexport async function sendMessage(\r\n    instanceName: string,\r\n    apiKey: string,\r\n    remoteJid: string,\r\n    text: string,\r\n    apiUrl?: string,\r\n    options?: { delay?: number, linkPreview?: boolean }\r\n) {\r\n    const baseUrl = apiUrl || EVOLUTION_API_URL\r\n    const url = `${baseUrl}/message/sendText/${instanceName}`\r\n    const body = {\r\n        number: remoteJid,\r\n        text: text,\r\n        delay: options?.delay || getHumanizedDelay(), // Use random delay if not specified\r\n        linkPreview: options?.linkPreview !== false\r\n    }\r\n\r\n    return await fetchEvolution(url, apiKey, body)\r\n}\r\n\r\nexport async function sendMedia(\r\n    instanceName: string,\r\n    apiKey: string,\r\n    remoteJid: string,\r\n    mediaUrl: string,\r\n    mediaType: \u0027image\u0027 | \u0027video\u0027 | \u0027document\u0027 | \u0027audio\u0027,\r\n    caption?: string,\r\n    fileName?: string,\r\n    apiUrl?: string\r\n) {\r\n    let endpoint = \u0027sendMedia\u0027;\r\n    // Evolution API v2 might have different endpoints, but usually sendMedia handles all or specific ones like sendAudio\r\n    // Based on n8n it uses specific operations. \r\n    // Let\u0027s stick to specific if possible, or generic media.\r\n    // n8n \"send-audio\" uses /message/sendAudio ? No, it calls \"send-audio\" buffer operation.\r\n    // But over HTTP it\u0027s usually /message/sendMedia or /message/sendAudio\r\n\r\n    if (mediaType === \u0027audio\u0027) endpoint = \u0027sendWhatsAppAudio\u0027; // Specific for voice notes often\r\n    else if (mediaType === \u0027document\u0027) endpoint = \u0027sendMedia\u0027; // PDF usually via sendMedia or sendDocument\r\n\r\n    const baseUrl = apiUrl || EVOLUTION_API_URL\r\n    const url = `${baseUrl}/message/${endpoint}/${instanceName}`\r\n\r\n    const body: any = {\r\n        number: remoteJid,\r\n        mediatype: mediaType,\r\n        mimetype: mediaType === \u0027audio\u0027 ? \u0027audio/mpeg\u0027 : (mediaType === \u0027document\u0027 ? \u0027application/pdf\u0027 : undefined),\r\n        caption: caption,\r\n        media: mediaUrl,\r\n        fileName: fileName\r\n    }\r\n\r\n    if (mediaType === \u0027audio\u0027) {\r\n        // Special handling for audio if needed\r\n        // Sometimes \"url\" field is used instead of \"media\" depending on version\r\n        // We assume standard body\r\n    }\r\n\r\n    return await fetchEvolution(url, apiKey, body)\r\n}\r\n\r\nasync function fetchEvolution(url: string, apiKey: string, body: any) {\r\n    try {\r\n        const res = await fetch(url, {\r\n            method: \u0027POST\u0027,\r\n            headers: {\r\n                \u0027apikey\u0027: apiKey,\r\n                \u0027Content-Type\u0027: \u0027application/json\u0027\r\n            },\r\n            body: JSON.stringify(body)\r\n        })\r\n\r\n        if (!res.ok) {\r\n            const err = await res.text()\r\n            console.error(\u0027Evolution API Error:\u0027, err)\r\n            throw new Error(`Evolution API Error: ${err}`)\r\n        }\r\n        return await res.json()\r\n    } catch (e) {\r\n        console.error(\u0027Fetch Evolution Error:\u0027, e)\r\n        return null\r\n    }\r\n}\r\n\r\nexport async function getMediaBase64(\r\n    instanceName: string,\r\n    apiKey: string,\r\n    messageId: string,\r\n    convertToMp4: boolean = false,\r\n    apiUrl?: string\r\n): Promise\u003c{ base64: string, mimetype?: string } | null\u003e {\r\n    const baseUrl = apiUrl || EVOLUTION_API_URL\r\n    const url = `${baseUrl}/chat/getBase64FromMediaMessage/${instanceName}`\r\n    const body = {\r\n        message: {\r\n            key: {\r\n                id: messageId\r\n            }\r\n        },\r\n        convertToMp4\r\n    }\r\n\r\n    try {\r\n        const res = await fetch(url, {\r\n            method: \u0027POST\u0027,\r\n            headers: {\r\n                \u0027apikey\u0027: apiKey,\r\n                \u0027Content-Type\u0027: \u0027application/json\u0027\r\n            },\r\n            body: JSON.stringify(body)\r\n        })\r\n\r\n        if (!res.ok) {\r\n            console.error(\u0027Error fetching media:\u0027, await res.text())\r\n            return null\r\n        }\r\n\r\n        const data = await res.json()\r\n        // Evolution returns { base64: \"...\", mimetype: \"...\" } or similar\r\n        return {\r\n            base64: data.base64,\r\n            mimetype: data.mimetype\r\n        }\r\n\r\n    } catch (e) {\r\n        console.error(\u0027Error in getMediaBase64:\u0027, e)\r\n        return null\r\n    }\r\n}\r\n\r\nexport async function getMediaUrl(\r\n    instanceName: string,\r\n    apiKey: string,\r\n    messageId: string,\r\n    apiUrl?: string\r\n): Promise\u003cstring | null\u003e {\r\n    const media = await getMediaBase64(instanceName, apiKey, messageId, false, apiUrl);\r\n    if (!media || !media.base64) return null;\r\n\r\n    return `data:${media.mimetype};base64,${media.base64}`;\r\n}\r\n\r\nexport async function sendImage(\r\n    instanceName: string,\r\n    apiKey: string,\r\n    remoteJid: string,\r\n    imageUrl: string,\r\n    caption?: string,\r\n    apiUrl?: string\r\n) {\r\n    return await sendMedia(instanceName, apiKey, remoteJid, imageUrl, \u0027image\u0027, caption, undefined, apiUrl)\r\n}\r\n\r\nexport async function sendVideo(\r\n    instanceName: string,\r\n    apiKey: string,\r\n    remoteJid: string,\r\n    videoUrl: string,\r\n    caption?: string,\r\n    apiUrl?: string\r\n) {\r\n    return await sendMedia(instanceName, apiKey, remoteJid, videoUrl, \u0027video\u0027, caption, undefined, apiUrl)\r\n}\r\n\r\nexport async function sendAudio(\r\n    instanceName: string,\r\n    apiKey: string,\r\n    remoteJid: string,\r\n    audioUrl: string,\r\n    apiUrl?: string\r\n) {\r\n    return await sendMedia(instanceName, apiKey, remoteJid, audioUrl, \u0027audio\u0027, undefined, undefined, apiUrl)\r\n}\r\n",
                                    "PSPath":  "H:\\DESAL\\ELina 26\\supabase\\functions\\process-chat-message\\evolution-client.ts",
                                    "PSParentPath":  "H:\\DESAL\\ELina 26\\supabase\\functions\\process-chat-message",
                                    "PSChildName":  "evolution-client.ts",
                                    "PSDrive":  "H",
                                    "PSProvider":  "Microsoft.PowerShell.Core\\FileSystem",
                                    "ReadCount":  1
                                },
    "pcm/llm.ts":  {
                       "value":  "\r\nimport OpenAI from \"https://esm.sh/openai@4.51.0\";\r\nimport { SupabaseClient } from \u0027https://esm.sh/@supabase/supabase-js@2\u0027\r\nimport { toolsDefinition, searchProducts, createAppointment } from \u0027./tools.ts\u0027\r\n\r\n// Google Gemini Config via OpenAI Compatibility\r\nconst openai = new OpenAI({\r\n    apiKey: Deno.env.get(\"GEMINI_API_KEY\")!,\r\n    baseURL: \"https://generativelanguage.googleapis.com/v1beta/openai/\"\r\n});\r\n\r\n// Helper function to check if current time is within business hours\r\nfunction checkBusinessHours(now: Date, startHour?: string, endHour?: string, timezone?: string): boolean {\r\n    if (!startHour || !endHour) return false // If no hours set, assume always open\r\n\r\n    try {\r\n        const currentHour = now.getHours()\r\n        const currentMinute = now.getMinutes()\r\n        const currentTime = currentHour * 60 + currentMinute\r\n\r\n        const [startH, startM] = startHour.split(\u0027:\u0027).map(Number)\r\n        const [endH, endM] = endHour.split(\u0027:\u0027).map(Number)\r\n\r\n        const startTime = startH * 60 + startM\r\n        const endTime = endH * 60 + endM\r\n\r\n        // Check if current time is outside business hours\r\n        return currentTime \u003c startTime || currentTime \u003e endTime\r\n    } catch (e) {\r\n        console.error(\u0027Error checking business hours:\u0027, e)\r\n        return false // Default to open if error\r\n    }\r\n}\r\n\r\nexport async function runAgent(\r\n    supabase: SupabaseClient,\r\n    userId: string,\r\n    history: any[], // chat_history rows\r\n    currentMessage: string,\r\n    ragContext: string,\r\n    systemPromptBase: string,\r\n    companyInfo: any, // from profile\r\n    contactInfo: any // from contact\r\n) {\r\n    const now = new Date();\r\n    const dateContext = `\r\nFECHA/HORA ACTUAL: ${now.toLocaleString(\u0027es-MX\u0027, { timeZone: companyInfo.timezone || \u0027America/Mexico_City\u0027 })}\r\nDÃ­a de la semana: ${now.toLocaleDateString(\u0027es-MX\u0027, { weekday: \u0027long\u0027 })}\r\n`\r\n    // 1. Build System Message\r\n    const placeholderInstruction = `\r\nIMPORTANTE PRODUCTOS:\r\n- Cuando menciones un producto del inventario para VENTA, DEBES usar este formato: [PRODUCT_NAME:ID].\r\n- NO inventes IDs.\r\n\r\nREGLAS DE AGENDAMIENTO (ACCIÃ“N INMEDIATA):\r\n1. **DETECCIÃ“N Y ACCIÃ“N DIRECTA.**\r\n   - Si el usuario menciona un servicio (ej: \"sacar muela\"), ofrece horarios disponibles inmediatamente.\r\n   - **IMPORTANTE:** USA ÃšNICAMENTE los slots que aparecen en \"HORARIOS DISPONIBLES\" abajo. **PROHIBIDO** inventar horas.\r\n   - Si no hay slots en el contexto, pide al usuario el dÃ­a que prefiere y dile que verificarÃ¡s.\r\n\r\n2. **CONTROL DE LA AGENDA (SLOTS REALES).**\r\n   - Usa EXCLUSIVAMENTE la informaciÃ³n de \"HORARIOS DISPONIBLES\" abajo.\r\n   - **PROHIBIDO INVENTAR HORAS**. Si la lista dice \"09:00\", ofreces \"09:00\". No digas \"11:00\" si no estÃ¡ en la lista.\r\n   - Si no hay slots para \"maÃ±ana\", dile: \"Para maÃ±ana no me quedan espacios, pero tengo estos otros: [Leer lista]\".\r\n   - OFRECE OPCIONES CONCRETAS: \"Tengo a las 09:00 y a las 10:30. Â¿Te sirve alguna?\".\r\n\r\n3. **AGENDAMIENTO INMEDIATO (SIN CONFIRMACIÃ“N EXTRA).**\r\n   - **IMPORTANTE:** YA TIENES el nombre (${contactInfo.full_name || \u0027Guest\u0027}) y telÃ©fono (${contactInfo.phone_number}). **PROHIBIDO** decirlos o pedirlos.\r\n   - **REGLA CRÃTICA:** Si el usuario proporciona SERVICIO + FECHA + HORA en su mensaje, ejecuta create_appointment INMEDIATAMENTE.\r\n   - **NO PREGUNTES \"Â¿te confirmo?\" o \"Â¿te agendo?\"**. Ejecuta la herramienta y luego confirma el resultado.\r\n   - Ejemplos de ejecuciÃ³n inmediata:\r\n     * Usuario: \"Quiero cita para maÃ±ana a las 10\" â†’ Ejecutas create_appointment â†’ Respondes: \"Â¡Listo! Tu cita quedÃ³ confirmada para maÃ±ana a las 10:00. Â¿Te puedo ayudar con algo mÃ¡s?\"\r\n     * Usuario: \"AgÃ©ndame el jueves a las 2pm para limpieza dental\" â†’ Ejecutas create_appointment â†’ Respondes: \"Â¡Genial! Ya quedÃ³ tu cita de limpieza dental para el jueves a las 14:00.\"\r\n   - Solo si falta informaciÃ³n (servicio, fecha u hora), pregunta lo que falta. Pero en cuanto tengas todo, EJECUTA sin pedir confirmaciÃ³n adicional.\r\n`\r\n    const companyContext = `\r\nINFORMACIÃ“N DE LA EMPRESA:\r\n${companyInfo.website ? \u0027- Website: \u0027 + companyInfo.website : \u0027\u0027}\r\n${companyInfo.business_phone ? \u0027- TelÃ©fono: \u0027 + companyInfo.business_phone : \u0027\u0027}\r\n${companyInfo.business_address ? \u0027- DirecciÃ³n: \u0027 + companyInfo.business_address : \u0027\u0027}\r\n${companyInfo.work_start_hour ? `- Horario: ${companyInfo.work_start_hour} - ${companyInfo.work_end_hour}` : \u0027\u0027}\r\n${companyInfo.company_description ? \u0027- DescripciÃ³n: \u0027 + companyInfo.company_description : \u0027\u0027}\r\n\r\nDATOS DEL USUARIO (YA CONOCIDOS - NO PREGUNTAR):\r\n- Nombre: ${contactInfo.full_name || contactInfo.phone_number} (Usa este nombre para el registro)\r\n- TelÃ©fono: ${contactInfo.phone_number} (Usa este telÃ©fono para el registro)\r\n\r\nPERSONALIDAD Y TONO:\r\n${companyInfo.company_description ? `- Refleja la personalidad de la empresa: ${companyInfo.company_description}` : \u0027- SÃ© amigable, profesional y servicial\u0027}\r\n- Usa un tono conversacional y cercano, como si fueras parte del equipo\r\n- Evita respuestas robÃ³ticas o demasiado formales\r\n- Muestra empatÃ­a y comprensiÃ³n hacia las necesidades del cliente\r\n`\r\n\r\n    // Check if we\u0027re outside business hours\r\n    const isOutsideHours = checkBusinessHours(now, companyInfo.work_start_hour, companyInfo.work_end_hour, companyInfo.timezone)\r\n\r\n    let businessHoursContext = \"\"\r\n    if (isOutsideHours \u0026\u0026 companyInfo.work_start_hour \u0026\u0026 companyInfo.work_end_hour) {\r\n        businessHoursContext = `\r\n\r\n[IMPORTANTE - FUERA DE HORARIO]\r\nActualmente estamos FUERA del horario de atenciÃ³n (${companyInfo.work_start_hour} - ${companyInfo.work_end_hour}).\r\n- Menciona amablemente que estamos fuera de horario\r\n- Asegura al cliente que su mensaje fue recibido\r\n- Indica que responderemos en cuanto abramos (${companyInfo.work_start_hour})\r\n- Si es urgente, ofrece alternativas (dejar mensaje detallado, contacto de emergencia si existe)\r\n- Puedes seguir ayudando con informaciÃ³n general, pero menciona que para procesos que requieren confirmaciÃ³n humana deberÃ¡ esperar al horario de atenciÃ³n\r\n`\r\n    }\r\n\r\n\r\n    let bookingInstruction = \"\"\r\n    // Ensure slug exists and is not the generic \u0027agendar\u0027\r\n    const validSlug = (companyInfo.slug \u0026\u0026 companyInfo.slug !== \u0027agendar\u0027) ? companyInfo.slug : null;\r\n\r\n    if (validSlug) {\r\n        const bookingLink = `https://elinaia.com.mx/${validSlug}`\r\n        console.log(`+++ [LLM] Inyectando enlace de reserva: ${bookingLink}`)\r\n        bookingInstruction = `\r\nOPCIÃ“N DE RESERVA MANUAL (ÃšNICO LINK VÃLIDO):\r\n- Si el usuario prefiere agendar por su cuenta, ofrece ESTE enlace: ${bookingLink}\r\n- PROHIBIDO usar el enlace genÃ©rico \"/agendar\". \r\n- Dile: \"Si lo prefieres, tambiÃ©n puedes agendar directamente aquÃ­: ${bookingLink}\"\r\n- Si el usuario menciona que ya agendÃ³ en la web, confÃ­a en Ã©l y no insistas con horarios.\r\n`\r\n    } else {\r\n        console.warn(`--- [LLM] No se detectÃ³ slug vÃ¡lido para el perfil. Omitiendo link manual.`)\r\n        bookingInstruction = `\r\nOPCIÃ“N DE RESERVA MANUAL:\r\n- Si el proceso por chat se complica, dile al usuario que un asesor humano le contactarÃ¡ a la brevedad para ayudarle con su cita. NO inventes enlaces de reserva.\r\n`\r\n    }\r\n\r\n    const finalSystemPrompt = `${systemPromptBase}\\n\\n${dateContext}\\n\\n${bookingInstruction}\\n\\n${companyContext}\\n\\n${businessHoursContext}\\n\\n${placeholderInstruction}\\n\\nCONTEXTO RECUPERADO:\\n${ragContext}`\r\n\r\n    // 2. Build Messages Array (Deduplicated History)\r\n    const seenMsgs = new Set\u003cstring\u003e();\r\n    const deduplicatedHistory = history.filter(m =\u003e {\r\n        const key = `${m.message_type}:${m.content.trim()}`;\r\n        if (seenMsgs.has(key)) return false;\r\n        seenMsgs.add(key);\r\n        return true;\r\n    });\r\n\r\n    const messages: any[] = [\r\n        { role: \u0027system\u0027, content: finalSystemPrompt },\r\n        ...deduplicatedHistory.map(m =\u003e ({\r\n            role: m.message_type === \u0027human\u0027 ? \u0027user\u0027 : \u0027assistant\u0027,\r\n            content: m.content\r\n        })),\r\n        { role: \u0027user\u0027, content: currentMessage }\r\n    ]\r\n\r\n    // Gemini 2.5 Flash Lite\r\n    const TARGET_MODEL = \"gemini-2.5-flash-lite\";\r\n    console.log(\"Sending to Gemini...\", {\r\n        historyLength: deduplicatedHistory.length,\r\n        originalHistory: history.length,\r\n        model: TARGET_MODEL\r\n    })\r\n\r\n    // 3. Run Loop\r\n    let turns = 0\r\n    let response = await openai.chat.completions.create({\r\n        model: TARGET_MODEL,\r\n        messages: messages,\r\n        tools: toolsDefinition,\r\n        tool_choice: \"auto\",\r\n        temperature: 0.7,\r\n        max_tokens: 800\r\n    });\r\n\r\n    let message = response.choices[0].message;\r\n\r\n    while (message.tool_calls \u0026\u0026 turns \u003c 3) {\r\n        turns++;\r\n        messages.push(message);\r\n\r\n        for (const toolCall of message.tool_calls) {\r\n            const fnName = toolCall.function.name;\r\n            const args = JSON.parse(toolCall.function.arguments);\r\n\r\n            console.log(`Executing Tool: ${fnName}`, args);\r\n\r\n            let result = \"\";\r\n            if (fnName === \u0027search_products\u0027) {\r\n                result = await searchProducts(supabase, userId, args.query);\r\n            } else if (fnName === \u0027create_appointment\u0027) {\r\n                result = await createAppointment(\r\n                    supabase,\r\n                    userId,\r\n                    { name: contactInfo.full_name, phone: contactInfo.phone_number, id: contactInfo.id },\r\n                    args.start_time,\r\n                    args.service_id,\r\n                    args.notes || \"\"\r\n                );\r\n            } else {\r\n                result = \"Herramienta no encontrada.\";\r\n            }\r\n\r\n            messages.push({\r\n                tool_call_id: toolCall.id,\r\n                role: \"tool\",\r\n                name: fnName,\r\n                content: result\r\n            });\r\n        }\r\n\r\n        response = await openai.chat.completions.create({\r\n            model: TARGET_MODEL,\r\n            messages: messages,\r\n            tools: toolsDefinition\r\n        });\r\n        message = response.choices[0].message;\r\n    }\r\n\r\n    return message.content || \"\";\r\n}\r\n",
                       "PSPath":  "H:\\DESAL\\ELina 26\\supabase\\functions\\process-chat-message\\llm.ts",
                       "PSParentPath":  "H:\\DESAL\\ELina 26\\supabase\\functions\\process-chat-message",
                       "PSChildName":  "llm.ts",
                       "PSDrive":  "H",
                       "PSProvider":  "Microsoft.PowerShell.Core\\FileSystem",
                       "ReadCount":  1
                   },
    "pcm/logic.ts":  {
                         "value":  "\r\nimport { SupabaseClient } from \u0027https://esm.sh/@supabase/supabase-js@2\u0027\r\nimport { sendMessage, sendMedia } from \u0027./evolution-client.ts\u0027\r\n\r\nexport interface ProcessedTextResult {\r\n    finalText: string\r\n    productIds: number[]\r\n    productsMap: Map\u003cnumber, any\u003e\r\n}\r\n\r\nexport async function processPlaceholders(\r\n    text: string,\r\n    supabase: SupabaseClient,\r\n    userId: string\r\n): Promise\u003cProcessedTextResult\u003e {\r\n    const placeholderRegex = /\\[[^\\]]*?(\\d+)\\]/g\r\n    const matches = [...text.matchAll(placeholderRegex)]\r\n\r\n    const productIds = [...new Set(matches.map(m =\u003e parseInt(m[1], 10)))].filter(id =\u003e !isNaN(id))\r\n\r\n    if (productIds.length === 0) {\r\n        return { finalText: text, productIds: [], productsMap: new Map() }\r\n    }\r\n\r\n    console.log(`+++ [PLACEHOLDERS] IDs detectados: ${productIds.join(\u0027, \u0027)}`)\r\n\r\n    // Fetch products with STRICT validation\r\n    const { data: products, error } = await supabase\r\n        .from(\u0027products\u0027)\r\n        .select(\u0027*\u0027)\r\n        .in(\u0027id\u0027, productIds)\r\n        .eq(\u0027user_id\u0027, userId)\r\n\r\n    if (error) {\r\n        console.error(\u0027!!! [ERROR] Fallo al obtener productos:\u0027, error)\r\n        return { finalText: text, productIds: [], productsMap: new Map() }\r\n    }\r\n\r\n    const productMap = new Map\u003cnumber, any\u003e()\r\n    const validIds = new Set\u003cnumber\u003e()\r\n\r\n    if (products) {\r\n        products.forEach(p =\u003e {\r\n            productMap.set(p.id, p)\r\n            validIds.add(p.id)\r\n        })\r\n    }\r\n\r\n    // Identify INVALID IDs (IDs that don\u0027t exist in DB)\r\n    const invalidIds = productIds.filter(id =\u003e !validIds.has(id))\r\n\r\n    if (invalidIds.length \u003e 0) {\r\n        console.warn(`!!! [VALIDACIÃ“N] IDs INVÃLIDOS detectados (no existen en BD): ${invalidIds.join(\u0027, \u0027)}`)\r\n        console.warn(`    Estos IDs serÃ¡n ELIMINADOS del texto final`)\r\n    }\r\n\r\n    console.log(`+++ [PLACEHOLDERS] IDs vÃ¡lidos: ${Array.from(validIds).join(\u0027, \u0027)}`)\r\n\r\n    let finalText = text\r\n\r\n    // 1. Replace specific fields [PRODUCT_FIELD:ID] - ONLY for valid IDs\r\n    const specificRegex = /\\[PRODUCT_(\\w+):(\\d+)\\]/g\r\n    for (const match of finalText.matchAll(specificRegex)) {\r\n        const [fullMatch, field, idStr] = match\r\n        const id = parseInt(idStr)\r\n        const product = productMap.get(id)\r\n\r\n        if (product) {\r\n            let replacement = fullMatch\r\n            switch (field.toUpperCase()) {\r\n                case \"NAME\": replacement = product.product_name; break;\r\n                case \"PRICE\": replacement = Number(product.price).toFixed(2); break;\r\n                case \"URL\": replacement = product.media_url || \"\"; break;\r\n                case \"STOCK\": replacement = String(product.stock); break;\r\n                case \"DESC\": replacement = product.description || \"\"; break;\r\n            }\r\n            finalText = finalText.replace(fullMatch, replacement)\r\n        } else {\r\n            // INVALID ID - Remove entire placeholder\r\n            console.warn(`!!! [VALIDACIÃ“N] Eliminando placeholder invÃ¡lido: ${fullMatch}`)\r\n            finalText = finalText.replace(fullMatch, \u0027\u0027)\r\n        }\r\n    }\r\n\r\n    // 2. Clean dirty placeholders (e.g. [Some Name:123]) -\u003e Product Name (ONLY valid IDs)\r\n    const messRegex = /\\[([^\\]]+):(\\d+)\\]/g\r\n    for (const match of finalText.matchAll(messRegex)) {\r\n        const [fullMatch, content, idStr] = match\r\n        const id = parseInt(idStr)\r\n        const product = productMap.get(id)\r\n\r\n        if (product) {\r\n            finalText = finalText.replace(fullMatch, product.product_name)\r\n        } else {\r\n            // INVALID ID - Remove entire placeholder\r\n            console.warn(`!!! [VALIDACIÃ“N] Eliminando placeholder invÃ¡lido: ${fullMatch}`)\r\n            finalText = finalText.replace(fullMatch, \u0027\u0027)\r\n        }\r\n    }\r\n\r\n    // 3. Calculate Subtotals and Total\r\n    finalText = calculateSubtotals(finalText, productMap)\r\n\r\n    // 4. FINAL CLEANUP: Remove any leaked IDs or weird colon patterns (Safety Net)\r\n    // Matches patterns like \":8878\", \" 8878\", \": 8878\" where ID is 4+ digits\r\n    finalText = finalText.replace(/[:\\s]+\\d{4,}/g, \u0027 \u0027)\r\n\r\n    // Clean up trailing artifacts like \" - \" or \" : \" at the end of lines\r\n    finalText = finalText.split(\u0027\\n\u0027).map(line =\u003e {\r\n        let l = line.trim();\r\n        // Remove trailing dashes, colons or vertical bars left by the cleanup\r\n        l = l.replace(/\\s*[:\\-\\|]\\s*$/g, \u0027\u0027);\r\n        // Remove IDs that might be at the end of a word like \"Corte:9528\"\r\n        l = l.replace(/:?\\d{4,}/g, \u0027\u0027);\r\n        return l;\r\n    }).join(\u0027\\n\u0027);\r\n\r\n    // Final double check for any remaining [Name:ID] format\r\n    finalText = finalText.replace(/\\[([^\\]]+):\\d+\\]/g, \u0027$1\u0027)\r\n\r\n    // Remove double spaces\r\n    finalText = finalText.replace(/ {2,}/g, \u0027 \u0027)\r\n\r\n    // [SAFETY] Deduplicate sequential repetitive paragraphs (fixes Gemini repetition bug)\r\n    finalText = deduplicateRepetitiveText(finalText)\r\n\r\n    return { finalText: finalText.trim(), productIds, productsMap: productMap }\r\n}\r\n\r\nfunction deduplicateRepetitiveText(text: string): string {\r\n    const paragraphs = text.split(\u0027\\n\\n\u0027);\r\n    const uniqueParagraphs: string[] = [];\r\n\r\n    for (const p of paragraphs) {\r\n        const trimmed = p.trim();\r\n        if (trimmed === \"\") continue;\r\n\r\n        // If this paragraph is identical or a substring of the previous one (and long enough), skip it\r\n        if (uniqueParagraphs.length \u003e 0) {\r\n            const prev = uniqueParagraphs[uniqueParagraphs.length - 1];\r\n            if (trimmed === prev || (trimmed.length \u003e 50 \u0026\u0026 prev.includes(trimmed))) {\r\n                console.log(`--- [CLEANUP] Detectada repeticiÃ³n de pÃ¡rrafo, omitiendo.`);\r\n                continue;\r\n            }\r\n        }\r\n        uniqueParagraphs.push(trimmed);\r\n    }\r\n\r\n    return uniqueParagraphs.join(\u0027\\n\\n\u0027);\r\n}\r\n\r\nfunction calculateSubtotals(text: string, productsMap: Map\u003cnumber, any\u003e): string {\r\n    const subtotalRegex = /(\\d+)\\s*piezas?\\s*Subtotal:\\s*\\$\\[subtotal_calculado\\]/gi;\r\n    let totalAcumulado = 0;\r\n\r\n    let result = text.replace(subtotalRegex, (match, qtyStr, offset) =\u003e {\r\n        const qty = parseInt(qtyStr, 10);\r\n        const textBefore = text.substring(0, offset);\r\n        const pricesFound = textBefore.match(/\\$([\\d,]+(?:\\.\\d{2})?)/g);\r\n\r\n        if (pricesFound) {\r\n            const lastPriceStr = pricesFound[pricesFound.length - 1].replace(/[$,]/g, \"\");\r\n            const price = parseFloat(lastPriceStr);\r\n            const subtotal = qty * price;\r\n            totalAcumulado += subtotal;\r\n            return `${qty} piezas Subtotal: $${subtotal.toLocaleString(\u0027es-MX\u0027, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;\r\n        }\r\n        return match;\r\n    });\r\n\r\n    result = result.replace(/\\$\\[TOTAL_CALCULADO\\]/gi, \"$\" + totalAcumulado.toLocaleString(\"es-MX\", { minimumFractionDigits: 2, maximumFractionDigits: 2 }));\r\n\r\n    return result;\r\n}\r\n\r\nfunction extractQuantity(text: string, productId: number, productName: string): number {\r\n    const lowerText = text.toLowerCase();\r\n    const patterns = [\r\n        /x\\s*(\\d+)/gi,\r\n        /(\\d+)\\s*(?:unidades?|piezas?)/gi\r\n    ];\r\n\r\n    for (const pattern of patterns) {\r\n        const matches = [...lowerText.matchAll(pattern)];\r\n        if (matches.length \u003e 0) {\r\n            return parseInt(matches[0][1], 10) || 1;\r\n        }\r\n    }\r\n    return 1;\r\n}\r\n\r\nexport function shouldGenerateQuote(\r\n    text: string,\r\n    productIds: number[],\r\n    isExplicitRequest: boolean\r\n): boolean {\r\n    const lowerText = text.toLowerCase();\r\n\r\n    // Palabras negativas que cancelan la cotizaciÃ³n\r\n    const negativeKeywords = /(?:no quiero|no necesito|solo ver|consultar)/i;\r\n\r\n    if (negativeKeywords.test(lowerText)) {\r\n        return false; // Usuario NO quiere cotizaciÃ³n\r\n    }\r\n\r\n    if (productIds.length \u003e= 3) return true;\r\n    if (productIds.length \u003e 0 \u0026\u0026 isExplicitRequest) return true;\r\n    return false;\r\n}\r\n\r\nexport async function createAndSendQuote(\r\n    supabase: SupabaseClient,\r\n    instanceName: string,\r\n    apiKey: string,\r\n    remoteJid: string,\r\n    userId: string,\r\n    contactId: number,\r\n    productIds: number[],\r\n    productsMap: Map\u003cnumber, any\u003e,\r\n    messageText: string // [NEW] Added text for extraction\r\n) {\r\n    // 1. Prepare Items with quantity extraction\r\n    const items = productIds.map(id =\u003e {\r\n        const p = productsMap.get(id)\r\n        if (!p) return null\r\n        const quantity = extractQuantity(messageText, id, p.product_name);\r\n        return {\r\n            product_id: p.id,\r\n            product_name: p.product_name,\r\n            quantity: quantity,\r\n            price: p.price,\r\n            subtotal: p.price * quantity\r\n        }\r\n    }).filter(i =\u003e i !== null)\r\n\r\n    if (items.length === 0) return\r\n\r\n    // 2. Call create-quote\r\n    const createQuoteUrl = `${Deno.env.get(\u0027SUPABASE_URL\u0027)}/functions/v1/create-quote`\r\n\r\n    try {\r\n        const res = await fetch(createQuoteUrl, {\r\n            method: \u0027POST\u0027,\r\n            headers: {\r\n                \u0027Authorization\u0027: `Bearer ${Deno.env.get(\u0027SUPABASE_SERVICE_ROLE_KEY\u0027)}`,\r\n                \u0027Content-Type\u0027: \u0027application/json\u0027\r\n            },\r\n            body: JSON.stringify({\r\n                user_id: userId,\r\n                contact_id: contactId,\r\n                items: items,\r\n                valid_until: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString() // 7 days\r\n            })\r\n        })\r\n\r\n        if (!res.ok) {\r\n            console.error(\"Failed to create quote:\", await res.text())\r\n            await sendMessage(instanceName, apiKey, remoteJid, \"Hubo un error generando tu cotizaciÃ³n PDF.\")\r\n            return\r\n        }\r\n\r\n        const data = await res.json()\r\n        const pdfUrl = data.quote.pdf_url\r\n\r\n        if (pdfUrl) {\r\n            await sendMessage(instanceName, apiKey, remoteJid, \"AquÃ­ tienes tu cotizaciÃ³n formal:\")\r\n            // Send PDF\r\n            await sendMedia(instanceName, apiKey, remoteJid, pdfUrl, \u0027document\u0027, \u0027CotizaciÃ³n.pdf\u0027, \u0027CotizaciÃ³n.pdf\u0027)\r\n        }\r\n\r\n    } catch (e) {\r\n        console.error(\"Error generating quote:\", e)\r\n    }\r\n}\r\n",
                         "PSPath":  "H:\\DESAL\\ELina 26\\supabase\\functions\\process-chat-message\\logic.ts",
                         "PSParentPath":  "H:\\DESAL\\ELina 26\\supabase\\functions\\process-chat-message",
                         "PSChildName":  "logic.ts",
                         "PSDrive":  "H",
                         "PSProvider":  "Microsoft.PowerShell.Core\\FileSystem",
                         "ReadCount":  1
                     },
    "shared/tools.ts":  {
                            "value":  "\r\nimport { SupabaseClient } from \u0027https://esm.sh/@supabase/supabase-js@2\u0027\r\n\r\nexport const toolsDefinition = [\r\n    {\r\n        type: \u0027function\u0027,\r\n        function: {\r\n            name: \u0027search_products\u0027,\r\n            description: \u0027Buscar productos en el inventario por nombre, cÃ³digo, SKU o descripciÃ³n. Ãšsala siempre que el usuario pregunte por precios, stock o informaciÃ³n de un producto.\u0027,\r\n            parameters: {\r\n                type: \u0027object\u0027,\r\n                properties: {\r\n                    query: {\r\n                        type: \u0027string\u0027,\r\n                        description: \u0027TÃ©rmino de bÃºsqueda (nombre, modelo, sku, etc). Ej: \"toner m477\", \"impresora canon\"\u0027,\r\n                    },\r\n                },\r\n                required: [\u0027query\u0027],\r\n            },\r\n        },\r\n    },\r\n]\r\n\r\nexport async function searchProducts(\r\n    supabase: SupabaseClient,\r\n    userId: string,\r\n    query: string\r\n) {\r\n    // Call the existing search-products-hybrid function\r\n    // We use the public URL or internal invoke\r\n\r\n    const functionUrl = `${Deno.env.get(\u0027SUPABASE_URL\u0027)}/functions/v1/search-products-hybrid`\r\n\r\n    try {\r\n        const response = await fetch(functionUrl, {\r\n            method: \u0027POST\u0027,\r\n            headers: {\r\n                \u0027Authorization\u0027: `Bearer ${Deno.env.get(\u0027SUPABASE_SERVICE_ROLE_KEY\u0027)}`,\r\n                \u0027Content-Type\u0027: \u0027application/json\u0027,\r\n            },\r\n            body: JSON.stringify({\r\n                user_id: userId,\r\n                query: query,\r\n                limit: 5 // Return top 5\r\n            }),\r\n        })\r\n\r\n        if (!response.ok) {\r\n            console.error(\u0027Error invoking search-products-hybrid:\u0027, await response.text())\r\n            return \"Error buscando productos.\"\r\n        }\r\n\r\n        const data = await response.json()\r\n        // Format for LLM to save tokens\r\n        if (!data.products || data.products.length === 0) {\r\n            return \"No se encontraron productos con ese tÃ©rmino.\"\r\n        }\r\n\r\n        return JSON.stringify(data.products.map((p: any) =\u003e ({\r\n            id: p.id,\r\n            name: p.product_name,\r\n            price: p.price,\r\n            stock: p.stock,\r\n            description: p.description,\r\n            url: p.media_url,\r\n            score: p.relevance_score // Optional, maybe helpful for LLM to know confidence\r\n        })))\r\n\r\n    } catch (err) {\r\n        console.error(\u0027Exception in searchProducts:\u0027, err)\r\n        return \"Error al conectar con la base de datos de productos.\"\r\n    }\r\n}\r\n",
                            "PSPath":  "H:\\DESAL\\ELina 26\\supabase\\functions\\_shared\\tools.ts",
                            "PSParentPath":  "H:\\DESAL\\ELina 26\\supabase\\functions\\_shared",
                            "PSChildName":  "tools.ts",
                            "PSDrive":  "H",
                            "PSProvider":  "Microsoft.PowerShell.Core\\FileSystem",
                            "ReadCount":  1
                        },
    "pcm/index.ts":  {
                         "value":  "\r\nimport { serve } from \"https://deno.land/std@0.168.0/http/server.ts\"\r\nimport { createSupabaseAdminClient } from \"./supabase-client.ts\"\r\nimport { corsHeaders } from \"./cors.ts\"\r\nimport { getProfileByInstance, ensureContact, getChatHistory, getSubscription, hasIgnoreTag, getActivePromotion, formatPromotionText, getAppointmentSettings, getAvailableSlots, formatAppointmentContext, detectAppointmentIntent, detectCriticalIntent, recordMetric, getMessageBuffer, pushMessageBuffer, uploadToBunnyCDN, getAvailableServices, checkPresetResponse } from \"./context.ts\"\r\nimport { getRagContext, detectObjections } from \"./rag.ts\"\r\nimport { runAgent } from \"./llm.ts\"\r\nimport { processPlaceholders, shouldGenerateQuote, createAndSendQuote } from \"./logic.ts\"\r\nimport { sendMessage, sendImage, sendVideo, sendAudio, getMediaUrl, EVOLUTION_API_URL } from \"./evolution-client.ts\"\r\nimport { processMedia, generateAudio } from \"./media.ts\"\r\n\r\nconsole.log(\"Process Chat Message Function Started v2.0 (Master Orchestrator)\")\r\n\r\nserve(async (req) =\u003e {\r\n    // 1. Handle CORS\r\n    if (req.method === \u0027OPTIONS\u0027) {\r\n        return new Response(\u0027ok\u0027, { headers: corsHeaders })\r\n    }\r\n\r\n    const start = performance.now()\r\n    try {\r\n        const supabase = createSupabaseAdminClient()\r\n        const payload = await req.json()\r\n\r\n        console.log(\"\u003e\u003e\u003e [PROCESO INICIO] Webhook recibido.\", { timestamp: new Date().toISOString() })\r\n\r\n        // 2. Extract Basic Info\r\n        const data = payload?.data\r\n        if (!data) {\r\n            console.error(\"!!! [ERROR] Payload invÃ¡lido: \u0027data\u0027 no existe.\")\r\n            return new Response(JSON.stringify({ error: \u0027Invalid payload\u0027 }), {\r\n                headers: { ...corsHeaders, \u0027Content-Type\u0027: \u0027application/json\u0027 },\r\n                status: 400,\r\n            })\r\n        }\r\n\r\n        const { key, message, pushName } = data\r\n        let remoteJid = key?.remoteJid\r\n\r\n        // Manejo especial para LID (Linked Devices)\r\n        if (remoteJid \u0026\u0026 remoteJid.includes(\"@lid\")) {\r\n            remoteJid = key?.remoteJidAlt || remoteJid;\r\n        }\r\n\r\n        // Limpiar sufijo\r\n        remoteJid = remoteJid?.replace(\"@s.whatsapp.net\", \"\");\r\n\r\n        const messageId = key?.id\r\n        const instanceName = payload?.instance\r\n        const apiKey = payload?.apikey || payload?.instance_apikey\r\n\r\n        console.log(`--- [INFO] Datos extraÃ­dos: Instance=${instanceName}, Jid=${remoteJid}, MsgId=${messageId}`)\r\n\r\n        if (!remoteJid || !messageId || !instanceName) {\r\n            console.error(\u0027!!! [ERROR] Faltan campos clave (remoteJid, messageId, instanceName)\u0027)\r\n            return new Response(JSON.stringify({ error: \u0027Missing key fields\u0027 }), { status: 400 })\r\n        }\r\n\r\n        if (remoteJid === \u0027status@broadcast\u0027 || key?.fromMe) {\r\n            console.log(\"--- [INFO] Ignorando mensaje (status@broadcast o fromMe).\")\r\n            return new Response(JSON.stringify({ message: \u0027Ignored status update or own message\u0027 }), { status: 200 })\r\n        }\r\n\r\n        // Check Redis buffer for duplicates (Early lock)\r\n        const buffer = await getMessageBuffer(remoteJid)\r\n        if (buffer.includes(messageId)) {\r\n            console.log(\u0027--- [REDIS] Mensaje duplicado detectado al inicio, ignorando\u0027)\r\n            return new Response(JSON.stringify({ message: \u0027Duplicate message already in progress\u0027 }), { status: 200 })\r\n        }\r\n\r\n        // Add to buffer immediately to block concurrent retries\r\n        await pushMessageBuffer(remoteJid, messageId)\r\n\r\n        // 3. Get Profile\r\n        console.log(`... [PASO 1] Buscando perfil para instancia: ${instanceName}`)\r\n        const profile = await getProfileByInstance(supabase, instanceName)\r\n        if (!profile) {\r\n            console.error(`!!! [ERROR] Perfil no encontrado para instancia: ${instanceName}`)\r\n            return new Response(JSON.stringify({ error: \u0027Profile not found\u0027 }), { status: 404 })\r\n        }\r\n        console.log(`+++ [EXITO] Perfil encontrado: ${profile.id}. URL Evolution: ${profile.evolution_api_url}`)\r\n\r\n        // Use API Key from profile if not in payload (safer)\r\n        const evolutionApiKey = profile.evolution_api_key\r\n\r\n        // 4. Ensure Contact\r\n        console.log(`... [PASO 2] Buscando/Creando contacto: ${pushName || remoteJid}`)\r\n        const contact = await ensureContact(supabase, profile.id, remoteJid, pushName)\r\n        if (!contact) {\r\n            console.error(\u0027!!! [ERROR] FallÃ³ la creaciÃ³n/obtenciÃ³n del contacto\u0027)\r\n            return new Response(JSON.stringify({ error: \u0027Contact error\u0027 }), { status: 500 })\r\n        }\r\n        console.log(`+++ [EXITO] Contacto ID: ${contact.id}`)\r\n\r\n        // Record metric: message_received\r\n        await recordMetric(supabase, profile.id, contact.id, \u0027message_received\u0027, {\r\n            message_id: messageId,\r\n            remote_jid: remoteJid\r\n        })\r\n\r\n        // 4.1. Check if contact has \"ignorar\" tag\r\n        if (hasIgnoreTag(contact)) {\r\n            console.log(\"--- [INFO] Contacto tiene etiqueta \u0027ignorar\u0027. Mensaje ignorado.\")\r\n            return new Response(JSON.stringify({ message: \u0027Contact ignored\u0027 }), { status: 200 })\r\n        }\r\n\r\n        // 4.2. Validate subscription\r\n        console.log(`... [VALIDACIÃ“N] Verificando suscripciÃ³n activa...`)\r\n\r\n        const rawText = message?.conversation || message?.extendedTextMessage?.text || \"\";\r\n        if (rawText !== \u0027TEST_PING\u0027) {\r\n            const subscription = await getSubscription(supabase, profile.id)\r\n\r\n            // Check if subscription is active or in trial period (simple check)\r\n            const isActive = subscription?.status === \u0027active\u0027 || subscription?.status === \u0027trialing\u0027\r\n\r\n            if (!subscription || !isActive) {\r\n                console.error(`!!! [ERROR] SuscripciÃ³n inactiva para user_id: ${profile.id}. Status: ${subscription?.status}`)\r\n                return new Response(JSON.stringify({ error: \u0027Subscription inactive\u0027 }), { status: 403 })\r\n            }\r\n            console.log(`+++ [EXITO] SuscripciÃ³n activa/trial: ${subscription.plan_id}`)\r\n        } else {\r\n            console.log(\"\u003e\u003e\u003e [TEST] Bypassing subscription check for TEST_PING\")\r\n        }\r\n\r\n        // 5. Process Content \u0026 Media\r\n        let text = \"\"\r\n        let originalType = \"text\"\r\n\r\n        // Evolution API logic for content extraction\r\n        if (message?.conversation) {\r\n            text = message.conversation\r\n        } else if (message?.extendedTextMessage?.text) {\r\n            text = message.extendedTextMessage.text\r\n        } else if (message?.imageMessage) {\r\n            originalType = \"image\"\r\n            console.log(\"... [MEDIA] Imagen detectada. Procesando con VisiÃ³n...\")\r\n            // Process Image\r\n            text = await processMedia(instanceName, evolutionApiKey, messageId, \u0027image\u0027, profile.evolution_api_url)\r\n            console.log(`+++ [MEDIA] Imagen descrita: \"${text.substring(0, 50)}...\"`)\r\n            if (!text) text = \" [Imagen enviada] \" // Fallback if vision fails\r\n        } else if (message?.audioMessage) {\r\n            originalType = \"audio\"\r\n            console.log(\"... [MEDIA] Audio detectado. Transcribiendo con Whisper...\")\r\n            // Process Audio\r\n            text = await processMedia(instanceName, evolutionApiKey, messageId, \u0027audio\u0027, profile.evolution_api_url)\r\n            console.log(`+++ [MEDIA] Audio transcrito: \"${text}\"`)\r\n            if (!text) text = \" [Audio enviado] \" // Fallback\r\n        } else if (message?.videoMessage) {\r\n            originalType = \"video\"\r\n            console.log(\"... [MEDIA] Video detectado (no soportado para anÃ¡lisis)\")\r\n            text = \" [Video enviado] \"\r\n        } else if (message?.documentMessage) {\r\n            originalType = \"document\"\r\n            console.log(\"!!! [MEDIA] Documento detectado (tipo no soportado)\")\r\n            await sendMessage(instanceName, evolutionApiKey, remoteJid, \"âš ï¸ Lo siento, actualmente no puedo procesar documentos PDF, Word u otros archivos. Por favor, envÃ­a tu mensaje como texto o imagen.\", profile.evolution_api_url, { delay: 1500, linkPreview: false })\r\n            return new Response(JSON.stringify({ message: \u0027Unsupported file type: document\u0027 }), { status: 200 })\r\n        } else {\r\n            // Other unsupported types\r\n            console.log(\"!!! [MEDIA] Tipo de mensaje no soportado\")\r\n            await sendMessage(instanceName, evolutionApiKey, remoteJid, \"âš ï¸ Lo siento, no puedo procesar este tipo de mensaje. Por favor, envÃ­a texto, imagen o audio.\", profile.evolution_api_url, { delay: 1500, linkPreview: false })\r\n            return new Response(JSON.stringify({ message: \u0027Unsupported message type\u0027 }), { status: 200 })\r\n        }\r\n\r\n        if (!text || text.trim().length === 0) {\r\n            console.warn(\"--- [WARN] No hay contenido textual para procesar.\")\r\n            return new Response(JSON.stringify({ message: \u0027No textual content to process\u0027 }), { status: 200 })\r\n        }\r\n\r\n        // 4.1 Check Appointment Settings EARLY (Crucial for critical intent logic)\r\n        console.log(`... [PASO 2] Verificando configuraciÃ³n de citas...`)\r\n        const appointmentSettings = await getAppointmentSettings(supabase, profile.id)\r\n        const hasAppointmentIntent = detectAppointmentIntent(text)\r\n\r\n        // 4.2 Force Critical Intent if Appointment Requested but Disabled\r\n        if (hasAppointmentIntent \u0026\u0026 (!appointmentSettings || !appointmentSettings.is_enabled)) {\r\n            console.error(`!!! [CRÃTICO] Usuario pide cita pero el sistema estÃ¡ desactivado. FORZANDO HANDOVER.`)\r\n\r\n            // Force critical response structure\r\n            const criticalResponse = {\r\n                is_critical: true,\r\n                detection_type: \u0027appointment_request_manual\u0027,\r\n                confidence: 1.0,\r\n                detected_content: text,\r\n                reason: \u0027User requested appointment but system is disabled\u0027\r\n            }\r\n\r\n            // Execute critical logic (notifications, tagging)\r\n            // Add \"ignorar\" label to contact\r\n            const currentLabels = contact.labels || []\r\n            if (!currentLabels.includes(\u0027ignorar\u0027)) {\r\n                await supabase.from(\u0027contacts\u0027).update({\r\n                    labels: [...currentLabels, \u0027ignorar\u0027],\r\n                    razon_de_label_auto: criticalResponse.reason\r\n                }).eq(\u0027id\u0027, contact.id)\r\n                console.log(`+++ [CRÃTICO] Etiqueta \"ignorar\" agregada al contacto`)\r\n            }\r\n\r\n            // Pause active followups\r\n            await supabase.from(\u0027contacts\u0027).update({\r\n                followup_status: \u0027paused\u0027\r\n            }).eq(\u0027id\u0027, contact.id).not(\u0027followup_status\u0027, \u0027is\u0027, null)\r\n\r\n            // Notification\r\n            if (profile.contact_phone) {\r\n                const notificationMessage = `ðŸš¨ ATENCIÃ“N REQUERIDA (CITAS)\\n\\nContacto: ${contact.full_name || contact.phone_number}\\nMotivo: El usuario quiere agendar pero tu sistema de citas estÃ¡ DESACTIVADO.\\n\\nMensaje:\\n${text}`\r\n                try {\r\n                    await sendMessage(\u0027ElinaHead\u0027, evolutionApiKey, profile.contact_phone, notificationMessage, profile.evolution_api_url, { delay: 1500, linkPreview: false })\r\n                    console.log(`+++ [CRÃTICO] NotificaciÃ³n enviada a ${profile.contact_phone}`)\r\n                } catch (err) {\r\n                    console.error(`!!! [ERROR] No se pudo enviar notificaciÃ³n:`, err)\r\n                }\r\n            }\r\n\r\n            return new Response(JSON.stringify({\r\n                message: \u0027Critical intent forced (Appointment Disabled)\u0027,\r\n                is_critical: true,\r\n                detection_type: criticalResponse.detection_type\r\n            }), { status: 200 })\r\n        }\r\n\r\n        // 5.1. Detect Critical Intent (Normal flow)\r\n        console.log(`... [CRÃTICO] Analizando intenciÃ³n crÃ­tica (General)...`)\r\n        const criticalResponse = await detectCriticalIntent(contact.id, profile.id, text)\r\n\r\n        if (criticalResponse?.is_critical) {\r\n            console.error(`!!! [CRÃTICO] IntenciÃ³n crÃ­tica detectada: ${criticalResponse.detection_type || \u0027desconocido\u0027}`)\r\n\r\n            // Add \"ignorar\" label to contact\r\n            const currentLabels = contact.labels || []\r\n            if (!currentLabels.includes(\u0027ignorar\u0027)) {\r\n                await supabase.from(\u0027contacts\u0027).update({\r\n                    labels: [...currentLabels, \u0027ignorar\u0027],\r\n                    razon_de_label_auto: criticalResponse.reason || `IntenciÃ³n crÃ­tica: ${criticalResponse.detection_type}`\r\n                }).eq(\u0027id\u0027, contact.id)\r\n                console.log(`+++ [CRÃTICO] Etiqueta \"ignorar\" agregada al contacto`)\r\n            }\r\n\r\n            // Pause active followups if applicable\r\n            await supabase.from(\u0027contacts\u0027).update({\r\n                followup_status: \u0027paused\u0027\r\n            }).eq(\u0027id\u0027, contact.id).not(\u0027followup_status\u0027, \u0027is\u0027, null)\r\n\r\n            // Send notification to owner if contact_phone exists\r\n            if (profile.contact_phone) {\r\n                const notificationMessage = `ðŸš¨ ATENCIÃ“N REQUERIDA\\n\\nContacto: ${contact.full_name || contact.phone_number}\\nTipo: ${criticalResponse.detection_type || \u0027CrÃ­tico\u0027}\\nConfianza: ${Math.round((criticalResponse.confidence || 0) * 100)}%\\n\\nMensaje:\\n${criticalResponse.detected_content || text}\\n\\nMotivo: ${criticalResponse.reason || \u0027Requiere atenciÃ³n humana\u0027}`\r\n\r\n                try {\r\n                    await sendMessage(\u0027ElinaHead\u0027, evolutionApiKey, profile.contact_phone, notificationMessage, profile.evolution_api_url, { delay: 1500, linkPreview: false })\r\n                    console.log(`+++ [CRÃTICO] NotificaciÃ³n enviada a ${profile.contact_phone}`)\r\n                } catch (err) {\r\n                    console.error(`!!! [ERROR] No se pudo enviar notificaciÃ³n:`, err)\r\n                }\r\n            }\r\n\r\n            return new Response(JSON.stringify({\r\n                message: \u0027Critical intent detected, contact tagged and owner notified\u0027,\r\n                is_critical: true,\r\n                detection_type: criticalResponse.detection_type\r\n            }), { status: 200 })\r\n        }\r\n        console.log(`+++ [CRÃTICO] No se detectÃ³ intenciÃ³n crÃ­tica`)\r\n\r\n        // 5.2. Check Preset Responses (BEFORE AI)\r\n        console.log(`... [PRESET] Verificando respuestas programadas...`)\r\n        const presetResponse = await checkPresetResponse(supabase, profile.id, text)\r\n\r\n        if (presetResponse) {\r\n            console.log(`+++ [PRESET] Respuesta automÃ¡tica detectada: \"${presetResponse.trigger_text}\" (${presetResponse.match_type})`)\r\n\r\n            // Save user message\r\n            await supabase.from(\u0027chat_history\u0027).insert({\r\n                user_id: profile.id,\r\n                contact_id: contact.id,\r\n                message_type: \u0027human\u0027,\r\n                content: text,\r\n                created_at: new Date().toISOString()\r\n            })\r\n\r\n            // Save preset response to history\r\n            await supabase.from(\u0027chat_history\u0027).insert({\r\n                user_id: profile.id,\r\n                contact_id: contact.id,\r\n                message_type: \u0027ai\u0027,\r\n                content: presetResponse.response_text,\r\n                created_at: new Date().toISOString()\r\n            })\r\n\r\n            // Record metric\r\n            await recordMetric(supabase, profile.id, contact.id, \u0027preset_response_sent\u0027, {\r\n                trigger: presetResponse.trigger_text,\r\n                match_type: presetResponse.match_type\r\n            })\r\n\r\n            // Pause active followups (user responded)\r\n            const { data: contactData } = await supabase\r\n                .from(\u0027contacts\u0027)\r\n                .select(\u0027followup_status\u0027)\r\n                .eq(\u0027id\u0027, contact.id)\r\n                .single()\r\n\r\n            if (contactData?.followup_status === \u0027active\u0027) {\r\n                await supabase.from(\u0027contacts\u0027).update({\r\n                    followup_status: \u0027paused\u0027,\r\n                    last_interaction_at: new Date().toISOString()\r\n                }).eq(\u0027id\u0027, contact.id).eq(\u0027followup_status\u0027, \u0027active\u0027)\r\n\r\n                console.log(`+++ [FOLLOWUP] Seguimiento pausado para contacto ${contact.id}`)\r\n            }\r\n\r\n            // Return preset response for n8n to send\r\n            return new Response(JSON.stringify({\r\n                success: true,\r\n                processed: true,\r\n                preset_response: true,\r\n                data: {\r\n                    user_id: profile.id,\r\n                    contact_id: contact.id,\r\n                    message_processed: text,\r\n                    original_type: originalType,\r\n                    is_critical: false,\r\n                    generated_response: presetResponse.response_text,\r\n                    output: presetResponse.response_text,\r\n                    media_type: presetResponse.media_type || \u0027text\u0027,\r\n                    media_url: presetResponse.media_url || \u0027\u0027,\r\n                    quote_generated: false,\r\n                    product_ids: []\r\n                }\r\n            }), {\r\n                headers: { ...corsHeaders, \u0027Content-Type\u0027: \u0027application/json\u0027 },\r\n                status: 200,\r\n            })\r\n        }\r\n        console.log(`+++ [PRESET] No se encontrÃ³ respuesta programada`)\r\n\r\n        console.log(`\u003e\u003e\u003e [PROCESAMIENTO] Mensaje Final (\"${text.substring(0, 50)}...\") de ${contact.full_name}`)\r\n\r\n        // 6. Context \u0026 RAG (Parallel)\r\n        console.log(\"... [PASO 3] Obteniendo Historial, RAG y PromociÃ³n activa...\")\r\n        const [history, ragContext, activePromo, detectedObjections] = await Promise.all([\r\n            getChatHistory(supabase, profile.id, contact.id),\r\n            getRagContext(supabase, profile.id, contact.id.toString(), text),\r\n            getActivePromotion(supabase, profile.id),\r\n            detectObjections(supabase, profile.id, text)\r\n        ])\r\n        console.log(`+++ [CONTEXTO] Historial con ${history.length} mensajes. RAG Contexto: ${ragContext ? \u0027SÃ\u0027 : \u0027NO\u0027}. PromociÃ³n activa: ${activePromo ? \u0027SÃ\u0027 : \u0027NO\u0027}`)\r\n\r\n        // Log detected objections\r\n        if (detectedObjections.length \u003e 0) {\r\n            console.log(`+++ [OBJECIONES] ${detectedObjections.length} objeciones detectadas:`)\r\n            detectedObjections.forEach(obj =\u003e {\r\n                console.log(`    - \"${obj.objection}\" (confianza: ${(obj.confidence * 100).toFixed(1)}%)`)\r\n            })\r\n        }\r\n\r\n        // 6.2. Handle Appointments (Settings already fetched above)\r\n        let servicesContext = \"\"\r\n        let appointmentContext = \"\"\r\n        let slotsData: any[] = [] // Define in outer scope\r\n\r\n        if (appointmentSettings?.is_enabled) {\r\n            // Always get services so the agent knows what can be booked\r\n            const services = await getAvailableServices(supabase, profile.id)\r\n            if (services.length \u003e 0) {\r\n                servicesContext = `CATÃLOGO DE SERVICIOS (Usa el ID solo para herramientas):\\n${services.map((s: any) =\u003e `- SERVICIO: ${s.name} | ID: ${s.id}${s.description ? \u0027 | DESC: \u0027 + s.description : \u0027\u0027}`).join(\u0027\\n\u0027)}\\n`\r\n                console.log(`+++ [CITAS] ${services.length} servicios cargados`)\r\n            }\r\n\r\n            // Only get slots if there\u0027s clear intent to book\r\n            if (hasAppointmentIntent) {\r\n                console.log(`... [CITAS] Intent detectado, buscando slots...`)\r\n                slotsData = await getAvailableSlots(profile.id) // Assign to var\r\n                if (slotsData \u0026\u0026 slotsData.length \u003e 0) {\r\n                    appointmentContext = formatAppointmentContext(slotsData)\r\n                    console.log(`+++ [CITAS] ${slotsData.length} dÃ­as de slots cargados`)\r\n                }\r\n            }\r\n        }\r\n\r\n        // 6.3. Construct Final RAG Context with Objections\r\n        let finalRagContext = servicesContext + appointmentContext + (ragContext ? \u0027\\n\\n\u0027 + ragContext : \"\")\r\n\r\n        // Add detected objections to context\r\n        if (detectedObjections.length \u003e 0) {\r\n            const objectionsContext = `\\n\\n[OBJECIONES DETECTADAS]\\nEl mensaje del cliente parece contener una objeciÃ³n. AquÃ­ estÃ¡n las posibles objeciones y cÃ³mo manejarlas:\\n\\n${detectedObjections.map((obj, idx) =\u003e\r\n                `${idx + 1}. ObjeciÃ³n: \"${obj.objection}\" (Confianza: ${(obj.confidence * 100).toFixed(0)}%)\\n   Respuesta sugerida: ${obj.response}\\n   IMPORTANTE: Usa esta respuesta como GUÃA, no la copies exactamente. Adapta el tono y personaliza segÃºn el contexto.`\r\n            ).join(\u0027\\n\\n\u0027)}`\r\n\r\n            finalRagContext += objectionsContext\r\n            console.log(`+++ [OBJECIONES] Contexto de objeciones agregado al RAG`)\r\n        }\r\n\r\n        if (activePromo) {\r\n            const promoText = formatPromotionText(activePromo)\r\n            finalRagContext += `\\n\\n[PROMOCIÃ“N ACTIVA]:\\n${promoText}`\r\n            console.log(`+++ [PROMO] PromociÃ³n inyectada: \"${activePromo.title}\"`)\r\n        }\r\n\r\n        // 7. Save User Message (Async, don\u0027t block logic excessively but good to have saved)\r\n        await supabase.from(\u0027chat_history\u0027).insert({\r\n            user_id: profile.id,\r\n            contact_id: contact.id,\r\n            message_type: \u0027human\u0027,\r\n            content: text,\r\n            created_at: new Date().toISOString()\r\n        })\r\n\r\n        // 7.1. Check if this is first message\r\n        const isFirstMessage = history.length === 0\r\n        let systemPrompt = profile.prompt_content || \"Eres ELINA, una asistente virtual Ãºtil.\"\r\n\r\n        if (isFirstMessage) {\r\n            systemPrompt += `\\n\\n[IMPORTANTE]: Este es el PRIMER mensaje de este contacto. Dale una bienvenida cÃ¡lida y personalizada. PresÃ©ntate como ELINA y pregunta cÃ³mo puedes ayudarle hoy.`\r\n            console.log(`+++ [PRIMER MENSAJE] Detectado primer contacto, agregando contexto de bienvenida`)\r\n\r\n            // Record metric\r\n            await recordMetric(supabase, profile.id, contact.id, \u0027first_message\u0027, {\r\n                contact_name: contact.full_name,\r\n                contact_phone: contact.phone_number\r\n            })\r\n        }\r\n\r\n        // =================================================================================\r\n        // [MODO CONTEXTO] Salida anticipada para n8n\r\n        // Si el usuario solo quiere enriquecer el contexto para procesarlo en n8n\r\n        // =================================================================================\r\n        if (payload?.return_context_only === true) {\r\n            console.log(\"\u003e\u003e\u003e [MODO CONTEXTO] Retornando datos a n8n sin ejecutar LLM/EnvÃ­o.\")\r\n            return new Response(JSON.stringify({\r\n                success: true,\r\n                mode: \u0027context_only\u0027,\r\n                data: {\r\n                    contact,\r\n                    profile,\r\n                    history,\r\n                    rag_context: finalRagContext, // Incluye RAG + Promos + Citas\r\n                    system_prompt: systemPrompt,\r\n                    is_critical: false,\r\n                    active_promo: activePromo,\r\n                    appointment_settings: appointmentSettings?.is_enabled ? appointmentSettings : null,\r\n                    text_processed: text,\r\n                    original_type: originalType\r\n                }\r\n            }), {\r\n                headers: { ...corsHeaders, \u0027Content-Type\u0027: \u0027application/json\u0027 },\r\n                status: 200,\r\n            })\r\n        }\r\n\r\n        // 8. Run Agent\r\n        console.log(\"... [PASO 4] Ejecutando Agente (Gemini)...\")\r\n        const aiResponseRaw = await runAgent(\r\n            supabase,\r\n            profile.id,\r\n            history,\r\n            text,\r\n            finalRagContext,\r\n            systemPrompt,\r\n            profile,\r\n            contact\r\n        )\r\n        console.log(`+++ [AGENTE] Respuesta Raw (len=${aiResponseRaw.length}): \"${aiResponseRaw.substring(0, 100)}...\"`)\r\n\r\n        // 9. Logic (Placeholders)\r\n        console.log(\"... [PASO 5] Procesando placeholders...\")\r\n        const { finalText: aiResponseProcessed, productIds, productsMap } = await processPlaceholders(aiResponseRaw, supabase, profile.id)\r\n        if (productIds.length \u003e 0) console.log(`+++ [PLACEHOLDERS] IDs encontrados: ${productIds.join(\u0027, \u0027)}`)\r\n\r\n        // 10. Detect and Send Media (Images/Videos)\r\n        console.log(`... [PASO 6] Detectando media en respuesta...`)\r\n\r\n        let finalResponseType = \u0027text\u0027\r\n        let finalMediaUrl = \u0027\u0027\r\n        let finalOutputText = aiResponseProcessed\r\n\r\n        // Check for image marker: url_imagen:https://...\r\n        const imageMatch = aiResponseProcessed.match(/url_imagen:\\s*(https?:\\/\\/[^\\s]+)/i)\r\n        if (imageMatch) {\r\n            const imageUrl = imageMatch[1]\r\n            const textWithoutImage = aiResponseProcessed.replace(/url_imagen:\\s*https?:\\/\\/[^\\s]+/gi, \u0027\u0027).trim()\r\n            console.log(`+++ [IMAGEN] Detectada imagen: ${imageUrl}`)\r\n\r\n            finalResponseType = \u0027image\u0027\r\n            finalMediaUrl = imageUrl\r\n            finalOutputText = textWithoutImage // Output clean text for n8n\r\n\r\n            // Record history (but n8n will send)\r\n            await supabase.from(\u0027chat_history\u0027).insert({\r\n                user_id: profile.id,\r\n                contact_id: contact.id,\r\n                message_type: \u0027ai\u0027,\r\n                content: aiResponseProcessed,\r\n                created_at: new Date().toISOString()\r\n            })\r\n\r\n        } else {\r\n            // Check for video marker: urlVideo:https://...\r\n            const videoMatch = aiResponseProcessed.match(/urlVideo:\\s*(https?:\\/\\/[^\\s]+)/i)\r\n            if (videoMatch) {\r\n                const videoUrl = videoMatch[1]\r\n                const textWithoutVideo = aiResponseProcessed.replace(/urlVideo:\\s*https?:\\/\\/[^\\s]+/gi, \u0027\u0027).trim()\r\n                console.log(`+++ [VIDEO] Detectado video: ${videoUrl}`)\r\n\r\n                finalResponseType = \u0027video\u0027\r\n                finalMediaUrl = videoUrl\r\n                finalOutputText = textWithoutVideo\r\n\r\n                await supabase.from(\u0027chat_history\u0027).insert({\r\n                    user_id: profile.id,\r\n                    contact_id: contact.id,\r\n                    message_type: \u0027ai\u0027,\r\n                    content: aiResponseProcessed,\r\n                    created_at: new Date().toISOString()\r\n                })\r\n\r\n            } else {\r\n                // No media detected, send as normal text or audio\r\n                console.log(`... [PASO 7] Preparando respuesta para n8n (Tipo origen: ${originalType})...`)\r\n\r\n                // If input was audio, prepare audio response\r\n                if (originalType === \u0027audio\u0027) {\r\n                    console.log(\"... [AUDIO] Generando audio de respuesta (ElevenLabs)...\")\r\n                    const audioDataUrl = await generateAudio(aiResponseProcessed)\r\n                    if (audioDataUrl) {\r\n                        console.log(\"+++ [AUDIO] Audio generado.\")\r\n                        finalResponseType = \u0027audio\u0027\r\n                        finalMediaUrl = audioDataUrl\r\n                        finalOutputText = aiResponseProcessed\r\n                    } else {\r\n                        console.error(\"!!! [ERROR] FallÃ³ generaciÃ³n audio. Retornando solo texto.\")\r\n                        finalResponseType = \u0027text\u0027\r\n                        finalOutputText = aiResponseProcessed\r\n                    }\r\n                } else {\r\n                    // Normal text\r\n                    finalResponseType = \u0027text\u0027\r\n                    finalOutputText = aiResponseProcessed\r\n                }\r\n\r\n                // Save AI Message\r\n                await supabase.from(\u0027chat_history\u0027).insert({\r\n                    user_id: profile.id,\r\n                    contact_id: contact.id,\r\n                    message_type: \u0027ai\u0027,\r\n                    content: aiResponseProcessed,\r\n                    created_at: new Date().toISOString()\r\n                })\r\n\r\n                // Record metric: message_sent\r\n                await recordMetric(supabase, profile.id, contact.id, \u0027message_sent\u0027, {\r\n                    message_length: aiResponseProcessed.length,\r\n                    original_type: originalType\r\n                })\r\n\r\n                // Trigger auto-tags analysis (async, non-blocking)\r\n                const SUPABASE_URL = Deno.env.get(\u0027SUPABASE_URL\u0027)\r\n                const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get(\u0027SUPABASE_SERVICE_ROLE_KEY\u0027)\r\n\r\n                if (SUPABASE_URL \u0026\u0026 SUPABASE_SERVICE_ROLE_KEY) {\r\n                    // Fire and forget - don\u0027t await\r\n                    fetch(`${SUPABASE_URL}/functions/v1/apply-auto-tags`, {\r\n                        method: \u0027POST\u0027,\r\n                        headers: {\r\n                            \u0027Authorization\u0027: `Bearer ${SUPABASE_SERVICE_ROLE_KEY}`,\r\n                            \u0027Content-Type\u0027: \u0027application/json\u0027\r\n                        },\r\n                        body: JSON.stringify({\r\n                            user_id: profile.id,\r\n                            contact_id: contact.id\r\n                        })\r\n                    }).catch(err =\u003e console.error(\u0027[AUTO-TAGS] Error calling function:\u0027, err))\r\n\r\n                    console.log(\u0027+++ [AUTO-TAGS] AnÃ¡lisis disparado en background\u0027)\r\n                }\r\n            }\r\n        }\r\n\r\n        // 11. Pause active followups (user responded)\r\n        console.log(`... [FOLLOWUP] Verificando seguimientos activos...`)\r\n        const { data: contactData } = await supabase\r\n            .from(\u0027contacts\u0027)\r\n            .select(\u0027followup_status\u0027)\r\n            .eq(\u0027id\u0027, contact.id)\r\n            .single()\r\n\r\n        if (contactData?.followup_status === \u0027active\u0027) {\r\n            await supabase.from(\u0027contacts\u0027).update({\r\n                followup_status: \u0027paused\u0027,\r\n                last_interaction_at: new Date().toISOString()\r\n            }).eq(\u0027id\u0027, contact.id).eq(\u0027followup_status\u0027, \u0027active\u0027)\r\n\r\n            console.log(`+++ [FOLLOWUP] Seguimiento pausado para contacto ${contact.id}`)\r\n        }\r\n\r\n        // 12. Quote Logic (Still handled by Edge as it includes PDF generation and complex logic, or should we return it too? KEEPING IT here for now as user asked to handle MESSAGE sending in n8n, quote is a side effect but sends PDF...)\r\n        // Actually, user wants n8n control. Let\u0027s return quote data if needed.\r\n        // For parity, let\u0027s keep quote generation here for PDF but maybe let n8n send it? \r\n        // Logic `createAndSendQuote` sends it. Let\u0027s assume Quotes are complex and keep them here OR modify `createAndSendQuote` to return URL.\r\n        // Given constraint \"user wants n8n to send\", safest is to handle standard chat. Quotes are special flow. Let\u0027s keep existing Quote behavior for now unless user complains about Quote sending.\r\n\r\n        const textLower = text.toLowerCase()\r\n        const cierreKeywords = /(?:cotizaciÃ³n|cotizacion|presupuesto|generar pdf|enviar pdf|formalizar|documento|precio final)/i\r\n        const negativeKeywords = /(?:no quiero|no necesito|solo ver|consultar)/i\r\n\r\n        const isExplicitRequest = cierreKeywords.test(textLower) \u0026\u0026 !negativeKeywords.test(textLower)\r\n\r\n        if (shouldGenerateQuote(aiResponseProcessed, productIds, isExplicitRequest)) {\r\n            console.log(\"... [COTIZACION] Detectada necesidad de cotizaciÃ³n. Generando PDF...\")\r\n            // We keep this running here as it might be complex to move fully to n8n instantly without new nodes\r\n            await createAndSendQuote(\r\n                supabase,\r\n                instanceName,\r\n                evolutionApiKey,\r\n                remoteJid,\r\n                profile.id,\r\n                contact.id,\r\n                productIds,\r\n                productsMap,\r\n                text\r\n            )\r\n            console.log(\"+++ [COTIZACION] Proceso de cotizaciÃ³n finalizado.\")\r\n        }\r\n\r\n        const duration = performance.now() - start\r\n        console.log(`\u003e\u003e\u003e [FIN] Proceso completado exitosamente en ${duration.toFixed(0)}ms`)\r\n\r\n        return new Response(JSON.stringify({\r\n            success: true,\r\n            processed: true,\r\n            data: {\r\n                user_id: profile.id,\r\n                contact_id: contact.id,\r\n                message_processed: text,\r\n                original_type: originalType,\r\n                is_critical: false,\r\n                has_appointment_intent: hasAppointmentIntent,\r\n                generated_response: finalOutputText,\r\n                output: finalOutputText, // For n8n compatibility\r\n                media_type: finalResponseType,\r\n                media_url: finalMediaUrl,\r\n                quote_generated: false,\r\n                product_ids: productIds,\r\n                // New fields for N8N as requested\r\n                appointment_data: {\r\n                    slots: (appointmentSettings?.is_enabled \u0026\u0026 hasAppointmentIntent) ? slotsData : [], // Return slots if we fetched them\r\n                    booking_link: (profile.slug \u0026\u0026 profile.slug !== \u0027agendar\u0027) ? `https://elinaia.com.mx/${profile.slug}` : null\r\n                }\r\n            }\r\n        }), {\r\n            headers: { ...corsHeaders, \u0027Content-Type\u0027: \u0027application/json\u0027 },\r\n            status: 200,\r\n        })\r\n\r\n    } catch (error: any) {\r\n        console.error(\u0027!!! [ERROR FATAL] ExcepciÃ³n en process-chat-message:\u0027, error)\r\n        return new Response(JSON.stringify({ error: error.message }), {\r\n            headers: { ...corsHeaders, \u0027Content-Type\u0027: \u0027application/json\u0027 },\r\n            status: 500,\r\n        })\r\n    }\r\n})\r\n",
                         "PSPath":  "H:\\DESAL\\ELina 26\\supabase\\functions\\process-chat-message\\index.ts",
                         "PSParentPath":  "H:\\DESAL\\ELina 26\\supabase\\functions\\process-chat-message",
                         "PSChildName":  "index.ts",
                         "PSDrive":  "H",
                         "PSProvider":  "Microsoft.PowerShell.Core\\FileSystem",
                         "ReadCount":  1
                     },
    "pcm/context.ts":  {
                           "value":  "import { SupabaseClient } from \u0027https://esm.sh/@supabase/supabase-js@2\u0027\r\nimport { cache, CacheKeys } from \u0027./redis-cache.ts\u0027\r\n\r\nexport interface Profile {\r\n    id: string\r\n    evolution_instance_name: string\r\n    evolution_api_key: string\r\n    evolution_api_url?: string\r\n    contact_phone?: string\r\n    prompt_content?: string\r\n    product_search_strict_mode?: boolean\r\n    product_search_min_score?: number\r\n    // Add other necessary fields for system prompt\r\n    website?: string\r\n    company_description?: string\r\n    business_address?: string\r\n    business_phone?: string\r\n    work_start_hour?: string\r\n    work_end_hour?: string\r\n    pickup_location?: string\r\n    has_shipping_system?: boolean\r\n    social_media?: any\r\n    slug?: string\r\n}\r\n\r\nexport interface Contact {\r\n    id: number\r\n    full_name: string\r\n    phone_number: string\r\n    user_id: string\r\n    labels?: string[]\r\n}\r\n\r\nexport interface Subscription {\r\n    user_id: string\r\n    status: string\r\n    plan_id?: string\r\n    trial_ends_at?: string\r\n    current_period_end?: string\r\n}\r\n\r\nexport interface SmartPromotion {\r\n    id: string\r\n    user_id: string\r\n    title: string\r\n    description?: string\r\n    benefits?: string\r\n    call_to_action?: string\r\n    discount?: string\r\n    offer?: string\r\n    is_active: boolean\r\n    no_schedule: boolean\r\n    start_at?: string\r\n    end_at?: string\r\n}\r\n\r\nexport interface AppointmentSettings {\r\n    user_id: string\r\n    is_enabled: boolean\r\n    calendar_type?: string\r\n    timezone?: string\r\n    default_duration_minutes?: number\r\n    advance_booking_days?: number\r\n    buffer_time_minutes?: number\r\n}\r\n\r\nexport interface AppointmentSlot {\r\n    start: string\r\n    end: string\r\n    available: boolean\r\n}\r\n\r\nexport async function getProfileByInstance(\r\n    supabase: SupabaseClient,\r\n    instanceName: string\r\n): Promise\u003cProfile | null\u003e {\r\n    // Try cache first\r\n    const cacheKey = CacheKeys.profile(instanceName)\r\n\r\n    return await cache.getOrSet\u003cProfile | null\u003e(\r\n        cacheKey,\r\n        async () =\u003e {\r\n            // 1. Get profile from DB\r\n            const { data: profile, error } = await supabase\r\n                .from(\u0027profiles\u0027)\r\n                .select(\u0027*\u0027)\r\n                .eq(\u0027evolution_instance_name\u0027, instanceName)\r\n                .single()\r\n\r\n            if (error || !profile) {\r\n                console.error(\u0027Error fetching profile:\u0027, error)\r\n                return null\r\n            }\r\n\r\n            // 2. Get prompt_content from \u0027prompts\u0027 table\r\n            const { data: promptData } = await supabase\r\n                .from(\u0027prompts\u0027)\r\n                .select(\u0027prompt_content\u0027)\r\n                .eq(\u0027user_id\u0027, profile.id)\r\n                .maybeSingle()\r\n\r\n            if (promptData) {\r\n                profile.prompt_content = promptData.prompt_content\r\n            }\r\n\r\n            return profile as Profile\r\n        },\r\n        { ttl: 600 } // Cache for 10 minutes\r\n    )\r\n}\r\n\r\n\r\nexport interface PresetResponse {\r\n    id: string\r\n    user_id: string\r\n    trigger_text: string\r\n    response_text: string\r\n    match_type: \u0027exact\u0027 | \u0027contains\u0027 | \u0027regex\u0027\r\n    is_active: boolean\r\n    media_url?: string\r\n    media_type?: \u0027image\u0027 | \u0027video\u0027 | \u0027document\u0027\r\n}\r\n\r\nfunction matchesPattern(messageText: string, triggerText: string, matchType: string): boolean {\r\n    const lowerMessage = messageText.toLowerCase().trim()\r\n    const lowerTrigger = triggerText.toLowerCase().trim()\r\n\r\n    switch (matchType) {\r\n        case \u0027exact\u0027:\r\n            return lowerMessage === lowerTrigger\r\n        case \u0027contains\u0027:\r\n            return lowerMessage.includes(lowerTrigger)\r\n        case \u0027regex\u0027:\r\n            try {\r\n                const regex = new RegExp(triggerText, \u0027i\u0027)\r\n                return regex.test(messageText)\r\n            } catch (e) {\r\n                console.error(\u0027Invalid regex pattern:\u0027, triggerText, e)\r\n                return false\r\n            }\r\n        default:\r\n            return false\r\n    }\r\n}\r\n\r\nexport async function checkPresetResponse(\r\n    supabase: SupabaseClient,\r\n    userId: string,\r\n    messageText: string\r\n): Promise\u003cPresetResponse | null\u003e {\r\n    const { data: presets, error } = await supabase\r\n        .from(\u0027auto_responses\u0027)\r\n        .select(\u0027*\u0027)\r\n        .eq(\u0027user_id\u0027, userId)\r\n        .eq(\u0027is_active\u0027, true)\r\n        .order(\u0027created_at\u0027, { ascending: false })\r\n\r\n    if (error || !presets || presets.length === 0) {\r\n        return null\r\n    }\r\n\r\n    // Check each preset in order (most recent first)\r\n    for (const preset of presets) {\r\n        if (matchesPattern(messageText, preset.trigger_text, preset.match_type)) {\r\n            console.log(`+++ [PRESET] Match encontrado: \"${preset.trigger_text}\" (${preset.match_type})`)\r\n            return preset as PresetResponse\r\n        }\r\n    }\r\n\r\n    return null\r\n}\r\n\r\nexport async function ensureContact(\r\n    supabase: SupabaseClient,\r\n    userId: string,\r\n    remoteJid: string,\r\n    pushName: string\r\n): Promise\u003cContact | null\u003e {\r\n    const phoneNumber = remoteJid.replace(\u0027@s.whatsapp.net\u0027, \u0027\u0027)\r\n\r\n    // 1. Try to find existing\r\n    const { data: existing } = await supabase\r\n        .from(\u0027contacts\u0027)\r\n        .select(\u0027*\u0027)\r\n        .eq(\u0027user_id\u0027, userId)\r\n        .eq(\u0027phone_number\u0027, phoneNumber)\r\n        .maybeSingle()\r\n\r\n    if (existing) return existing\r\n\r\n    // 2. Create if not exists\r\n    const { data: created, error } = await supabase\r\n        .from(\u0027contacts\u0027)\r\n        .insert({\r\n            user_id: userId,\r\n            phone_number: phoneNumber,\r\n            full_name: pushName || \u0027Usuario WhatsApp\u0027,\r\n            created_at: new Date().toISOString()\r\n        })\r\n        .select()\r\n        .single()\r\n\r\n    if (error) {\r\n        console.error(\u0027Error creating contact:\u0027, error)\r\n        return null\r\n    }\r\n    return created\r\n}\r\n\r\nexport async function getChatHistory(\r\n    supabase: SupabaseClient,\r\n    userId: string,\r\n    contactId: number,\r\n    limit = 10\r\n) {\r\n    const { data, error } = await supabase\r\n        .from(\u0027chat_history\u0027)\r\n        .select(\u0027*\u0027)\r\n        .eq(\u0027user_id\u0027, userId)\r\n        .eq(\u0027contact_id\u0027, contactId)\r\n        .order(\u0027created_at\u0027, { ascending: false })\r\n        .limit(limit)\r\n\r\n    if (error) {\r\n        console.error(\u0027Error fetching history:\u0027, error)\r\n        return []\r\n    }\r\n    // Return reversed so it\u0027s chronological for the LLM\r\n    return (data || []).reverse()\r\n}\r\n\r\nexport async function getSubscription(\r\n    supabase: SupabaseClient,\r\n    userId: string\r\n): Promise\u003cSubscription | null\u003e {\r\n    const { data, error } = await supabase\r\n        .from(\u0027subscriptions\u0027)\r\n        .select(\u0027*\u0027)\r\n        .eq(\u0027user_id\u0027, userId)\r\n        .single()\r\n\r\n    if (error) {\r\n        console.error(\u0027Error fetching subscription:\u0027, error)\r\n        return null\r\n    }\r\n    return data\r\n}\r\n\r\nexport function hasIgnoreTag(contact: Contact): boolean {\r\n    if (!contact.labels || !Array.isArray(contact.labels)) return false\r\n\r\n    return contact.labels.some(label =\u003e\r\n        label \u0026\u0026 label.toString().toLowerCase().trim() === \u0027ignorar\u0027\r\n    )\r\n}\r\n\r\nexport async function getActivePromotion(\r\n    supabase: SupabaseClient,\r\n    userId: string\r\n): Promise\u003cSmartPromotion | null\u003e {\r\n    const cacheKey = CacheKeys.activePromo(userId)\r\n\r\n    return await cache.getOrSet\u003cSmartPromotion | null\u003e(\r\n        cacheKey,\r\n        async () =\u003e {\r\n            const { data: promos, error } = await supabase\r\n                .from(\u0027smart_promotions\u0027)\r\n                .select(\u0027*\u0027)\r\n                .eq(\u0027user_id\u0027, userId)\r\n\r\n            if (error || !promos || promos.length === 0) {\r\n                return null\r\n            }\r\n\r\n            const now = new Date()\r\n\r\n            const activePromo = promos.find((promo: SmartPromotion) =\u003e {\r\n                if (!promo.is_active) return false\r\n\r\n                if (!promo.no_schedule) {\r\n                    if (promo.start_at \u0026\u0026 new Date(promo.start_at) \u003e now) return false\r\n                    if (promo.end_at \u0026\u0026 new Date(promo.end_at) \u003c now) return false\r\n                }\r\n\r\n                return true\r\n            })\r\n\r\n            return activePromo || null\r\n        },\r\n        { ttl: 300 } // Cache for 5 minutes\r\n    )\r\n}\r\n\r\nexport function formatPromotionText(promo: SmartPromotion): string {\r\n    let text = `**${promo.title}**\\n`\r\n\r\n    if (promo.description) text += `${promo.description}\\n`\r\n    if (promo.discount) text += `ðŸ’° Descuento: ${promo.discount}\\n`\r\n    if (promo.offer) text += `ðŸŽ Oferta: ${promo.offer}\\n`\r\n    if (promo.benefits) text += `âœ¨ Beneficios: ${promo.benefits}\\n`\r\n    if (promo.call_to_action) text += `ðŸ‘‰ ${promo.call_to_action}`\r\n\r\n    return text.trim()\r\n}\r\n\r\nexport async function getAppointmentSettings(\r\n    supabase: SupabaseClient,\r\n    userId: string\r\n): Promise\u003cAppointmentSettings | null\u003e {\r\n    const cacheKey = CacheKeys.appointmentSettings(userId)\r\n\r\n    return await cache.getOrSet\u003cAppointmentSettings | null\u003e(\r\n        cacheKey,\r\n        async () =\u003e {\r\n            const { data, error } = await supabase\r\n                .from(\u0027appointment_settings\u0027)\r\n                .select(\u0027*\u0027)\r\n                .eq(\u0027user_id\u0027, userId)\r\n                .single()\r\n\r\n            if (error) {\r\n                console.error(\u0027Error fetching appointment settings:\u0027, error)\r\n                return null\r\n            }\r\n            return data\r\n        },\r\n        { ttl: 300 } // Cache for 5 minutes\r\n    )\r\n}\r\n\r\nexport async function getAvailableServices(\r\n    supabase: SupabaseClient,\r\n    userId: string\r\n): Promise\u003c{ id: number, name: string, description: string }[]\u003e {\r\n    const { data, error } = await supabase\r\n        .from(\u0027products\u0027)\r\n        .select(\u0027id, product_name, description\u0027)\r\n        .eq(\u0027user_id\u0027, userId)\r\n        .eq(\u0027product_type\u0027, \u0027service\u0027)\r\n        .limit(20)\r\n\r\n    if (error) {\r\n        console.error(\u0027Error fetching services:\u0027, error)\r\n        return []\r\n    }\r\n\r\n    return (data || []).map((s: any) =\u003e ({\r\n        id: s.id,\r\n        name: s.product_name,\r\n        description: s.description || \u0027\u0027\r\n    }))\r\n}\r\n\r\n// Helper to get next N days\r\nfunction getNextNDays(startDate: Date, days: number): string[] {\r\n    const dates = []\r\n    for (let i = 0; i \u003c days; i++) {\r\n        const d = new Date(startDate)\r\n        d.setDate(d.getDate() + i)\r\n        dates.push(d.toISOString().split(\u0027T\u0027)[0])\r\n    }\r\n    return dates\r\n}\r\n\r\n// Helper to summarize slots into ranges (e.g., \"MaÃ±ana y Tarde\")\r\nfunction summarizeSlots(slots: AppointmentSlot[]): string {\r\n    if (slots.length === 0) return \"\"\r\n\r\n    const formats = slots.map((s, index) =\u003e {\r\n        const hour = parseInt(s.start.split(\u0027:\u0027)[0], 10)\r\n        const ampm = hour \u003e= 12 ? \u0027PM\u0027 : \u0027AM\u0027\r\n        const h12 = hour % 12 || 12\r\n        const min = s.start.split(\u0027:\u0027)[1]\r\n        return `${index + 1}. ${h12}:${min} ${ampm}`\r\n    })\r\n\r\n    return formats.join(\u0027\\n\u0027)\r\n}\r\n\r\n// Helper for fetch with timeout\r\nasync function fetchWithTimeout(resource: string, options: RequestInit = {}, timeout = 5000) {\r\n    const controller = new AbortController();\r\n    const id = setTimeout(() =\u003e controller.abort(), timeout);\r\n    const response = await fetch(resource, {\r\n        ...options,\r\n        signal: controller.signal\r\n    });\r\n    clearTimeout(id);\r\n    return response;\r\n}\r\n\r\nexport async function getAvailableSlots(\r\n    userId: string,\r\n    date?: string\r\n): Promise\u003c{ date: string, slots: AppointmentSlot[], summary: string }[]\u003e {\r\n    const SUPABASE_URL = Deno.env.get(\u0027SUPABASE_URL\u0027)\r\n    const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get(\u0027SUPABASE_SERVICE_ROLE_KEY\u0027)\r\n\r\n    if (!SUPABASE_URL || !SUPABASE_SERVICE_ROLE_KEY) return []\r\n\r\n    // Fetch for today and next 2 days\r\n    const start = date ? new Date(date) : new Date()\r\n    const targetDates = getNextNDays(start, 3)\r\n\r\n    // Parallel Fetch with Timeout\r\n    const promises = targetDates.map(async (d) =\u003e {\r\n        try {\r\n            const response = await fetchWithTimeout(`${SUPABASE_URL}/functions/v1/get-available-slots`, {\r\n                method: \u0027POST\u0027,\r\n                headers: {\r\n                    \u0027Authorization\u0027: `Bearer ${SUPABASE_SERVICE_ROLE_KEY}`,\r\n                    \u0027Content-Type\u0027: \u0027application/json\u0027\r\n                },\r\n                body: JSON.stringify({\r\n                    user_id: userId,\r\n                    date: d,\r\n                    duration_minutes: null\r\n                })\r\n            }, 5000) // 5s timeout per request\r\n\r\n            if (response.ok) {\r\n                const data = await response.json()\r\n                const slots = data.available_slots || []\r\n                if (slots.length \u003e 0) {\r\n                    return {\r\n                        date: d,\r\n                        slots: slots,\r\n                        summary: summarizeSlots(slots)\r\n                    }\r\n                }\r\n            }\r\n        } catch (e) {\r\n            console.error(`Error fetching slots for ${d}:`, e)\r\n        }\r\n        return null\r\n    })\r\n\r\n    const results = await Promise.all(promises)\r\n    return results.filter(r =\u003e r !== null) as { date: string, slots: AppointmentSlot[], summary: string }[]\r\n}\r\n\r\nexport function formatAppointmentContext(availability: { date: string, slots: AppointmentSlot[], summary: string }[]): string {\r\n    if (!availability || availability.length === 0) {\r\n        return `[CONTEXTO DE CITAS]\\nNo se encontraron horarios disponibles para los prÃ³ximos 3 dÃ­as (o hubo error consultando). Sugiere al cliente preguntar por otra fecha.`\r\n    }\r\n\r\n    let text = `[CONTEXTO DE CITAS]\\nHorarios disponibles reales (Formato 24h):\\n`\r\n\r\n    for (const day of availability) {\r\n        // Take up to 10 slots to avoid overflowing context\r\n        const slotsList = Array.isArray(day.slots)\r\n            ? day.slots.slice(0, 10).map(s =\u003e s.start.substring(0, 5)).join(\u0027, \u0027)\r\n            : \u0027No hay slots\u0027\r\n\r\n        text += `- **${day.date}**: ${slotsList}\\n`\r\n    }\r\n\r\n    text += `\\nINSTRUCCIÃ“N: Ofrece 2 o 3 de estos horarios exactos. NO inventes horas que no estÃ©n en esta lista.`\r\n    return text\r\n}\r\n\r\nexport function detectAppointmentIntent(text: string): boolean {\r\n    const lowerText = text.toLowerCase()\r\n\r\n    // 1. Strong booking keywords (Action oriented)\r\n    const strongKeywords = [\r\n        \u0027cita\u0027, \u0027agendar\u0027, \u0027reservar\u0027, \u0027reserva\u0027, \u0027turno\u0027,\r\n        \u0027calendario\u0027, \u0027agenda\u0027, \u0027programar\u0027, \u0027separar lugar\u0027, \u0027apartar\u0027,\r\n        \u0027quiero un espacio\u0027, \u0027tiene espacio\u0027, \u0027tienes espacio\u0027, \u0027hay espacio\u0027\r\n    ]\r\n\r\n    // 2. Contextual keywords (Needs to be paired or very specific)\r\n    // We removed \u0027hoy\u0027, \u0027maÃ±ana\u0027, days of week to avoid false positives (e.g. \"Hablamos maÃ±ana\")\r\n    const weakKeywords = [\r\n        \u0027horario\u0027, \u0027disponible\u0027, \u0027disponibilidad\u0027, \u0027hueco\u0027\r\n    ]\r\n\r\n    // Check strong keywords\r\n    if (strongKeywords.some(k =\u003e lowerText.includes(k))) return true\r\n\r\n    // Check weak keywords ONLY if they are not part of common phrases? \r\n    // For now, if they mention \u0027horario\u0027 or \u0027disponible\u0027, it\u0027s likely about booking context.\r\n    if (weakKeywords.some(k =\u003e lowerText.includes(k))) return true\r\n\r\n    // 3. Regex for specific time requests \"a las X\" imply scheduling\r\n    const timeRegex = /a\\s+las?\\s+\\d+/i\r\n    if (timeRegex.test(lowerText)) return true\r\n\r\n    return false\r\n}\r\n\r\nexport interface CriticalIntentResponse {\r\n    is_critical: boolean\r\n    detection_type?: string\r\n    confidence?: number\r\n    detected_content?: string\r\n    reason?: string\r\n}\r\n\r\nexport async function detectCriticalIntent(\r\n    contactId: number,\r\n    userId: string,\r\n    messageContent: string\r\n): Promise\u003cCriticalIntentResponse | null\u003e {\r\n    const SUPABASE_URL = Deno.env.get(\u0027SUPABASE_URL\u0027)\r\n    const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get(\u0027SUPABASE_SERVICE_ROLE_KEY\u0027)\r\n\r\n    if (!SUPABASE_URL || !SUPABASE_SERVICE_ROLE_KEY) {\r\n        console.error(\u0027Missing Supabase environment variables\u0027)\r\n        return null\r\n    }\r\n\r\n    try {\r\n        // Use timeout for critical intent\r\n        const response = await fetchWithTimeout(`${SUPABASE_URL}/functions/v1/detect-critical-intent`, {\r\n            method: \u0027POST\u0027,\r\n            headers: {\r\n                \u0027Authorization\u0027: `Bearer ${SUPABASE_SERVICE_ROLE_KEY}`,\r\n                \u0027Content-Type\u0027: \u0027application/json\u0027\r\n            },\r\n            body: JSON.stringify({\r\n                contact_id: contactId,\r\n                user_id: userId,\r\n                message_content: messageContent,\r\n                message_id: null\r\n            })\r\n        }, 5000) // 5s timeout\r\n\r\n        if (!response.ok) {\r\n            console.error(\u0027Error calling detect-critical-intent:\u0027, await response.text())\r\n            return null\r\n        }\r\n\r\n        const data = await response.json()\r\n        return data\r\n    } catch (err) {\r\n        console.error(\u0027Exception in detectCriticalIntent:\u0027, err)\r\n        return null\r\n    }\r\n}\r\n\r\n// Helper to get Redis URL with proper protocol\r\nfunction getRedisBaseUrl(): string | null {\r\n    let url = Deno.env.get(\u0027REDIS_URL\u0027);\r\n    if (!url) return null;\r\n    if (!url.startsWith(\u0027http\u0027)) {\r\n        url = `https://${url}`;\r\n    }\r\n    return url;\r\n}\r\n\r\nexport async function recordMetric(\r\n    supabase: SupabaseClient,\r\n    userId: string,\r\n    contactId: number,\r\n    eventType: string,\r\n    metadata?: any\r\n) {\r\n    // Fire and forget - don\u0027t await to block\r\n    supabase.from(\u0027metrics\u0027).insert({\r\n        user_id: userId,\r\n        contact_id: contactId,\r\n        event_type: eventType,\r\n        metadata: metadata || {},\r\n        created_at: new Date().toISOString()\r\n    }).then(() =\u003e { }).catch((err: any) =\u003e console.error(\u0027Metric error:\u0027, err))\r\n}\r\n\r\nexport async function getMessageBuffer(chatId: string): Promise\u003cstring[]\u003e {\r\n    const REDIS_URL = getRedisBaseUrl();\r\n    if (!REDIS_URL) return []\r\n\r\n    try {\r\n        const response = await fetchWithTimeout(`${REDIS_URL}/get/${chatId}_buffer`, {}, 2000) // 2s timeout\r\n        const data = await response.json()\r\n        return data.value ? JSON.parse(data.value) : []\r\n    } catch {\r\n        return []\r\n    }\r\n}\r\n\r\nexport async function pushMessageBuffer(chatId: string, messageId: string) {\r\n    const REDIS_URL = getRedisBaseUrl();\r\n    if (!REDIS_URL) return\r\n\r\n    // Don\u0027t wait for GET\r\n    try {\r\n        const buffer = await getMessageBuffer(chatId)\r\n        buffer.push(messageId)\r\n        const trimmed = buffer.slice(-10)\r\n\r\n        await fetchWithTimeout(`${REDIS_URL}/set/${chatId}_buffer`, {\r\n            method: \u0027POST\u0027,\r\n            headers: { \u0027Content-Type\u0027: \u0027application/json\u0027 },\r\n            body: JSON.stringify({ value: JSON.stringify(trimmed), ttl: 86400 }) // 24h\r\n        }, 5000) // Increased to 5s\r\n    } catch (err: any) {\r\n        console.error(\"Redis Push Error:\", err)\r\n    }\r\n}\r\n\r\nexport async function uploadToBunnyCDN(\r\n    fileData: string,\r\n    fileName: string,\r\n    mimeType: string\r\n): Promise\u003cstring | null\u003e {\r\n    const SUPABASE_URL = Deno.env.get(\u0027SUPABASE_URL\u0027)\r\n    const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get(\u0027SUPABASE_SERVICE_ROLE_KEY\u0027)\r\n\r\n    if (!SUPABASE_URL || !SUPABASE_SERVICE_ROLE_KEY) return null\r\n\r\n    try {\r\n        const response = await fetch(`${SUPABASE_URL}/functions/v1/smart-worker`, {\r\n            method: \u0027POST\u0027,\r\n            headers: {\r\n                \u0027Authorization\u0027: `Bearer ${SUPABASE_SERVICE_ROLE_KEY}`,\r\n                \u0027Content-Type\u0027: \u0027application/json\u0027\r\n            },\r\n            body: JSON.stringify({\r\n                action: \u0027upload\u0027,\r\n                file_data: fileData,\r\n                file_name: fileName,\r\n                mime_type: mimeType\r\n            })\r\n        })\r\n\r\n        const data = await response.json()\r\n        return data.cdn_url || null\r\n    } catch (err) {\r\n        console.error(\u0027Error uploading to Bunny CDN:\u0027, err)\r\n        return null\r\n    }\r\n}\r\n",
                           "PSPath":  "H:\\DESAL\\ELina 26\\supabase\\functions\\process-chat-message\\context.ts",
                           "PSParentPath":  "H:\\DESAL\\ELina 26\\supabase\\functions\\process-chat-message",
                           "PSChildName":  "context.ts",
                           "PSDrive":  "H",
                           "PSProvider":  "Microsoft.PowerShell.Core\\FileSystem",
                           "ReadCount":  1
                       },
    "shared/cors.ts":  {
                           "value":  "\r\nexport const corsHeaders = {\r\n    \u0027Access-Control-Allow-Origin\u0027: \u0027*\u0027,\r\n    \u0027Access-Control-Allow-Headers\u0027: \u0027authorization, x-client-info, apikey, content-type\u0027,\r\n}\r\n",
                           "PSPath":  "H:\\DESAL\\ELina 26\\supabase\\functions\\_shared\\cors.ts",
                           "PSParentPath":  "H:\\DESAL\\ELina 26\\supabase\\functions\\_shared",
                           "PSChildName":  "cors.ts",
                           "PSDrive":  "H",
                           "PSProvider":  "Microsoft.PowerShell.Core\\FileSystem",
                           "ReadCount":  1
                       },
    "pcm/supabase-client.ts":  {
                                   "value":  "\r\nimport { createClient } from \u0027https://esm.sh/@supabase/supabase-js@2\u0027\r\n\r\nexport function createSupabaseClient(req: Request) {\r\n    return createClient(\r\n        Deno.env.get(\u0027SUPABASE_URL\u0027) ?? \u0027\u0027,\r\n        Deno.env.get(\u0027SUPABASE_SERVICE_ROLE_KEY\u0027) ?? \u0027\u0027,\r\n        {\r\n            global: {\r\n                headers: { Authorization: req.headers.get(\u0027Authorization\u0027)! },\r\n            },\r\n        }\r\n    )\r\n}\r\n\r\nexport function createSupabaseAdminClient() {\r\n    return createClient(\r\n        Deno.env.get(\u0027SUPABASE_URL\u0027) ?? \u0027\u0027,\r\n        Deno.env.get(\u0027SUPABASE_SERVICE_ROLE_KEY\u0027) ?? \u0027\u0027\r\n    )\r\n}\r\n",
                                   "PSPath":  "H:\\DESAL\\ELina 26\\supabase\\functions\\process-chat-message\\supabase-client.ts",
                                   "PSParentPath":  "H:\\DESAL\\ELina 26\\supabase\\functions\\process-chat-message",
                                   "PSChildName":  "supabase-client.ts",
                                   "PSDrive":  "H",
                                   "PSProvider":  "Microsoft.PowerShell.Core\\FileSystem",
                                   "ReadCount":  1
                               },
    "shared/supabase-client.ts":  {
                                      "value":  "\r\nimport { createClient } from \u0027https://esm.sh/@supabase/supabase-js@2\u0027\r\n\r\nexport function createSupabaseClient(req: Request) {\r\n    return createClient(\r\n        Deno.env.get(\u0027SUPABASE_URL\u0027) ?? \u0027\u0027,\r\n        Deno.env.get(\u0027SUPABASE_SERVICE_ROLE_KEY\u0027) ?? \u0027\u0027,\r\n        {\r\n            global: {\r\n                headers: { Authorization: req.headers.get(\u0027Authorization\u0027)! },\r\n            },\r\n        }\r\n    )\r\n}\r\n\r\nexport function createSupabaseAdminClient() {\r\n    return createClient(\r\n        Deno.env.get(\u0027SUPABASE_URL\u0027) ?? \u0027\u0027,\r\n        Deno.env.get(\u0027SUPABASE_SERVICE_ROLE_KEY\u0027) ?? \u0027\u0027\r\n    )\r\n}\r\n",
                                      "PSPath":  "H:\\DESAL\\ELina 26\\supabase\\functions\\_shared\\supabase-client.ts",
                                      "PSParentPath":  "H:\\DESAL\\ELina 26\\supabase\\functions\\_shared",
                                      "PSChildName":  "supabase-client.ts",
                                      "PSDrive":  "H",
                                      "PSProvider":  "Microsoft.PowerShell.Core\\FileSystem",
                                      "ReadCount":  1
                                  }
}
