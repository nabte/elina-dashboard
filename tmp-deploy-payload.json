[{"name":"agents/conversational.ts","content":"/**\r\n * ELINA V5 - Conversational Agent\r\n * \r\n * Agente conversacional principal usando OpenRouter con GPT-5-nano\r\n */\r\n\r\nimport type { SupabaseClient } from 'https://esm.sh/@supabase/supabase-js@2'\r\nimport type { AccountConfig, IntentDetectionResult, ConversationContext, AgentResponse, Message, ToolResult, ToolCall } from '../config/types.ts'\r\nimport { DEFAULT_MODEL, DEFAULT_TEMPERATURE, DEFAULT_MAX_TOKENS, OPENROUTER_API_URL } from '../config/constants.ts'\r\n\r\n/**\r\n * Ejecuta el agente conversacional\r\n */\r\nexport async function runConversationalAgent(\r\n    supabase: SupabaseClient,\r\n    config: AccountConfig,\r\n    userMessage: string,\r\n    intent: IntentDetectionResult,\r\n    context: ConversationContext,\r\n    toolCalls?: ToolCall[],     // ‚Üê Tool calls originales del assistant\r\n    toolResults?: ToolResult[]  // ‚Üê Resultados de herramientas ejecutadas\r\n): Promise<AgentResponse> {\r\n    console.log(`ü§ñ [AGENT] Running conversational agent`)\r\n    console.log(`   - Intent: ${intent.primary}`)\r\n    console.log(`   - Sentiment: ${intent.sentiment.polarity} (${intent.sentiment.score})`)\r\n\r\n    const startTime = performance.now()\r\n\r\n    // 1. Construir system prompt\r\n    const systemPrompt = await buildSystemPrompt(config, intent, context)\r\n\r\n    // 2. Preparar mensajes\r\n    const messages: any[] = [\r\n        { role: 'system', content: systemPrompt },\r\n        ...context.recentMessages.slice(-8), // √öltimos 8 mensajes para contexto\r\n        { role: 'user', content: userMessage }\r\n    ]\r\n\r\n    // Si hay tool calls y results, construir el flujo completo\r\n    if (toolCalls && toolCalls.length > 0 && toolResults && toolResults.length > 0) {\r\n        // Agregar el mensaje del assistant con tool_calls\r\n        messages.push({\r\n            role: 'assistant',\r\n            content: null,\r\n            tool_calls: toolCalls\r\n        })\r\n        // Agregar los resultados de las herramientas\r\n        messages.push(...toolResults)\r\n    }\r\n\r\n    // 3. Llamar a OpenRouter\r\n    const openrouterKey = Deno.env.get('OPENROUTER_API_KEY')\r\n    if (!openrouterKey) {\r\n        throw new Error('OPENROUTER_API_KEY not found in environment')\r\n    }\r\n\r\n    try {\r\n        const response = await fetch(OPENROUTER_API_URL, {\r\n            method: 'POST',\r\n            headers: {\r\n                'Authorization': `Bearer ${openrouterKey}`,\r\n                'HTTP-Referer': 'https://elina.ai',\r\n                'X-Title': 'ELINA V5',\r\n                'Content-Type': 'application/json'\r\n            },\r\n            body: JSON.stringify({\r\n                model: config.model || DEFAULT_MODEL,\r\n                messages,  // Ya incluye tool results si existen\r\n                temperature: config.temperature || DEFAULT_TEMPERATURE,\r\n                max_tokens: config.maxTokens || DEFAULT_MAX_TOKENS,\r\n                // Tools solo en la primera llamada (cuando no hay toolResults)\r\n                ...(toolResults && toolResults.length > 0 ? {} : {\r\n                    tools: getAvailableTools(config, intent),\r\n                    tool_choice: 'auto'\r\n                })\r\n            })\r\n        })\r\n\r\n        if (!response.ok) {\r\n            const errorText = await response.text()\r\n            throw new Error(`OpenRouter API error: ${response.status} ${response.statusText} - ${errorText}`)\r\n        }\r\n\r\n        const data = await response.json()\r\n        const duration = performance.now() - startTime\r\n\r\n        console.log(`‚úÖ [AGENT] Response generated in ${duration.toFixed(0)}ms`)\r\n        console.log(`   - Model: ${data.model || config.model}`)\r\n        console.log(`   - Tokens: ${data.usage?.total_tokens || 'unknown'}`)\r\n\r\n        // 4. Procesar respuesta\r\n        const choice = data.choices[0]\r\n\r\n        return {\r\n            text: choice.message.content || '',\r\n            toolCalls: choice.message.tool_calls || [],\r\n            metadata: {\r\n                model: data.model || config.model,\r\n                tokensUsed: data.usage?.total_tokens || 0,\r\n                finishReason: choice.finish_reason || 'stop',\r\n                duration\r\n            }\r\n        }\r\n    } catch (error) {\r\n        console.error(`‚ùå [AGENT] Error calling OpenRouter: ${error.message}`)\r\n        throw error\r\n    }\r\n}\r\n\r\n/**\r\n * Construye el system prompt din√°micamente\r\n */\r\nasync function buildSystemPrompt(\r\n    config: AccountConfig,\r\n    intent: IntentDetectionResult,\r\n    context: ConversationContext\r\n): Promise<string> {\r\n    let prompt = `Eres el asistente virtual de ${config.companyName}, un chatbot de ventas y atenci√≥n al cliente ${config.tone} y profesional.\r\n\r\n## Informaci√≥n de la Empresa\r\n${config.website ? `Sitio web: ${config.website}` : ''}\r\n${config.businessPhone ? `\\nTel√©fono: ${config.businessPhone}` : ''}\r\n${config.businessAddress ? `\\nDirecci√≥n: ${config.businessAddress}` : ''}\r\n`\r\n\r\n    // CR√çTICO: Solo incluir descripci√≥n de empresa si NO es consulta de productos\r\n    // Esto evita que el LLM invente productos bas√°ndose en la descripci√≥n\r\n    if (intent.primary !== 'product_inquiry') {\r\n        prompt += `\\n${config.companyDescription || 'Empresa dedicada a ofrecer productos y servicios de calidad.'}\r\n`\r\n    }\r\n\r\n    prompt += `\r\n## Tu Misi√≥n\r\n- Responder de forma natural y conversacional, como un humano por WhatsApp\r\n- Ser BREVE: m√°ximo 2-3 l√≠neas por mensaje (como un mensaje de texto real)\r\n- Ir directo al grano, sin rodeos ni explicaciones largas\r\n- Detectar las necesidades del cliente y ofrecer soluciones\r\n- Mantener un tono ${config.tone} pero casual\r\n- Usar emojis ocasionalmente (1-2 por mensaje m√°ximo) üòä\r\n- Si hay mucha info, dividir en mensajes cortos en lugar de un mensaje largo\r\n- Responder como si estuvieras chateando, no escribiendo un email\r\n\r\n## Capacidades Disponibles\r\n\r\n**IMPORTANTE: FECHA ACTUAL**\r\nHoy es: ${new Date().toLocaleString('es-MX', { timeZone: config.timezone || 'America/Mexico_City', weekday: 'long', year: 'numeric', month: 'long', day: 'numeric', hour: '2-digit', minute: '2-digit' })}.\r\nUsa esta fecha como referencia absoluta para \"ma√±ana\", \"lunes\", etc.\r\n`\r\n\r\n    // REGLAS CR√çTICAS SOBRE PRODUCTOS\r\n    prompt += `\\nüö® **REGLAS CR√çTICAS SOBRE PRODUCTOS** üö®\\n`\r\n    prompt += `1. NUNCA respondas sobre productos sin usar la herramienta buscar_productos primero.\\n`\r\n    prompt += `2. NUNCA inventes productos, servicios o caracter√≠sticas bas√°ndote en la descripci√≥n de la empresa.\\n`\r\n    prompt += `3. Si el usuario pregunta \"qu√© vendes?\", \"qu√© productos tienes?\", \"qu√© manejas?\", etc., DEBES usar buscar_productos con query vac√≠a (\"\") para obtener el cat√°logo real.\\n`\r\n    prompt += `4. Si buscar_productos devuelve 0 resultados, significa que NO lo tenemos. Di: \"No manejo esa marca/modelo actualmente.\"\\n`\r\n    prompt += `5. NUNCA digas \"tengo otros modelos\" o \"puedo buscar otros\" si la b√∫squeda fall√≥.\\n`\r\n    prompt += `6. Solo menciona productos que REALMENTE encontraste con la herramienta.\\n`\r\n    prompt += `7. PROHIBIDO asumir que vendes algo solo porque est√° en la descripci√≥n de la empresa.\\n`\r\n\r\n    if (config.appointmentsEnabled) {\r\n        prompt += `‚úÖ **Citas**: Puedes consultar disponibilidad y agendar citas.\\n`\r\n    }\r\n\r\n    if (config.quotesEnabled) {\r\n        prompt += `‚úÖ **Cotizaciones**: Puedes generar cotizaciones en PDF cuando el cliente lo solicite.\\n`\r\n    }\r\n\r\n    if (config.hasShipping) {\r\n        prompt += `‚úÖ **Env√≠os**: Ofrecemos servicio de env√≠o a domicilio.\\n`\r\n    }\r\n\r\n    // Agregar contexto RAG si existe\r\n    if (context.ragContext) {\r\n        prompt += `\\n## Informaci√≥n Relevante de la Base de Conocimientos\\n${context.ragContext}\\n`\r\n    }\r\n\r\n    // Agregar aprendizajes de largo plazo\r\n    if (context.accountLearnings && context.accountLearnings.length > 0) {\r\n        prompt += `\\n## Aprendizajes Previos\\n`\r\n        context.accountLearnings.forEach(learning => {\r\n            prompt += `- ${learning.content}\\n`\r\n        })\r\n    }\r\n\r\n    // Agregar preferencias del usuario\r\n    if (context.userPreferences && context.userPreferences.length > 0) {\r\n        prompt += `\\n## Preferencias del Cliente\\n`\r\n        context.userPreferences.forEach(pref => {\r\n            prompt += `- ${pref.key}: ${pref.value}\\n`\r\n        })\r\n    }\r\n\r\n    // Agregar promociones activas\r\n    if (context.activePromotions && context.activePromotions.length > 0) {\r\n        prompt += `\\n## Promociones Activas\\n`\r\n        context.activePromotions.forEach(promo => {\r\n            prompt += `- **${promo.title}**: ${promo.description || ''}\\n`\r\n            if (promo.discount) prompt += `  Descuento: ${promo.discount}\\n`\r\n        })\r\n    }\r\n\r\n    // üî• PRODUCTOS MENCIONADOS RECIENTEMENTE (con FAQs para follow-up questions)\r\n    if (context.recentlyMentionedProducts && context.recentlyMentionedProducts.length > 0) {\r\n        const { formatCachedProductsForPrompt } = await import('../utils/product-cache.ts')\r\n        prompt += formatCachedProductsForPrompt(context.recentlyMentionedProducts)\r\n        prompt += `\\n**IMPORTANTE:** Si el cliente hace preguntas sobre estos productos (ej: \"¬øc√≥mo funciona?\", \"¬øes compatible?\"), usa la informaci√≥n de FAQs arriba. NO necesitas buscar de nuevo.\\n`\r\n    }\r\n\r\n    // Instrucciones espec√≠ficas seg√∫n intenci√≥n\r\n    if (intent.primary === 'product_inquiry') {\r\n        prompt += `\\n## üéØ ACCI√ìN REQUERIDA: CONSULTA DE PRODUCTOS\r\n\r\n**PASO 1 - OBLIGATORIO:** Usa la herramienta buscar_productos AHORA.\r\n- Si el usuario pregunta \"qu√© vendes?\", \"qu√© productos?\", \"qu√© tienes?\": usa query=\"\" (vac√≠o) para ver TODO el cat√°logo\r\n- Si pregunta por algo espec√≠fico (ej: \"migra√±a\", \"665\", \"105X\"): usa ese t√©rmino como query\r\n\r\n**PASO 2:** Bas√°ndote SOLO en los resultados de la herramienta:\r\n- Si encontraste productos: menciona usando placeholders (OPCIONAL):\r\n  * Nombre: [PRODUCT_NAME:ID] o el nombre directamente\r\n  * Precio: [PRODUCT_PRICE:ID] o el precio directamente\r\n  * Stock: [PRODUCT_STOCK:ID]\r\n  * Descripci√≥n: [PRODUCT_DESC:ID]\r\n- Si NO encontraste nada (0 resultados): di \"No manejo esa marca/modelo actualmente.\"\r\n- **üñºÔ∏è MEDIA**: NO necesitas mencionar [PRODUCT_MEDIA:ID] - el sistema env√≠a im√°genes/videos autom√°ticamente si el producto las tiene\r\n\r\n**EJEMPLOS:**\r\n- \"S√≠, tengo el [PRODUCT_NAME:123] por [PRODUCT_PRICE:123]\"\r\n- O simplemente: \"S√≠, tengo el HP 665 por $350. Hay 10 en stock\"\r\n\r\n‚Üí Si el producto tiene media_url, se enviar√° autom√°ticamente como imagen con tu texto como caption\r\n\r\n**üîé USO DE FAQs DE PRODUCTOS:**\r\n- La herramienta buscar_productos devuelve FAQs (preguntas frecuentes) para cada producto\r\n- Las FAQs contienen respuestas verificadas y espec√≠ficas sobre caracter√≠sticas, compatibilidad, uso, etc.\r\n- Si el cliente pregunta algo que est√° en las FAQs del producto, usa esa informaci√≥n para responder\r\n- Las FAQs son informaci√≥n CONFIABLE y REAL del producto\r\n- Ejemplo: Cliente: \"¬øEs compatible con Windows?\" ‚Üí Si hay FAQ que lo responde, √∫sala\r\n\r\n**PROHIBIDO:**\r\n‚ùå Responder sin usar la herramienta primero\r\n‚ùå Inventar productos bas√°ndote en la descripci√≥n de la empresa\r\n‚ùå Decir \"ofrecemos servicios en...\" sin verificar productos reales\r\n‚ùå Asumir que vendes algo solo porque suena l√≥gico\r\n‚ùå Enviar URLs de im√°genes manualmente (el sistema las env√≠a autom√°ticamente)\r\n`\r\n    }\r\n\r\n    if (intent.primary === 'appointment_request') {\r\n        prompt += `\\n## Contexto Actual\r\nEl cliente quiere agendar una cita.\r\nIMPORTANTE: \r\n1. PRIMERO usa consultar_disponibilidad para ver horarios disponibles.\r\n2. Si hay slots disponibles, mu√©stralos.\r\n3. CR√çTICO: Si el usuario elige un horario (ej: \"a las 3\", \"el de las 5\"), AGENDA INMEDIATAMENTE usando agendar_cita.\r\n4. NO preguntes \"¬øte gustar√≠a agendar?\" o \"¬øconfirmamos?\". HAZLO DIRECTAMENTE. Simplemente di: \"Listo, ha quedado agendada...\".\r\n5. Solo si el horario no es claro o no hay disponibilidad, pregunta.\r\n${context.appointmentSlots && context.appointmentSlots.length > 0 ? `\r\nHorarios disponibles:\r\n${context.appointmentSlots.map(s => `- ${s.date} a las ${s.time}`).join('\\n')}\r\n` : ''}\r\n`\r\n    }\r\n\r\n    if (intent.primary === 'complaint' || intent.primary === 'urgent_issue') {\r\n        prompt += `\\n## ALERTA: Intenci√≥n Cr√≠tica Detectada\r\nEl cliente tiene una queja o problema urgente. Responde con:\r\n1. Empat√≠a y disculpas sinceras\r\n2. Reconocimiento del problema\r\n3. Ofrecimiento de soluci√≥n inmediata\r\n4. Escalamiento a un humano si es necesario\r\n\r\nEjemplo: \"Lamento mucho escuchar eso üòî Entiendo tu frustraci√≥n y quiero ayudarte a resolver esto de inmediato. ¬øPodr√≠as darme m√°s detalles para poder asistirte mejor?\"\r\n`\r\n    }\r\n\r\n    // Prompt personalizado del usuario\r\n    if (config.customPrompt) {\r\n        prompt += `\\n## Instrucciones Adicionales del Negocio\\n${config.customPrompt}\\n`\r\n    }\r\n\r\n    // Reglas generales\r\n    prompt += `\\n## Reglas Importantes\r\n1. S√â BREVE: M√°ximo 2-3 l√≠neas, como un mensaje de WhatsApp real\r\n2. NUNCA inventes informaci√≥n que no tengas\r\n3. Si no sabes algo, adm√≠telo brevemente y ofrece alternativas\r\n4. Usa placeholders [PRODUCT_NAME:ID] para productos\r\n5. Responde como humano casual, no como robot formal\r\n6. Usa emojis con moderaci√≥n (1-2 m√°ximo)\r\n7. Si detectas venta, cierra con CTA breve y claro\r\n8. EVITA p√°rrafos largos - divide en mensajes cortos si es necesario\r\n`\r\n\r\n    return prompt\r\n}\r\n\r\n/**\r\n * Obtiene las herramientas disponibles seg√∫n configuraci√≥n\r\n */\r\nfunction getAvailableTools(config: AccountConfig, intent: IntentDetectionResult): any[] {\r\n    const tools: any[] = []\r\n\r\n    // Herramienta de b√∫squeda de productos\r\n    // SIEMPRE disponible si el usuario tiene productos, sin importar el intent\r\n    // El LLM decidir√° cu√°ndo usarla\r\n    if (config.hasProducts) {\r\n        tools.push({\r\n            type: 'function',\r\n            function: {\r\n                name: 'buscar_productos',\r\n                description: 'Busca productos en el cat√°logo bas√°ndose en una consulta de texto. √ösala cuando el cliente pregunte por productos, precios, SKUs, o qu√© vendes.',\r\n                parameters: {\r\n                    type: 'object',\r\n                    properties: {\r\n                        query: {\r\n                            type: 'string',\r\n                            description: 'Consulta de b√∫squeda (ej: \"zapatos deportivos\", \"laptop gaming\", \"105X\", \"migra√±a\")'\r\n                        },\r\n                        limit: {\r\n                            type: 'number',\r\n                            description: 'N√∫mero m√°ximo de resultados (default: 5)'\r\n                        }\r\n                    },\r\n                    required: ['query']\r\n                }\r\n            }\r\n        })\r\n    }\r\n\r\n    // Herramienta de agendamiento de citas\r\n    if (config.appointmentsEnabled && intent.primary === 'appointment_request') {\r\n        tools.push({\r\n            type: 'function',\r\n            function: {\r\n                name: 'agendar_cita',\r\n                description: 'Agenda una cita para el cliente',\r\n                parameters: {\r\n                    type: 'object',\r\n                    properties: {\r\n                        date: {\r\n                            type: 'string',\r\n                            description: 'Fecha de la cita (formato: YYYY-MM-DD)'\r\n                        },\r\n                        time: {\r\n                            type: 'string',\r\n                            description: 'Hora de la cita (formato: HH:MM)'\r\n                        },\r\n                        service_id: {\r\n                            type: 'number',\r\n                            description: 'ID del servicio (opcional)'\r\n                        },\r\n                        notes: {\r\n                            type: 'string',\r\n                            description: 'Notas adicionales (opcional)'\r\n                        }\r\n                    },\r\n                    required: ['date', 'time']\r\n                }\r\n            }\r\n        })\r\n\r\n        // Tool para consultar disponibilidad\r\n        tools.push({\r\n            type: 'function',\r\n            function: {\r\n                name: 'consultar_disponibilidad',\r\n                description: 'Consulta los horarios disponibles para una fecha espec√≠fica',\r\n                parameters: {\r\n                    type: 'object',\r\n                    properties: {\r\n                        date: {\r\n                            type: 'string',\r\n                            description: 'Fecha a consultar (formato: YYYY-MM-DD)'\r\n                        }\r\n                    },\r\n                    required: ['date']\r\n                }\r\n            }\r\n        })\r\n    }\r\n\r\n    return tools\r\n}\r\n"},{"name":"config/account-config.ts","content":"/**\r\n * ELINA V5 - Account Configuration Loader\r\n * \r\n * Carga toda la configuraci√≥n de una cuenta desde m√∫ltiples tablas de Supabase\r\n */\r\n\r\nimport type { SupabaseClient } from 'https://esm.sh/@supabase/supabase-js@2'\r\nimport type { AccountConfig, CriticalRule, AutoResponse, Profile } from './types.ts'\r\nimport { DEFAULT_MODEL, DEFAULT_TEMPERATURE, DEFAULT_MAX_TOKENS } from './constants.ts'\r\n\r\n/**\r\n * Carga la configuraci√≥n completa de una cuenta\r\n */\r\n/**\r\n * Carga la configuraci√≥n completa de una cuenta\r\n */\r\nexport async function loadAccountConfig(\r\n    supabase: SupabaseClient,\r\n    userId: string\r\n): Promise<AccountConfig> {\r\n    console.log(`üìã [CONFIG] Loading account configuration for user: ${userId}`)\r\n\r\n    // 1. Cargar datos en paralelo (New Schema)\r\n    const [\r\n        profileResult,\r\n        teamResult,\r\n        rulesResult\r\n    ] = await Promise.all([\r\n        supabase.from('profiles').select('*').eq('id', userId).single(),\r\n        supabase.from('teams').select('ignored_labels').eq('owner_id', userId).maybeSingle(),\r\n        supabase.from('automation_rules').select('*').eq('user_id', userId).eq('is_active', true)\r\n    ])\r\n\r\n    if (profileResult.error || !profileResult.data) {\r\n        throw new Error(`Profile not found for user ${userId}: ${profileResult.error?.message}`)\r\n    }\r\n\r\n    const profile = profileResult.data as Profile\r\n    const team = teamResult.data\r\n    const allRules = (rulesResult.data || []) as any[] // Start as any to handle mapping\r\n\r\n    // 2. Map Automation Rules to Legacy Structures (for compatibility)\r\n    const criticalRules = allRules\r\n        .filter(r => r.type === 'critical')\r\n        .map(r => ({\r\n            id: r.id,\r\n            ruleName: r.name,\r\n            ruleType: r.trigger_type === 'pattern' ? 'pattern' : 'keyword',\r\n            patternOrKeyword: r.trigger_config?.pattern || r.trigger_config?.keyword || '',\r\n            detectionType: r.trigger_config?.detection_type || 'contains',\r\n            isActive: r.is_active,\r\n            priority: r.priority,\r\n            caseSensitive: false // Default\r\n        }))\r\n\r\n    const autoResponses = allRules\r\n        .filter(r => r.type === 'auto_response')\r\n        .map(r => ({\r\n            id: r.id,\r\n            triggerText: r.trigger_config?.keyword || '',\r\n            responseText: r.action_config?.response_text || '',\r\n            isActive: r.is_active,\r\n            matchType: r.trigger_config?.match_type || 'exact',\r\n            mediaUrl: r.action_config?.media_url,\r\n            mediaType: r.action_config?.media_type || 'text'\r\n        }))\r\n\r\n    // Extract settings from JSONB columns\r\n    const aptConfig = profile.appointment_config || {}\r\n    const quoteConfig = profile.quote_config || {}\r\n\r\n    // 3. Construir objeto de configuraci√≥n\r\n    const config: AccountConfig = {\r\n        // Identification\r\n        userId,\r\n        instanceName: profile.evolution_instance_name || '',\r\n        serverUrl: profile.evolution_api_url || 'https://evolutionapi-evolution-api.mcjhhb.easypanel.host', // Default as fallback\r\n\r\n        // AI Configuration\r\n        model: DEFAULT_MODEL,\r\n        temperature: DEFAULT_TEMPERATURE,\r\n        maxTokens: DEFAULT_MAX_TOKENS,\r\n\r\n        // Company Info\r\n        companyName: profile.full_name || 'Asistente',\r\n        companyDescription: profile.company_description || '',\r\n        website: profile.website,\r\n        businessAddress: profile.business_address,\r\n        businessPhone: profile.business_phone,\r\n        timezone: profile.timezone || 'America/Mexico_City',\r\n        slug: profile.slug,\r\n\r\n        // Personality\r\n        tone: 'profesional',\r\n        customPrompt: profile.system_prompt || undefined, // New Field\r\n\r\n        // Business Capabilities\r\n        businessType: (profile.business_type as any) || 'hybrid',\r\n        hasProducts: true, // Siempre permitir b√∫squeda de productos\r\n        hasServices: true, // Siempre permitir servicios\r\n        hasAppointments: !!(aptConfig.is_enabled),\r\n        hasQuotes: profile.quotes_enabled || false,\r\n        hasShipping: profile.has_shipping_system || false,\r\n        productCount: 0, // Deprecated - se calcula din√°micamente\r\n        serviceCount: 0, // Deprecated - se calcula din√°micamente\r\n\r\n        // Filters and Rules\r\n        ignoredLabels: team?.ignored_labels || [],\r\n        criticalRules: criticalRules as any[], // Explicit cast to avoid literal type mismatch\r\n        autoResponses,\r\n\r\n        // Integrations\r\n        evolutionApiKey: profile.evolution_api_key || '',\r\n        evolutionApiUrl: profile.evolution_api_url || 'https://evolutionapi-evolution-api.mcjhhb.easypanel.host',\r\n        elevenLabsVoiceId: undefined,\r\n\r\n        // Working Hours\r\n        workStartHour: profile.work_start_hour || 9,\r\n        workEndHour: profile.work_end_hour || 18,\r\n\r\n        // Limits\r\n        maxMessagesPerDay: undefined,\r\n\r\n        // Features\r\n        quotesEnabled: profile.quotes_enabled || false,\r\n        appointmentsEnabled: !!(aptConfig.is_enabled),\r\n        remindersEnabled: false\r\n    }\r\n\r\n    console.log(`‚úÖ [CONFIG] Configuration loaded successfully (New Schema)`)\r\n    console.log(`   - Company: ${config.companyName}`)\r\n    console.log(`   - Instance: ${config.instanceName}`)\r\n    console.log(`   - API Key Present: ${config.evolutionApiKey ? 'YES' : 'NO'} (${config.evolutionApiKey.substring(0, 4)}...)`)\r\n    return config\r\n}\r\n\r\n/**\r\n * Valida que la configuraci√≥n de la cuenta sea v√°lida\r\n */\r\nexport function validateAccountConfig(config: AccountConfig): { valid: boolean; errors: string[] } {\r\n    const errors: string[] = []\r\n\r\n    if (!config.userId) {\r\n        errors.push('Missing userId')\r\n    }\r\n\r\n    if (!config.instanceName) {\r\n        errors.push('Missing instanceName')\r\n    }\r\n\r\n    if (!config.evolutionApiKey) {\r\n        errors.push('Missing evolutionApiKey')\r\n    }\r\n\r\n    if (!config.companyName) {\r\n        errors.push('Missing companyName')\r\n    }\r\n\r\n    if (config.workStartHour < 0 || config.workStartHour > 23) {\r\n        errors.push('Invalid workStartHour (must be 0-23)')\r\n    }\r\n\r\n    if (config.workEndHour < 0 || config.workEndHour > 23) {\r\n        errors.push('Invalid workEndHour (must be 0-23)')\r\n    }\r\n\r\n    if (config.workStartHour >= config.workEndHour) {\r\n        errors.push('workStartHour must be less than workEndHour')\r\n    }\r\n\r\n    return {\r\n        valid: errors.length === 0,\r\n        errors\r\n    }\r\n}\r\n\r\n\r\n"},{"name":"config/constants.ts","content":"/**\r\n * ELINA V5 - Constants and Configuration\r\n * \r\n * Voy a usar supabase-ELINA\r\n * Confirmo: project_ref = mytvwfbijlgbihlegmfg\r\n */\r\n\r\n// API Configuration\r\nexport const OPENROUTER_API_URL = 'https://openrouter.ai/api/v1/chat/completions'\r\nexport const DEFAULT_MODEL = 'openai/gpt-4.1-mini'\r\nexport const FALLBACK_MODEL = 'openai/gpt-3.5-turbo'\r\n\r\n// Model Parameters\r\nexport const DEFAULT_TEMPERATURE = 0.7\r\nexport const DEFAULT_MAX_TOKENS = 1000\r\nexport const MAX_CONTEXT_MESSAGES = 10\r\n\r\n// Memory Configuration\r\nexport const REDIS_MESSAGE_BUFFER_TTL = 300 // 5 minutes\r\nexport const REDIS_MESSAGE_BUFFER_MAX = 10\r\nexport const CONVERSATION_SUMMARY_THRESHOLD = 20 // messages\r\n\r\n// Intent Detection\r\nexport const INTENT_CONFIDENCE_THRESHOLD = 0.7\r\nexport const CRITICAL_INTENT_THRESHOLD = 0.8\r\n\r\n// Delays (simulate human typing)\r\nexport const MIN_TYPING_DELAY = 500 // ms\r\nexport const MAX_TYPING_DELAY = 3000 // ms\r\nexport const CHARS_PER_SECOND = 50\r\n\r\n// Quote Generation\r\nexport const MIN_PRODUCTS_FOR_AUTO_QUOTE = 3\r\nexport const QUOTE_VALUE_THRESHOLD = 5000 // MXN\r\n\r\n// Embeddings\r\nexport const EMBEDDING_MODEL = 'text-embedding-3-small'\r\nexport const EMBEDDING_DIMENSIONS = 1536\r\nexport const RAG_SIMILARITY_THRESHOLD = 0.7\r\nexport const RAG_MAX_RESULTS = 5\r\n\r\n// Long-term Memory\r\nexport const LEARNING_CONFIDENCE_THRESHOLD = 0.6\r\nexport const LEARNING_USAGE_DECAY_DAYS = 30\r\n\r\n// Rate Limiting\r\nexport const MAX_MESSAGES_PER_MINUTE = 30\r\nexport const MAX_MESSAGES_PER_HOUR = 500\r\n\r\n// Evolution API\r\nexport const EVOLUTION_API_TIMEOUT = 10000 // ms\r\n\r\n// Bunny CDN\r\nexport const BUNNY_STORAGE_ZONE = 'elina-media'\r\nexport const BUNNY_CDN_URL = 'https://elina-media.b-cdn.net'\r\n\r\n// Feature Flags\r\nexport const ENABLE_LONG_TERM_MEMORY = true\r\nexport const ENABLE_SENTIMENT_ANALYSIS = true\r\nexport const ENABLE_OBJECTION_DETECTION = true\r\nexport const ENABLE_AUTO_LEARNING = true\r\n"},{"name":"config/types.ts","content":"/**\r\n * ELINA V5 - Type Definitions\r\n */\r\n\r\nimport type { SupabaseClient } from 'https://esm.sh/@supabase/supabase-js@2'\r\n\r\n// ============================================================================\r\n// Account Configuration\r\n// ============================================================================\r\n\r\nexport interface AccountConfig {\r\n    // Identification\r\n    userId: string\r\n    instanceName: string\r\n    serverUrl: string\r\n\r\n    // AI Configuration\r\n    model: string\r\n    temperature: number\r\n    maxTokens: number\r\n\r\n    // Company Info\r\n    companyName: string\r\n    companyDescription: string\r\n    website?: string\r\n    businessAddress?: string\r\n    businessPhone?: string\r\n    timezone: string\r\n    slug?: string // Company unique slug for profile link\r\n\r\n    // Personality\r\n    tone: 'profesional' | 'casual' | 'amigable' | 'formal'\r\n    customPrompt?: string\r\n\r\n    // Business Capabilities\r\n    businessType: 'ecommerce' | 'services' | 'hybrid' | 'appointments'\r\n    hasProducts: boolean\r\n    hasServices: boolean\r\n    hasAppointments: boolean\r\n    hasQuotes: boolean\r\n    hasShipping: boolean\r\n    productCount: number\r\n    serviceCount: number\r\n\r\n    // Filters and Rules\r\n    ignoredLabels: string[]\r\n    criticalRules: CriticalRule[]\r\n    autoResponses: AutoResponse[]\r\n\r\n    // Integrations\r\n    evolutionApiKey: string\r\n    evolutionApiUrl: string\r\n    elevenLabsVoiceId?: string\r\n\r\n    // Working Hours\r\n    workStartHour: number\r\n    workEndHour: number\r\n\r\n    // Limits\r\n    maxMessagesPerDay?: number\r\n\r\n    // Features\r\n    quotesEnabled: boolean\r\n    appointmentsEnabled: boolean\r\n    remindersEnabled: boolean\r\n}\r\n\r\n// ============================================================================\r\n// Rules and Responses\r\n// ============================================================================\r\n\r\nexport interface CriticalRule {\r\n    id: number\r\n    ruleName: string\r\n    ruleType: 'keyword' | 'pattern'\r\n    patternOrKeyword: string\r\n    detectionType: string\r\n    isActive: boolean\r\n    priority: number\r\n    caseSensitive: boolean\r\n}\r\n\r\nexport interface AutoResponse {\r\n    id: number\r\n    triggerText: string\r\n    responseText: string\r\n    isActive: boolean\r\n    matchType: 'exact' | 'contains'\r\n    mediaUrl?: string\r\n    mediaType: 'text' | 'image' | 'video' | 'audio' | 'document'\r\n}\r\n\r\n// ============================================================================\r\n// Intent Detection\r\n// ============================================================================\r\n\r\nexport enum Intent {\r\n    // Basic\r\n    GREETING = 'greeting',\r\n    FAREWELL = 'farewell',\r\n    GENERAL_QUESTION = 'general_question',\r\n\r\n    // Business\r\n    PRODUCT_INQUIRY = 'product_inquiry',\r\n    SERVICE_INQUIRY = 'service_inquiry',\r\n    PRICE_INQUIRY = 'price_inquiry',\r\n    STOCK_INQUIRY = 'stock_inquiry',\r\n    APPOINTMENT_REQUEST = 'appointment_request',\r\n    QUOTE_REQUEST = 'quote_request',\r\n    ORDER_STATUS = 'order_status',\r\n\r\n    // Critical\r\n    COMPLAINT = 'complaint',\r\n    URGENT_ISSUE = 'urgent_issue',\r\n    CANCELLATION = 'cancellation',\r\n    REFUND_REQUEST = 'refund_request',\r\n\r\n    // Conversational\r\n    SMALL_TALK = 'small_talk',\r\n    CLARIFICATION = 'clarification',\r\n    CONFIRMATION = 'confirmation',\r\n    OBJECTION = 'objection',\r\n\r\n    // Other\r\n    UNKNOWN = 'unknown'\r\n}\r\n\r\nexport interface IntentDetectionResult {\r\n    primary: Intent\r\n    secondary?: Intent[]\r\n    confidence: number\r\n    sentiment: SentimentAnalysis\r\n    entities: {\r\n        products?: string[]\r\n        services?: string[]\r\n        dates?: string[]\r\n        prices?: number[]\r\n        phoneNumbers?: string[]\r\n    }\r\n}\r\n\r\nexport interface SentimentAnalysis {\r\n    polarity: 'positive' | 'neutral' | 'negative'\r\n    score: number // -1 to 1\r\n    emotions?: string[]\r\n}\r\n\r\n// ============================================================================\r\n// Memory\r\n// ============================================================================\r\n\r\nexport interface ConversationContext {\r\n    // Recent Messages\r\n    recentMessages: Message[]\r\n\r\n    // Conversation Summary\r\n    summary?: string\r\n\r\n    // RAG Context\r\n    ragContext?: string\r\n\r\n    // Business Context\r\n    businessCapabilities?: BusinessCapabilities\r\n    topProducts?: Product[]\r\n    activePromotions?: Promotion[]\r\n    appointmentSlots?: AppointmentSlot[]\r\n    appointmentContext?: string\r\n\r\n    // User Preferences\r\n    userPreferences?: UserPreference[]\r\n\r\n    // Account Learnings\r\n    accountLearnings?: AccountLearning[]\r\n\r\n    // Conversation State (for contextual references)\r\n    conversationState?: ConversationContextState | null\r\n}\r\n\r\nexport interface MentionedProduct {\r\n    id: number\r\n    position: number  // 1, 2, 3... (order shown to user)\r\n    name: string\r\n    price: number\r\n    mentionedAt: string\r\n}\r\n\r\nexport interface CartItem {\r\n    product_id: number\r\n    quantity: number\r\n    addedAt: string\r\n}\r\n\r\nexport interface ConversationContextState {\r\n    lastProductsMentioned: MentionedProduct[]\r\n    tentativeCart: CartItem[]\r\n    lastIntent: string\r\n    lastAgentResponse?: string\r\n    appointmentContext?: any\r\n    potentialService?: {\r\n        id?: number\r\n        name: string\r\n    }\r\n    updatedAt: string\r\n}\r\n\r\nexport interface Message {\r\n    role: 'user' | 'assistant' | 'system'\r\n    content: string\r\n    timestamp?: Date\r\n}\r\n\r\nexport interface BusinessCapabilities {\r\n    primaryBusinessType: string | null\r\n    hasPhysicalProducts: boolean\r\n    productCount: number\r\n    hasServices: boolean\r\n    serviceCount: number\r\n    hasAppointments: boolean\r\n    appointmentCount: number\r\n    hasShippingSystem: boolean\r\n}\r\n\r\nexport interface Product {\r\n    id: number\r\n    productName: string\r\n    sku?: string\r\n    price: number\r\n    stock: number\r\n    description?: string\r\n    mediaUrl?: string\r\n    productType: 'physical' | 'service'\r\n    serviceDurationMinutes?: number\r\n}\r\n\r\nexport interface Promotion {\r\n    id: string\r\n    title: string\r\n    description?: string\r\n    benefits?: string\r\n    callToAction?: string\r\n    imageUrls?: string[]\r\n    discount?: string\r\n    offer?: string\r\n}\r\n\r\nexport interface AppointmentSlot {\r\n    start_time: string\r\n    end_time: string\r\n    service_id: number\r\n    service_name: string\r\n    duration_minutes: number\r\n    available?: boolean\r\n}\r\n\r\nexport interface UserPreference {\r\n    key: string\r\n    value: string\r\n    confidence: number\r\n    lastUpdated: Date\r\n}\r\n\r\nexport interface AccountLearning {\r\n    id: string\r\n    userId: string\r\n    learningType: 'pattern' | 'objection' | 'product_insight' | 'best_practice'\r\n    content: string\r\n    confidence: number\r\n    usageCount: number\r\n    lastUsed?: Date\r\n}\r\n\r\n// ============================================================================\r\n// Agent\r\n// ============================================================================\r\n\r\nexport interface AgentResponse {\r\n    text: string\r\n    toolCalls?: ToolCall[]\r\n    metadata: {\r\n        model: string\r\n        tokensUsed: number\r\n        finishReason: string\r\n        duration?: number\r\n    }\r\n}\r\n\r\nexport interface ToolCall {\r\n    id: string\r\n    type: 'function'\r\n    function: {\r\n        name: string\r\n        arguments: string\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// Database Types\r\n// ============================================================================\r\n\r\nexport interface Profile {\r\n    id: string\r\n    full_name?: string\r\n    email?: string\r\n    contact_phone?: string\r\n    evolution_instance_name?: string\r\n    evolution_api_key?: string\r\n    evolution_api_url?: string\r\n    company_description?: string\r\n    website?: string\r\n    business_address?: string\r\n    business_phone?: string\r\n    timezone?: string\r\n    slug?: string // Company slug for profile link\r\n    work_start_hour?: number\r\n    work_end_hour?: number\r\n    product_count?: number\r\n    service_count?: number\r\n    business_type?: string\r\n    quotes_enabled?: boolean\r\n    has_shipping_system?: boolean\r\n    // New fields for consolidation\r\n    system_prompt?: string\r\n    prompt_history?: any[]\r\n    appointment_config?: Record<string, any>\r\n    quote_config?: Record<string, any>\r\n    automation_settings?: Record<string, any>\r\n}\r\n\r\nexport interface AutomationRule {\r\n    id: string\r\n    user_id: string\r\n    name: string\r\n    type: 'critical' | 'auto_response' | 'promotion' | 'label_assignment'\r\n    trigger_type: 'keyword' | 'pattern' | 'intent' | 'schedule'\r\n    trigger_config: Record<string, any>\r\n    action_type: 'reply' | 'assign_label' | 'notify' | 'insert_content'\r\n    action_config: Record<string, any>\r\n    priority: number\r\n    is_active: boolean\r\n    created_at: string\r\n}\r\n\r\nexport interface Contact {\r\n    id: number\r\n    user_id: string\r\n    phone_number: string\r\n    full_name?: string\r\n    labels?: string[]\r\n    followup_status?: string\r\n    is_simulation?: boolean\r\n}\r\n\r\nexport interface Team {\r\n    id: string\r\n    owner_id: string\r\n    name: string\r\n    ignored_labels?: string[]\r\n}\r\n\r\nexport interface ConversationState {\r\n    id: number\r\n    contact_id: number\r\n    user_id: string\r\n    is_paused: boolean\r\n    pause_reason?: string\r\n    paused_at?: Date\r\n}\r\n\r\n// ============================================================================\r\n// Utility Types\r\n// ============================================================================\r\n\r\nexport interface FilterResult {\r\n    ignore: boolean\r\n    reason?: string\r\n}\r\n\r\nexport interface MediaProcessingResult {\r\n    transcription?: string\r\n    description?: string\r\n    mediaType: 'image' | 'audio' | 'video' | 'document'\r\n    success: boolean\r\n    error?: string\r\n}\r\n\r\nexport interface QuoteItem {\r\n    product_id: number\r\n    product_name: string\r\n    quantity: number\r\n    price: number\r\n    subtotal: number\r\n}\r\n\r\n\r\nexport interface PlaceholderResult {\r\n    finalText: string\r\n    productIds: number[]\r\n    productsMap: Record<string, Product>\r\n    shouldGenerateQuote: boolean\r\n    quoteItems: QuoteItem[]\r\n}\r\n\r\n// ============================================================================\r\n// Tool Calling\r\n// ============================================================================\r\n\r\nexport interface ToolCall {\r\n    id: string\r\n    type: 'function'\r\n    function: {\r\n        name: string\r\n        arguments: string  // JSON string\r\n    }\r\n}\r\n\r\nexport interface ToolResult {\r\n    tool_call_id: string\r\n    role: 'tool'\r\n    name: string\r\n    content: string  // JSON string\r\n}\r\n"},{"name":"core/filters.ts","content":"/**\r\n * ELINA V5 - Filters System\r\n * \r\n * Sistema de filtros para ignorar mensajes seg√∫n etiquetas, estado de conversaci√≥n, etc.\r\n */\r\n\r\nimport type { SupabaseClient } from 'https://esm.sh/@supabase/supabase-js@2'\r\nimport type { AccountConfig, FilterResult, Contact, ConversationState } from '../config/types.ts'\r\n\r\n/**\r\n * Determina si un mensaje debe ser ignorado\r\n */\r\nexport async function shouldIgnoreMessage(\r\n    supabase: SupabaseClient,\r\n    config: AccountConfig,\r\n    contactId: number\r\n): Promise<FilterResult> {\r\n    console.log(`üîç [FILTER] Checking if message should be ignored for contact ${contactId}`)\r\n\r\n    // 1. Obtener informaci√≥n del contacto\r\n    const { data: contact, error: contactError } = await supabase\r\n        .from('contacts')\r\n        .select('labels, is_simulation')\r\n        .eq('id', contactId)\r\n        .single()\r\n\r\n    if (contactError || !contact) {\r\n        console.warn(`‚ö†Ô∏è [FILTER] Contact not found: ${contactId}`)\r\n        return { ignore: false }\r\n    }\r\n\r\n    // 2. Verificar etiquetas ignoradas\r\n    const contactLabels = (contact as Contact).labels || []\r\n\r\n    // El usuario confirm√≥ expl√≠citamente: \"si entro de sus label existe 'ignorar' ingoramos\"\r\n    const hasIgnoredLabel = contactLabels.some(label =>\r\n        label.toLowerCase() === 'ignorar' ||\r\n        config.ignoredLabels.includes(label)\r\n    )\r\n\r\n    if (hasIgnoredLabel) {\r\n        console.log(`üö´ [FILTER] Contact has ignored label. Labels: ${contactLabels.join(', ')}`)\r\n        return {\r\n            ignore: true,\r\n            reason: `Contact marked as 'ignorar'`\r\n        }\r\n    }\r\n\r\n    // 3. Verificar si la conversaci√≥n est√° pausada\r\n    const { data: convState, error: convError } = await supabase\r\n        .from('conversation_states')\r\n        .select('is_paused, pause_reason')\r\n        .eq('contact_id', contactId)\r\n        .maybeSingle()\r\n\r\n    if (!convError && convState) {\r\n        const state = convState as ConversationState\r\n        if (state.is_paused) {\r\n            console.log(`‚è∏Ô∏è [FILTER] Conversation is paused: ${state.pause_reason}`)\r\n            return {\r\n                ignore: true,\r\n                reason: `Conversation paused: ${state.pause_reason || 'No reason provided'}`\r\n            }\r\n        }\r\n    }\r\n\r\n    // 4. Verificar horario laboral (solo si no es simulaci√≥n)\r\n    if (!contact.is_simulation) {\r\n        const now = new Date()\r\n        const currentHour = now.getHours()\r\n\r\n        if (currentHour < config.workStartHour || currentHour >= config.workEndHour) {\r\n            console.log(`üïê [FILTER] Outside working hours (${currentHour}:00, work hours: ${config.workStartHour}-${config.workEndHour})`)\r\n            // NO ignorar, pero podr√≠amos enviar un mensaje autom√°tico\r\n            // Por ahora, permitimos que el bot responda 24/7\r\n        }\r\n    }\r\n\r\n    console.log(`‚úÖ [FILTER] Message should be processed`)\r\n    return { ignore: false }\r\n}\r\n\r\n/**\r\n * Verifica si un contacto tiene una etiqueta espec√≠fica\r\n */\r\nexport async function contactHasLabel(\r\n    supabase: SupabaseClient,\r\n    contactId: number,\r\n    labelName: string\r\n): Promise<boolean> {\r\n    const { data, error } = await supabase\r\n        .from('contacts')\r\n        .select('labels')\r\n        .eq('id', contactId)\r\n        .single()\r\n\r\n    if (error || !data) {\r\n        return false\r\n    }\r\n\r\n    const labels = (data as Contact).labels || []\r\n    return labels.includes(labelName)\r\n}\r\n\r\n/**\r\n * Pausa una conversaci√≥n\r\n */\r\nexport async function pauseConversation(\r\n    supabase: SupabaseClient,\r\n    contactId: number,\r\n    userId: string,\r\n    reason: string\r\n): Promise<void> {\r\n    console.log(`‚è∏Ô∏è [FILTER] Pausing conversation for contact ${contactId}`)\r\n\r\n    const { error } = await supabase\r\n        .from('conversation_states')\r\n        .upsert({\r\n            contact_id: contactId,\r\n            user_id: userId,\r\n            is_paused: true,\r\n            pause_reason: reason,\r\n            paused_at: new Date().toISOString(),\r\n            paused_by: userId,\r\n            updated_at: new Date().toISOString()\r\n        }, {\r\n            onConflict: 'contact_id'\r\n        })\r\n\r\n    if (error) {\r\n        console.error(`‚ùå [FILTER] Error pausing conversation: ${error.message}`)\r\n        throw error\r\n    }\r\n\r\n    console.log(`‚úÖ [FILTER] Conversation paused successfully`)\r\n}\r\n\r\n/**\r\n * Reanuda una conversaci√≥n\r\n */\r\nexport async function resumeConversation(\r\n    supabase: SupabaseClient,\r\n    contactId: number,\r\n    userId: string\r\n): Promise<void> {\r\n    console.log(`‚ñ∂Ô∏è [FILTER] Resuming conversation for contact ${contactId}`)\r\n\r\n    const { error } = await supabase\r\n        .from('conversation_states')\r\n        .update({\r\n            is_paused: false,\r\n            pause_reason: null,\r\n            resumed_at: new Date().toISOString(),\r\n            resumed_by: userId,\r\n            updated_at: new Date().toISOString()\r\n        })\r\n        .eq('contact_id', contactId)\r\n\r\n    if (error) {\r\n        console.error(`‚ùå [FILTER] Error resuming conversation: ${error.message}`)\r\n        throw error\r\n    }\r\n\r\n    console.log(`‚úÖ [FILTER] Conversation resumed successfully`)\r\n}\r\n\r\n/**\r\n * Verifica si un mensaje es spam o abusivo\r\n */\r\nexport function isSpamOrAbusive(message: string): boolean {\r\n    // Detectar mensajes muy cortos repetidos\r\n    if (message.length < 3) {\r\n        return true\r\n    }\r\n\r\n    // Detectar caracteres repetidos excesivamente\r\n    const repeatedCharsRegex = /(.)\\1{10,}/\r\n    if (repeatedCharsRegex.test(message)) {\r\n        return true\r\n    }\r\n\r\n    // Detectar URLs sospechosas (opcional)\r\n    const suspiciousUrlRegex = /(bit\\.ly|tinyurl|goo\\.gl)/i\r\n    if (suspiciousUrlRegex.test(message)) {\r\n        console.warn(`‚ö†Ô∏è [FILTER] Suspicious URL detected in message`)\r\n        // No bloquear autom√°ticamente, solo advertir\r\n    }\r\n\r\n    return false\r\n}\r\n"},{"name":"index.ts","content":"/**\r\n * ELINA V5 - Main Orchestrator\r\n * \r\n * Voy a usar supabase-ELINA\r\n * Confirmo: project_ref = mytvwfbijlgbihlegmfg\r\n */\r\n\r\nimport { serve } from 'https://deno.land/std@0.168.0/http/server.ts'\r\nimport { createSupabaseAdminClient } from './utils/supabase.ts'\r\nimport { corsHeaders } from './utils/cors.ts'\r\nimport { loadAccountConfig, validateAccountConfig } from './config/account-config.ts'\r\nimport { shouldIgnoreMessage } from './core/filters.ts'\r\nimport { detectIntent, isCriticalIntent } from './intent/detector.ts'\r\nimport { runConversationalAgent } from './agents/conversational.ts'\r\nimport { sendMessage, sendImage, sendAudio } from './utils/evolution.ts'\r\nimport {\r\n    getProfileByInstance,\r\n    ensureContact,\r\n    loadConversationContext,\r\n    saveChatHistory\r\n} from './utils/context.ts'\r\n\r\nconsole.log('üöÄ ELINA V5 - Edge Function Started')\r\n\r\nserve(async (req) => {\r\n    // Handle CORS preflight\r\n    if (req.method === 'OPTIONS') {\r\n        return new Response('ok', { headers: corsHeaders })\r\n    }\r\n\r\n    const startTime = performance.now()\r\n\r\n    try {\r\n        const supabase = createSupabaseAdminClient()\r\n        const payload = await req.json()\r\n\r\n        console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ')\r\n        console.log('üîî [WEBHOOK] New message received')\r\n        console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ')\r\n\r\n        // ========================================================================\r\n        // 1. EXTRACT BASIC DATA\r\n        // ========================================================================\r\n        const data = payload?.data\r\n        if (!data) {\r\n            console.error('‚ùå [ERROR] Invalid payload: missing data')\r\n            return new Response(JSON.stringify({ error: 'Invalid payload' }), {\r\n                headers: { ...corsHeaders, 'Content-Type': 'application/json' },\r\n                status: 400\r\n            })\r\n        }\r\n\r\n        const { key, message, pushName } = data\r\n        let remoteJid = key?.remoteJid\r\n\r\n        // Handle LID (Linked Devices)\r\n        if (remoteJid?.includes('@lid')) {\r\n            remoteJid = key?.remoteJidAlt || remoteJid\r\n        }\r\n\r\n        // Clean suffix\r\n        remoteJid = remoteJid?.replace('@s.whatsapp.net', '')\r\n\r\n        const messageId = key?.id\r\n        const instanceName = payload?.instance\r\n        const isSimulation = payload?.isSimulation === true\r\n\r\n        console.log(`üìã [INFO] Instance: ${instanceName}`)\r\n        console.log(`üìã [INFO] Remote JID: ${remoteJid}`)\r\n        console.log(`üìã [INFO] Message ID: ${messageId}`)\r\n        console.log(`üìã [INFO] Simulation: ${isSimulation}`)\r\n\r\n        // Validate required fields\r\n        if (!remoteJid || !messageId || !instanceName) {\r\n            console.error('‚ùå [ERROR] Missing required fields')\r\n            return new Response(JSON.stringify({ error: 'Missing required fields' }), {\r\n                headers: corsHeaders,\r\n                status: 400\r\n            })\r\n        }\r\n\r\n        // Ignore status broadcasts and own messages\r\n        if (remoteJid === 'status@broadcast' || key?.fromMe) {\r\n            console.log('‚è≠Ô∏è [INFO] Ignoring status broadcast or own message')\r\n            return new Response(JSON.stringify({ ignored: true }), {\r\n                headers: corsHeaders,\r\n                status: 200\r\n            })\r\n        }\r\n\r\n        // ========================================================================\r\n        // 2. LOAD ACCOUNT CONFIGURATION\r\n        // ========================================================================\r\n        console.log(`\\nüìã [CONFIG] Loading account configuration...`)\r\n\r\n        const profile = await getProfileByInstance(supabase, instanceName)\r\n        const config = await loadAccountConfig(supabase, profile.id)\r\n\r\n        // Validate configuration\r\n        const validation = validateAccountConfig(config)\r\n        if (!validation.valid) {\r\n            console.error(`‚ùå [CONFIG] Invalid configuration: ${validation.errors.join(', ')}`)\r\n            return new Response(JSON.stringify({ error: 'Invalid account configuration', details: validation.errors }), {\r\n                headers: corsHeaders,\r\n                status: 500\r\n            })\r\n        }\r\n\r\n        console.log(`‚úÖ [CONFIG] Configuration loaded for: ${config.companyName}`)\r\n\r\n        // ========================================================================\r\n        // 3. ENSURE CONTACT EXISTS\r\n        // ========================================================================\r\n        console.log(`\\nüë§ [CONTACT] Ensuring contact exists...`)\r\n\r\n        const contact = await ensureContact(supabase, profile.id, remoteJid, pushName)\r\n        console.log(`‚úÖ [CONTACT] Contact ID: ${contact.id}`)\r\n\r\n        // ========================================================================\r\n        // 4. CHECK FILTERS\r\n        // ========================================================================\r\n        console.log(`\\nüîç [FILTER] Checking filters...`)\r\n\r\n        const filterResult = await shouldIgnoreMessage(supabase, config, contact.id)\r\n        if (filterResult.ignore) {\r\n            console.log(`üö´ [FILTER] Message ignored: ${filterResult.reason}`)\r\n            return new Response(JSON.stringify({\r\n                ignored: true,\r\n                reason: filterResult.reason\r\n            }), {\r\n                headers: corsHeaders,\r\n                status: 200\r\n            })\r\n        }\r\n\r\n        console.log(`‚úÖ [FILTER] Message should be processed`)\r\n\r\n        // ========================================================================\r\n        // 5. EXTRACT MESSAGE TEXT\r\n        // ========================================================================\r\n        let messageText = message.conversation ||\r\n            message.extendedTextMessage?.text ||\r\n            ''\r\n\r\n        if (!messageText) {\r\n            console.log('‚è≠Ô∏è [INFO] No text message found (media only or unsupported type)')\r\n            return new Response(JSON.stringify({ ignored: true, reason: 'No text content' }), {\r\n                headers: corsHeaders,\r\n                status: 200\r\n            })\r\n        }\r\n\r\n        console.log(`\\nüí¨ [MESSAGE] Text: \"${messageText.substring(0, 100)}${messageText.length > 100 ? '...' : ''}\"`)\r\n\r\n        // ========================================================================\r\n        // 5.5 MESSAGE BUFFERING (Group rapid consecutive messages)\r\n        // Uses Supabase table to coordinate between independent requests\r\n        // ========================================================================\r\n        if (!isSimulation) {\r\n            console.log(`\\n‚è≥ [BUFFER] Checking for rapid consecutive messages...`)\r\n            const { bufferMessage } = await import('./utils/message-buffer.ts')\r\n            const bufferResult = await bufferMessage(supabase, profile.id, contact.id, messageText)\r\n\r\n            if (!bufferResult.shouldProcess) {\r\n                // A newer message arrived ‚Äî this request should NOT process\r\n                console.log(`‚è≠Ô∏è [BUFFER] Deferring to newer message, this request ends here`)\r\n                return new Response(JSON.stringify({ buffered: true, reason: 'Deferred to newer message' }), {\r\n                    headers: { ...corsHeaders, 'Content-Type': 'application/json' },\r\n                    status: 200\r\n                })\r\n            }\r\n\r\n            messageText = bufferResult.combinedText\r\n            if (bufferResult.combinedText.includes('\\n')) {\r\n                console.log(`‚úÖ [BUFFER] Processing ${bufferResult.combinedText.split('\\n').length} combined messages`)\r\n            }\r\n        }\r\n\r\n        // ========================================================================\r\n        // 6. CHECK AUTO RESPONSES\r\n        // ========================================================================\r\n        console.log(`\\nü§ñ [AUTOMATION] Checking auto-responses...`)\r\n        const { checkAutoResponses } = await import('./utils/automation.ts')\r\n        const autoResponse = checkAutoResponses(messageText, config)\r\n\r\n        if (autoResponse) {\r\n            console.log(`‚úÖ [AUTOMATION] Auto-response triggered: ${autoResponse.triggerText}`)\r\n\r\n            // üîÑ NUEVO: Solo enviar si NO es simulaci√≥n\r\n            if (!isSimulation) {\r\n                await sendMessage(config, remoteJid, autoResponse.responseText)\r\n            }\r\n\r\n            // Save history\r\n            await saveChatHistory(\r\n                supabase,\r\n                profile.id,\r\n                contact.id,\r\n                messageText,\r\n                autoResponse.responseText,\r\n                {\r\n                    primary: 'auto_response' as any,\r\n                    confidence: 1.0,\r\n                    sentiment: { polarity: 'neutral', score: 0 },\r\n                    entities: {}\r\n                }\r\n            )\r\n\r\n            return new Response(JSON.stringify({\r\n                success: true,\r\n                intent: 'auto_response',\r\n                response: autoResponse.responseText\r\n            }), { headers: corsHeaders })\r\n        }\r\n\r\n        // ========================================================================\r\n        // 6. DETECT INTENT\r\n        // ========================================================================\r\n        console.log(`\\nüéØ [INTENT] Detecting intent...`)\r\n\r\n        const conversationHistory = await loadConversationContext(\r\n            supabase,\r\n            config,\r\n            contact,\r\n            messageText,\r\n            { primary: 'unknown' }\r\n        ).then(ctx => ctx.recentMessages)\r\n\r\n        const intent = await detectIntent(messageText, config, conversationHistory)\r\n\r\n        console.log(`‚úÖ [INTENT] Detected: ${intent.primary}`)\r\n        console.log(`   - Confidence: ${intent.confidence}`)\r\n        console.log(`   - Sentiment: ${intent.sentiment.polarity} (${intent.sentiment.score})`)\r\n\r\n        // Handle critical intents\r\n        if (isCriticalIntent(intent.primary)) {\r\n            console.log(`üö® [CRITICAL] Critical intent detected: ${intent.primary}`)\r\n            // TODO: Notify account owner\r\n        }\r\n\r\n        // ========================================================================\r\n        // 7. LOAD FULL CONTEXT\r\n        // ========================================================================\r\n        console.log(`\\nüìö [CONTEXT] Loading conversation context...`)\r\n\r\n        const context = await loadConversationContext(\r\n            supabase,\r\n            config,\r\n            contact,\r\n            messageText,\r\n            intent\r\n        )\r\n\r\n        console.log(`‚úÖ [CONTEXT] Context loaded`)\r\n        console.log(`   - Recent messages: ${context.recentMessages.length}`)\r\n        console.log(`   - Account learnings: ${context.accountLearnings?.length || 0}`)\r\n        console.log(`   - User preferences: ${context.userPreferences?.length || 0}`)\r\n\r\n        // ========================================================================\r\n        // 8. RUN CONVERSATIONAL AGENT\r\n        // ========================================================================\r\n        console.log(`\\nü§ñ [AGENT] Running conversational agent...`)\r\n\r\n        const agentResponse = await runConversationalAgent(\r\n            supabase,\r\n            config,\r\n            messageText,\r\n            intent,\r\n            context\r\n        )\r\n\r\n        // ========================================================================\r\n        // 8.5. EXECUTE TOOL CALLS (if any)\r\n        // ========================================================================\r\n        let executedToolResults: any[] = []  // üî• Guardar para recopilar media despu√©s\r\n\r\n        if (agentResponse.toolCalls && agentResponse.toolCalls.length > 0) {\r\n            console.log(`\\nüîß [TOOLS] Agent requested ${agentResponse.toolCalls.length} tool call(s)`)\r\n\r\n            const { executeToolCalls } = await import('./utils/tool-executor.ts')\r\n\r\n            const toolResults = await executeToolCalls(\r\n                supabase,\r\n                config,\r\n                contact.id,\r\n                agentResponse.toolCalls\r\n            )\r\n\r\n            executedToolResults = toolResults  // üî• Guardar para usar despu√©s\r\n\r\n            console.log(`‚úÖ [TOOLS] Tool calls executed, re-calling agent with results`)\r\n\r\n            // Re-llamar al agente con los resultados de las herramientas\r\n            const finalAgentResponse = await runConversationalAgent(\r\n                supabase,\r\n                config,\r\n                messageText,\r\n                intent,\r\n                context,\r\n                agentResponse.toolCalls,  // ‚Üê Pasar tool_calls originales\r\n                toolResults               // ‚Üê Pasar resultados\r\n            )\r\n\r\n            // Usar la respuesta final\r\n            agentResponse.text = finalAgentResponse.text\r\n            agentResponse.metadata = finalAgentResponse.metadata\r\n        }\r\n\r\n        if (!agentResponse.text || agentResponse.text.trim() === '') {\r\n            console.warn('‚ö†Ô∏è [AGENT] Empty response received. Using fallback.')\r\n            agentResponse.text = 'Lo siento, tuve un problema procesando tu mensaje. ¬øPodr√≠as repetirlo?'\r\n        }\r\n\r\n        console.log(`‚úÖ [AGENT] Response generated`)\r\n        console.log(`   - Length: ${agentResponse.text.length} chars`)\r\n        console.log(`   - Tokens used: ${agentResponse.metadata.tokensUsed}`)\r\n        console.log(`   - Duration: ${agentResponse.metadata.duration?.toFixed(0)}ms`)\r\n\r\n        // ========================================================================\r\n        // 9. PROCESS PLACEHOLDERS & EXTRACT MEDIA\r\n        // ========================================================================\r\n        console.log(`\\nüß© [PLACEHOLDERS] Processing placeholders...`)\r\n\r\n        const { processPlaceholders } = await import('./utils/placeholders.ts')\r\n\r\n        const placeholderResult = await processPlaceholders(\r\n            supabase,\r\n            config.userId,\r\n            agentResponse.text\r\n        )\r\n\r\n        let finalText = placeholderResult.finalText\r\n\r\n        // Variable to hold product media for later use\r\n        let productMediaForSending: Array<{ url: string, type: 'image' | 'video' }> = []\r\n\r\n        // ========================================================================\r\n        // 10. RECOPILAR MEDIA & CALCULATE TOTALS (C√ìDIGO HACE EL TRABAJO)\r\n        // ========================================================================\r\n        console.log(`\\nüñºÔ∏è [MEDIA] Collecting media from products and text... (v2.0 - UPDATED)`)\r\n\r\n        const mediaToSend: Array<{ url: string, type: 'image' | 'video', source: 'product' | 'text' }> = []\r\n\r\n        // --- A. PRIMERO: Media de productos (garantizada si el producto tiene media) ---\r\n        // Esto asegura que si un producto fue mencionado y tiene media, SE ENV√çA SIEMPRE\r\n        if (placeholderResult.productMedia && placeholderResult.productMedia.length > 0) {\r\n            console.log(`   - Found ${placeholderResult.productMedia.length} media from products (via placeholders)`)\r\n\r\n            placeholderResult.productMedia.forEach(media => {\r\n                mediaToSend.push({\r\n                    url: media.url,\r\n                    type: media.type,\r\n                    source: 'product'\r\n                })\r\n            })\r\n        }\r\n\r\n        // üî• FALLBACK: Tambi√©n buscar media en tool results (por si el LLM olvid√≥ usar placeholders)\r\n        if (executedToolResults.length > 0) {\r\n            console.log(`   - Checking tool results for additional product media...`)\r\n\r\n            for (const toolResult of executedToolResults) {\r\n                if (toolResult.role === 'tool' && toolResult.content) {\r\n                    try {\r\n                        const content = JSON.parse(toolResult.content)\r\n\r\n                        // Si es resultado de buscar_productos\r\n                        if (content.products && Array.isArray(content.products)) {\r\n                            console.log(`   - Found ${content.products.length} products in tool result`)\r\n\r\n                            content.products.forEach((product: any) => {\r\n                                if (product.media_url && product.media_url.trim()) {\r\n                                    const isVideo = /\\.(mp4|mov|avi|webm)$/i.test(product.media_url)\r\n\r\n                                    // Evitar duplicados (comparar URL)\r\n                                    if (!mediaToSend.find(m => m.url === product.media_url)) {\r\n                                        mediaToSend.push({\r\n                                            url: product.media_url,\r\n                                            type: isVideo ? 'video' : 'image',\r\n                                            source: 'product'\r\n                                        })\r\n                                        console.log(`   - Added media from product ID ${product.id}: ${product.media_url}`)\r\n                                    }\r\n                                }\r\n                            })\r\n                        }\r\n                    } catch (e) {\r\n                        // No es JSON v√°lido, continuar\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // --- B. SEGUNDO: Extracci√≥n adicional del texto (por si el LLM agreg√≥ media extra) ---\r\n        // 1. Detectar URLs de Markdown: ![alt](url)\r\n        const markdownRegex = /!\\[([^\\]]*)\\]\\((https:\\/\\/creativersezone\\.b-cdn\\.net\\/[^\\)]+\\.(jpg|jpeg|png|gif|webp|mp4|mov|avi|webm))\\)/gi\r\n        const markdownMatches = [...finalText.matchAll(markdownRegex)]\r\n\r\n        for (const match of markdownMatches) {\r\n            const url = match[2]\r\n            const isVideo = /\\.(mp4|mov|avi|webm)$/i.test(url)\r\n\r\n            // Solo agregar si no est√° ya en la lista (evitar duplicados con product media)\r\n            if (!mediaToSend.find(m => m.url === url)) {\r\n                mediaToSend.push({\r\n                    url: url,\r\n                    type: isVideo ? 'video' : 'image',\r\n                    source: 'text'\r\n                })\r\n            }\r\n        }\r\n\r\n        // 2. Detectar URLs puras (Raw)\r\n        const mediaUrlRegex = /https:\\/\\/creativersezone\\.b-cdn\\.net\\/[^\\s\\)]+\\.(jpg|jpeg|png|gif|webp|mp4|mov|avi|webm)/gi\r\n        let matches = finalText.match(mediaUrlRegex)\r\n\r\n        if (matches) {\r\n            for (const url of matches) {\r\n                const isVideo = /\\.(mp4|mov|avi|webm)$/i.test(url)\r\n\r\n                // Solo agregar si no est√° ya en la lista\r\n                if (!mediaToSend.find(m => m.url === url)) {\r\n                    mediaToSend.push({\r\n                        url: url,\r\n                        type: isVideo ? 'video' : 'image',\r\n                        source: 'text'\r\n                    })\r\n                }\r\n            }\r\n        }\r\n\r\n        // --- C. Limpieza de URLs y Markdown de Imagen del texto (GLOBAL) ---\r\n        // Remover markdown de imagen COMPLETO\r\n        finalText = finalText.replace(markdownRegex, '')\r\n\r\n        // Remover URLs sueltas globalmente\r\n        finalText = finalText.replace(mediaUrlRegex, '')\r\n\r\n        // --- D. Regla de Negocio: M√°ximo 3 media files ---\r\n        const MAX_MEDIA = 3\r\n        const finalMediaToSend = mediaToSend.slice(0, MAX_MEDIA)\r\n\r\n        if (mediaToSend.length > MAX_MEDIA) {\r\n            console.log(`   ‚ö†Ô∏è Limitando media: ${mediaToSend.length} encontrados -> enviando ${MAX_MEDIA}`)\r\n        }\r\n\r\n        // --- C. C√°lculos de Subtotales y Totales (L√≥gica n8n V4) ---\r\n        console.log(`\\nüßÆ [CALCS] Running n8n-style calculations...`)\r\n\r\n        // Regex para detectar l√≠neas de item y calcular subtotal\r\n        // Ejemplo: \"5 piezas Subtotal: $[subtotal_calculado]\"\r\n        const subtotalRegex = /(\\d+)\\s*piezas?\\s*Subtotal:\\s*\\$\\[subtotal_calculado\\]/gi\r\n        let totalAcumulado = 0\r\n\r\n        finalText = finalText.replace(subtotalRegex, (match, qtyStr, offset) => {\r\n            const qty = parseInt(qtyStr, 10)\r\n            // Buscar el precio anterior m√°s cercano en el texto\r\n            const textBefore = finalText.substring(0, offset)\r\n            const pricesFound = textBefore.match(/\\$([\\d,]+(?:\\.\\d{2})?)/g)\r\n\r\n            if (pricesFound && pricesFound.length > 0) {\r\n                const lastPriceStr = pricesFound[pricesFound.length - 1].replace(/[$,]/g, \"\")\r\n                const price = parseFloat(lastPriceStr)\r\n\r\n                if (!isNaN(price)) {\r\n                    const subtotal = qty * price\r\n                    totalAcumulado += subtotal\r\n                    return `${qty} piezas Subtotal: $${subtotal.toLocaleString('es-MX', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`\r\n                }\r\n            }\r\n            return match // Si no se encuentra precio, dejar igual\r\n        })\r\n\r\n        // Reemplazar placeholder de Total General\r\n        finalText = finalText.replace(/\\$\\[TOTAL_CALCULADO\\]/gi, \"$\" + totalAcumulado.toLocaleString(\"es-MX\", { minimumFractionDigits: 2, maximumFractionDigits: 2 }))\r\n\r\n        // --- D. Formato de Texto (Limpieza) ---\r\n        finalText = finalText\r\n            // Convertir negritas de Markdown (**) a WhatsApp (*)\r\n            .replace(/\\*\\*([^*]+)\\*\\*/g, '*$1*')\r\n            // Eliminar corchetes vac√≠os si quedaron de links mal formados \"[]()\"\r\n            .replace(/\\[\\s*\\]\\(\\s*\\)/g, '')\r\n            // Eliminar espacios m√∫ltiples\r\n            .replace(/\\s{2,}/g, ' ')\r\n            // Asegurar saltos de l√≠nea limpios (m√°ximo 2)\r\n            .replace(/\\n{3,}/g, '\\n\\n')\r\n            .trim()\r\n\r\n        const productMediaCount = mediaToSend.filter(m => m.source === 'product').length\r\n        const textMediaCount = mediaToSend.filter(m => m.source === 'text').length\r\n\r\n        console.log(`   - Found ${mediaToSend.length} total media URL(s)`)\r\n        console.log(`     ‚Ä¢ ${productMediaCount} from products (guaranteed)`)\r\n        console.log(`     ‚Ä¢ ${textMediaCount} from text (LLM generated)`)\r\n        console.log(`   - Sending ${finalMediaToSend.length} media file(s)`)\r\n        console.log(`   - Cleaned text length: ${finalText.length}`)\r\n\r\n        // üî• CRITICAL: Save media for later use in sending section\r\n        productMediaForSending = finalMediaToSend.map(m => ({ url: m.url, type: m.type }))\r\n\r\n        // ========================================================================\r\n        // 11. SEND RESPONSE WITH MEDIA (N8N V4 STYLE)\r\n        // ========================================================================\r\n        console.log(`\\nüì§ [SEND] Sending response...`)\r\n\r\n        // üîÑ NUEVO: Solo enviar mensajes reales si NO es simulaci√≥n\r\n        if (!isSimulation) {\r\n\r\n        if (finalMediaToSend.length > 0) {\r\n            console.log(`   - Sending ${finalMediaToSend.length} media message(s)`)\r\n\r\n            // ========================================================================\r\n            // DISTRIBUCI√ìN INTELIGENTE DE TEXTO ENTRE CAPTIONS (n8n V4 logic)\r\n            // ========================================================================\r\n\r\n            // Si tenemos productMedia (productos garantizados), usar distribuci√≥n inteligente\r\n            if (placeholderResult.productMedia && placeholderResult.productMedia.length > 0) {\r\n                console.log(`   - Using smart text distribution across product media`)\r\n\r\n                const { distributeTextAcrossProductMedia } = await import('./utils/text-formatter.ts')\r\n\r\n                const mediaWithCaptions = distributeTextAcrossProductMedia(\r\n                    finalText,\r\n                    placeholderResult.productMedia.slice(0, 3), // Max 3\r\n                    placeholderResult.productsMap,\r\n                    3\r\n                )\r\n\r\n                console.log(`   - Generated ${mediaWithCaptions.length} media with captions`)\r\n\r\n                // Enviar cada media con su caption\r\n                for (let i = 0; i < mediaWithCaptions.length; i++) {\r\n                    const item = mediaWithCaptions[i]\r\n\r\n                    console.log(`   - Sending media ${i + 1}/${mediaWithCaptions.length} (Product ID: ${item.productId})`)\r\n                    console.log(`     Caption length: ${item.caption.length} chars`)\r\n\r\n                    if (item.type === 'video') {\r\n                        const { sendVideo } = await import('./utils/evolution.ts')\r\n                        await sendVideo(config, remoteJid, item.url, item.caption)\r\n                    } else {\r\n                        await sendImage(config, remoteJid, item.url, item.caption)\r\n                    }\r\n\r\n                    // Delay entre mensajes\r\n                    if (i < mediaWithCaptions.length - 1) {\r\n                        await new Promise(r => setTimeout(r, 600))\r\n                    }\r\n                }\r\n\r\n            } else {\r\n                // ========================================================================\r\n                // FALLBACK: Media sin productos (media del texto LLM)\r\n                // ========================================================================\r\n                console.log(`   - Using fallback: media without product distribution`)\r\n\r\n                if (finalMediaToSend.length === 1) {\r\n                    // UNA SOLA MEDIA - Todo el texto como caption\r\n                    const media = finalMediaToSend[0]\r\n                    console.log(`   - Sending single media with full text as caption`)\r\n\r\n                    if (media.type === 'video') {\r\n                        const { sendVideo } = await import('./utils/evolution.ts')\r\n                        await sendVideo(config, remoteJid, media.url, finalText)\r\n                    } else {\r\n                        await sendImage(config, remoteJid, media.url, finalText)\r\n                    }\r\n\r\n                } else {\r\n                    // M√öLTIPLES MEDIA - Sin caption, texto al final\r\n                    console.log(`   - Sending multiple media, text will be sent after`)\r\n\r\n                    for (let i = 0; i < finalMediaToSend.length; i++) {\r\n                        const media = finalMediaToSend[i]\r\n\r\n                        if (media.type === 'video') {\r\n                            const { sendVideo } = await import('./utils/evolution.ts')\r\n                            await sendVideo(config, remoteJid, media.url, '')\r\n                        } else {\r\n                            await sendImage(config, remoteJid, media.url, '')\r\n                        }\r\n\r\n                        if (i < finalMediaToSend.length - 1) {\r\n                            await new Promise(r => setTimeout(r, 600))\r\n                        }\r\n                    }\r\n\r\n                    // Texto al final\r\n                    if (finalText.length > 0) {\r\n                        await new Promise(r => setTimeout(r, 600))\r\n                        await sendMessage(config, remoteJid, finalText, true)\r\n                    }\r\n                }\r\n            }\r\n\r\n        } else {\r\n            // Sin media - Enviar solo texto\r\n            await sendMessage(config, remoteJid, finalText, true)\r\n        }\r\n\r\n        // Si se requiere cotizaci√≥n PDF\r\n        if (placeholderResult.shouldGenerateQuote) {\r\n            console.log(`üìÑ [QUOTE] Generating quote PDF...`)\r\n            // TODO: Implementar generaci√≥n real de PDF\r\n        }\r\n\r\n        } // üîÑ FIN: Cierre de if (!isSimulation)\r\n\r\n        console.log(`‚úÖ [SEND] Response sent successfully${isSimulation ? ' (simulation mode - no messages sent)' : ''}`)\r\n\r\n        // ========================================================================\r\n        // 11. SAVE TO HISTORY\r\n        // ========================================================================\r\n        console.log(`\\nüíæ [HISTORY] Saving to chat history...`)\r\n\r\n        await saveChatHistory(\r\n            supabase,\r\n            profile.id,\r\n            contact.id,\r\n            messageText,\r\n            finalText, // Guardamos el texto final\r\n            intent\r\n        )\r\n\r\n        console.log(`‚úÖ [HISTORY] Saved successfully`)\r\n\r\n        // ========================================================================\r\n        // 12. FINAL METRICS\r\n        // ========================================================================\r\n        const totalDuration = performance.now() - startTime\r\n\r\n        console.log('\\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ')\r\n        console.log(`‚úÖ [SUCCESS] Message processed successfully`)\r\n        console.log(`‚è±Ô∏è  Total duration: ${totalDuration.toFixed(0)}ms`)\r\n        console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n')\r\n\r\n        return new Response(JSON.stringify({\r\n            success: true,\r\n            intent: intent.primary,\r\n            sentiment: intent.sentiment.polarity,\r\n            duration: totalDuration,\r\n            tokensUsed: agentResponse.metadata.tokensUsed,\r\n            quoteGenerated: placeholderResult.shouldGenerateQuote,\r\n            toolCalls: agentResponse.toolCalls,\r\n            userId: profile.id, // <--- Verify which user is being used\r\n            text: agentResponse.text, // <--- CRITICAL: Sending the AI response text\r\n            message: agentResponse.text, // <--- Compatibility\r\n            response: agentResponse.text // <--- Compatibility\r\n        }), {\r\n            headers: { ...corsHeaders, 'Content-Type': 'application/json' }\r\n        })\r\n\r\n    } catch (error) {\r\n        console.error('\\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ')\r\n        console.error('‚ùå [ERROR] Fatal error processing message')\r\n        console.error(`   Message: ${error.message}`)\r\n        console.error(`   Stack: ${error.stack}`)\r\n        console.error('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n')\r\n\r\n        return new Response(JSON.stringify({\r\n            error: error.message,\r\n            stack: error.stack\r\n        }), {\r\n            headers: { ...corsHeaders, 'Content-Type': 'application/json' },\r\n            status: 500\r\n        })\r\n    }\r\n})\r\n"},{"name":"intent/detector.ts","content":"/**\r\n * ELINA V5 - Intent Detection System\r\n * \r\n * Sistema avanzado de detecci√≥n de intenciones con an√°lisis de sentimientos\r\n */\r\n\r\nimport type { AccountConfig, Intent, IntentDetectionResult, SentimentAnalysis, Message } from '../config/types.ts'\r\nimport { INTENT_CONFIDENCE_THRESHOLD } from '../config/constants.ts'\r\n\r\n/**\r\n * Detecta la intenci√≥n del mensaje del usuario\r\n */\r\nexport async function detectIntent(\r\n    message: string,\r\n    config: AccountConfig,\r\n    conversationHistory: Message[] = []\r\n): Promise<IntentDetectionResult> {\r\n    console.log(`üéØ [INTENT] Detecting intent for message: \"${message.substring(0, 50)}...\"`)\r\n\r\n    // 1. Detecci√≥n basada en reglas (r√°pido)\r\n    const ruleBasedIntent = detectIntentByRules(message, config)\r\n\r\n    // 2. Si la confianza es alta, usar el resultado de reglas\r\n    if (ruleBasedIntent.confidence >= INTENT_CONFIDENCE_THRESHOLD) {\r\n        console.log(`‚úÖ [INTENT] Rule-based detection: ${ruleBasedIntent.primary} (${ruleBasedIntent.confidence})`)\r\n        return ruleBasedIntent\r\n    }\r\n\r\n    // 3. Si no, usar LLM para mayor precisi√≥n (m√°s lento)\r\n    console.log(`ü§ñ [INTENT] Using LLM for intent detection (low confidence: ${ruleBasedIntent.confidence})`)\r\n    return await detectIntentByLLM(message, config, conversationHistory)\r\n}\r\n\r\n/**\r\n * Detecci√≥n de intenci√≥n basada en reglas y patrones\r\n */\r\nfunction detectIntentByRules(\r\n    message: string,\r\n    config: AccountConfig\r\n): IntentDetectionResult {\r\n    const lowerMessage = message.toLowerCase().trim()\r\n    const sentiment = analyzeSentiment(message)\r\n\r\n    // Saludos\r\n    if (/^(hola|buenos d√≠as|buenas tardes|buenas noches|hey|qu√© tal|saludos|buen d√≠a)/i.test(message)) {\r\n        return {\r\n            primary: 'greeting' as Intent,\r\n            confidence: 0.95,\r\n            sentiment,\r\n            entities: {}\r\n        }\r\n    }\r\n\r\n    // Despedidas\r\n    if (/^(adi√≥s|hasta luego|nos vemos|chao|bye|gracias|ok gracias)/i.test(message)) {\r\n        return {\r\n            primary: 'farewell' as Intent,\r\n            confidence: 0.9,\r\n            sentiment,\r\n            entities: {}\r\n        }\r\n    }\r\n\r\n    // Quejas (CR√çTICO)\r\n    if (/\\b(queja|reclamo|molesto|enojado|mal servicio|p√©simo|horrible|terrible|decepcionado|fraude|estafa)\\b/i.test(lowerMessage)) {\r\n        return {\r\n            primary: 'complaint' as Intent,\r\n            confidence: 0.95,\r\n            sentiment: { polarity: 'negative', score: -0.8 },\r\n            entities: {}\r\n        }\r\n    }\r\n\r\n    // Urgencias (CR√çTICO)\r\n    if (/\\b(urgente|emergencia|ayuda|problema grave|necesito ya|inmediato)\\b/i.test(lowerMessage)) {\r\n        return {\r\n            primary: 'urgent_issue' as Intent,\r\n            confidence: 0.9,\r\n            sentiment: { polarity: 'negative', score: -0.6 },\r\n            entities: {}\r\n        }\r\n    }\r\n\r\n    // Cancelaciones\r\n    if (/\\b(cancelar|anular|ya no quiero|mejor no|desistir)\\b/i.test(lowerMessage)) {\r\n        return {\r\n            primary: 'cancellation' as Intent,\r\n            confidence: 0.85,\r\n            sentiment,\r\n            entities: {}\r\n        }\r\n    }\r\n\r\n    // Citas (solo si est√° habilitado)\r\n    if (config.hasAppointments || config.appointmentsEnabled) {\r\n        if (/\\b(cita|agendar|reservar|turno|hora|consulta|appointment)\\b/i.test(lowerMessage)) {\r\n            return {\r\n                primary: 'appointment_request' as Intent,\r\n                confidence: 0.9,\r\n                sentiment,\r\n                entities: extractEntities(message)\r\n            }\r\n        }\r\n    }\r\n\r\n    // Cotizaciones\r\n    if (config.quotesEnabled || config.hasQuotes) {\r\n        if (/\\b(cotizaci√≥n|presupuesto|precio total|cu√°nto ser√≠a todo|quote)\\b/i.test(lowerMessage)) {\r\n            return {\r\n                primary: 'quote_request' as Intent,\r\n                confidence: 0.85,\r\n                sentiment,\r\n                entities: extractEntities(message)\r\n            }\r\n        }\r\n    }\r\n\r\n    // Productos\r\n    if (config.hasProducts) {\r\n        if (/\\b(producto|art√≠culo|precio|costo|cu√°nto|disponible|stock|inventario|comprar|vend(es|en)|tien(es|en)|ofrec(es|en)|manej(as|an)|cat√°logo|qu√© si vend)\\b/i.test(lowerMessage)) {\r\n            return {\r\n                primary: 'product_inquiry' as Intent,\r\n                confidence: 0.8,\r\n                sentiment,\r\n                entities: extractEntities(message)\r\n            }\r\n        }\r\n    }\r\n\r\n    // Servicios\r\n    if (config.hasServices) {\r\n        if (/\\b(servicio|ofreces|haces|realizas|cu√°nto cobras)\\b/i.test(lowerMessage)) {\r\n            return {\r\n                primary: 'service_inquiry' as Intent,\r\n                confidence: 0.8,\r\n                sentiment,\r\n                entities: extractEntities(message)\r\n            }\r\n        }\r\n    }\r\n\r\n    // Confirmaciones\r\n    if (/^(s√≠|si|yes|ok|est√° bien|perfecto|de acuerdo|confirmo|acepto)\\b/i.test(message)) {\r\n        return {\r\n            primary: 'confirmation' as Intent,\r\n            confidence: 0.85,\r\n            sentiment: { polarity: 'positive', score: 0.6 },\r\n            entities: {}\r\n        }\r\n    }\r\n\r\n    // Default: pregunta general\r\n    return {\r\n        primary: 'general_question' as Intent,\r\n        confidence: 0.5,\r\n        sentiment,\r\n        entities: extractEntities(message)\r\n    }\r\n}\r\n\r\n/**\r\n * Detecci√≥n de intenci√≥n usando LLM (m√°s preciso pero m√°s lento)\r\n */\r\nasync function detectIntentByLLM(\r\n    message: string,\r\n    config: AccountConfig,\r\n    conversationHistory: Message[]\r\n): Promise<IntentDetectionResult> {\r\n    const openrouterKey = Deno.env.get('OPENROUTER_API_KEY')\r\n    if (!openrouterKey) {\r\n        console.warn(`‚ö†Ô∏è [INTENT] OPENROUTER_API_KEY not found, falling back to rule-based`)\r\n        return detectIntentByRules(message, config)\r\n    }\r\n\r\n    const prompt = `Analiza el siguiente mensaje y determina la intenci√≥n principal del usuario.\r\n\r\nMensaje: \"${message}\"\r\n\r\nContexto de negocio:\r\n- Tipo: ${config.businessType}\r\n- Tiene productos: ${config.hasProducts}\r\n- Tiene servicios: ${config.hasServices}\r\n- Tiene citas: ${config.appointmentsEnabled}\r\n- Tiene cotizaciones: ${config.quotesEnabled}\r\n\r\nResponde SOLO con un JSON en este formato:\r\n{\r\n  \"intent\": \"greeting|farewell|product_inquiry|service_inquiry|appointment_request|quote_request|complaint|urgent_issue|cancellation|confirmation|general_question|unknown\",\r\n  \"confidence\": 0.0-1.0,\r\n  \"sentiment\": \"positive|neutral|negative\",\r\n  \"entities\": {\r\n    \"products\": [\"producto1\", \"producto2\"],\r\n    \"dates\": [\"2026-02-10\"],\r\n    \"prices\": [100, 200]\r\n  }\r\n}`\r\n\r\n    try {\r\n        const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {\r\n            method: 'POST',\r\n            headers: {\r\n                'Authorization': `Bearer ${openrouterKey}`,\r\n                'HTTP-Referer': 'https://elina.ai',\r\n                'X-Title': 'ELINA V5 Intent Detection',\r\n                'Content-Type': 'application/json'\r\n            },\r\n            body: JSON.stringify({\r\n                model: 'openai/gpt-4o-mini', // M√°s barato para detecci√≥n de intenci√≥n\r\n                messages: [{ role: 'user', content: prompt }],\r\n                temperature: 0.3,\r\n                max_tokens: 200\r\n            })\r\n        })\r\n\r\n        if (!response.ok) {\r\n            throw new Error(`OpenRouter API error: ${response.statusText}`)\r\n        }\r\n\r\n        const data = await response.json()\r\n        const content = data.choices[0].message.content\r\n\r\n        // Extraer JSON de la respuesta\r\n        const jsonMatch = content.match(/\\{[\\s\\S]*\\}/)\r\n        if (!jsonMatch) {\r\n            throw new Error('No JSON found in LLM response')\r\n        }\r\n\r\n        const result = JSON.parse(jsonMatch[0])\r\n\r\n        return {\r\n            primary: result.intent as Intent,\r\n            confidence: result.confidence || 0.7,\r\n            sentiment: {\r\n                polarity: result.sentiment || 'neutral',\r\n                score: result.sentiment === 'positive' ? 0.6 : result.sentiment === 'negative' ? -0.6 : 0\r\n            },\r\n            entities: result.entities || {}\r\n        }\r\n    } catch (error) {\r\n        console.error(`‚ùå [INTENT] LLM detection failed: ${error.message}`)\r\n        return detectIntentByRules(message, config)\r\n    }\r\n}\r\n\r\n/**\r\n * Analiza el sentimiento del mensaje\r\n */\r\nexport function analyzeSentiment(message: string): SentimentAnalysis {\r\n    const lowerMessage = message.toLowerCase()\r\n\r\n    // Palabras positivas\r\n    const positiveWords = ['excelente', 'genial', 'perfecto', 'gracias', 'bueno', 'bien', 'feliz', 'contento', 'encantado', 'maravilloso']\r\n    const positiveCount = positiveWords.filter(word => lowerMessage.includes(word)).length\r\n\r\n    // Palabras negativas\r\n    const negativeWords = ['mal', 'p√©simo', 'horrible', 'terrible', 'molesto', 'enojado', 'decepcionado', 'problema', 'queja', 'reclamo']\r\n    const negativeCount = negativeWords.filter(word => lowerMessage.includes(word)).length\r\n\r\n    // Calcular polaridad\r\n    if (positiveCount > negativeCount) {\r\n        return {\r\n            polarity: 'positive',\r\n            score: Math.min(0.8, 0.3 + (positiveCount * 0.2))\r\n        }\r\n    } else if (negativeCount > positiveCount) {\r\n        return {\r\n            polarity: 'negative',\r\n            score: Math.max(-0.8, -0.3 - (negativeCount * 0.2))\r\n        }\r\n    }\r\n\r\n    return {\r\n        polarity: 'neutral',\r\n        score: 0\r\n    }\r\n}\r\n\r\n/**\r\n * Extrae entidades del mensaje (productos, fechas, precios, etc.)\r\n */\r\nfunction extractEntities(message: string): {\r\n    products?: string[]\r\n    services?: string[]\r\n    dates?: string[]\r\n    prices?: number[]\r\n    phoneNumbers?: string[]\r\n} {\r\n    const entities: any = {}\r\n\r\n    // Extraer precios (ej: $100, 100 pesos, $1,000.00)\r\n    const priceRegex = /\\$?\\d{1,3}(?:,\\d{3})*(?:\\.\\d{2})?(?:\\s*(?:pesos|mxn|usd|d√≥lares))?/gi\r\n    const prices = message.match(priceRegex)\r\n    if (prices) {\r\n        entities.prices = prices.map(p => parseFloat(p.replace(/[$,]/g, '')))\r\n    }\r\n\r\n    // Extraer fechas (ej: 10/02/2026, 10 de febrero, ma√±ana)\r\n    const dateKeywords = ['ma√±ana', 'hoy', 'pasado ma√±ana', 'lunes', 'martes', 'mi√©rcoles', 'jueves', 'viernes', 's√°bado', 'domingo']\r\n    const foundDates = dateKeywords.filter(keyword => message.toLowerCase().includes(keyword))\r\n    if (foundDates.length > 0) {\r\n        entities.dates = foundDates\r\n    }\r\n\r\n    // Extraer n√∫meros de tel√©fono (ej: 5512345678, +52 55 1234 5678)\r\n    const phoneRegex = /(?:\\+?52\\s?)?(?:\\d{2,3}\\s?)?\\d{4}\\s?\\d{4}/g\r\n    const phones = message.match(phoneRegex)\r\n    if (phones) {\r\n        entities.phoneNumbers = phones\r\n    }\r\n\r\n    return entities\r\n}\r\n\r\n/**\r\n * Verifica si la intenci√≥n es cr√≠tica y requiere atenci√≥n humana\r\n */\r\nexport function isCriticalIntent(intent: Intent): boolean {\r\n    const criticalIntents: Intent[] = [\r\n        'complaint' as Intent,\r\n        'urgent_issue' as Intent,\r\n        'cancellation' as Intent,\r\n        'refund_request' as Intent\r\n    ]\r\n\r\n    return criticalIntents.includes(intent)\r\n}\r\n"},{"name":"memory/long-term.ts","content":"/**\r\n * ELINA V5 - Long-term Memory System\r\n * \r\n * Sistema de aprendizaje de largo plazo por cuenta\r\n */\r\n\r\nimport type { SupabaseClient } from 'https://esm.sh/@supabase/supabase-js@2'\r\nimport type { AccountLearning } from '../config/types.ts'\r\nimport { LEARNING_CONFIDENCE_THRESHOLD, RAG_MAX_RESULTS } from '../config/constants.ts'\r\n\r\n/**\r\n * Genera embedding para un texto usando OpenAI\r\n */\r\nasync function generateEmbedding(text: string): Promise<number[]> {\r\n    const openaiKey = Deno.env.get('OPENAI_API_KEY')\r\n    if (!openaiKey) {\r\n        throw new Error('OPENAI_API_KEY not found')\r\n    }\r\n\r\n    const response = await fetch('https://api.openai.com/v1/embeddings', {\r\n        method: 'POST',\r\n        headers: {\r\n            'Authorization': `Bearer ${openaiKey}`,\r\n            'Content-Type': 'application/json'\r\n        },\r\n        body: JSON.stringify({\r\n            model: 'text-embedding-3-small',\r\n            input: text\r\n        })\r\n    })\r\n\r\n    if (!response.ok) {\r\n        throw new Error(`OpenAI API error: ${response.statusText}`)\r\n    }\r\n\r\n    const data = await response.json()\r\n    return data.data[0].embedding\r\n}\r\n\r\n/**\r\n * Obtiene aprendizajes relevantes basados en el mensaje actual\r\n */\r\nexport async function getRelevantLearnings(\r\n    supabase: SupabaseClient,\r\n    userId: string,\r\n    currentMessage: string,\r\n    limit: number = RAG_MAX_RESULTS\r\n): Promise<AccountLearning[]> {\r\n    console.log(`üß† [MEMORY] Fetching relevant learnings for user ${userId}`)\r\n\r\n    try {\r\n        // 1. Generar embedding del mensaje actual\r\n        const embedding = await generateEmbedding(currentMessage)\r\n\r\n        // 2. Buscar aprendizajes similares\r\n        const { data, error } = await supabase.rpc('match_account_learnings', {\r\n            query_embedding: embedding,\r\n            match_threshold: LEARNING_CONFIDENCE_THRESHOLD,\r\n            match_count: limit,\r\n            filter_user_id: userId\r\n        })\r\n\r\n        if (error) {\r\n            console.error(`‚ùå [MEMORY] Error fetching learnings: ${error.message}`)\r\n            return []\r\n        }\r\n\r\n        const learnings = (data || []) as AccountLearning[]\r\n        console.log(`‚úÖ [MEMORY] Found ${learnings.length} relevant learnings`)\r\n\r\n        // 3. Actualizar usage_count y last_used\r\n        if (learnings.length > 0) {\r\n            await Promise.all(\r\n                learnings.map(learning =>\r\n                    supabase\r\n                        .from('account_learnings')\r\n                        .update({\r\n                            usage_count: (learning.usageCount || 0) + 1,\r\n                            last_used: new Date().toISOString()\r\n                        })\r\n                        .eq('id', learning.id)\r\n                )\r\n            )\r\n        }\r\n\r\n        return learnings\r\n    } catch (error) {\r\n        console.error(`‚ùå [MEMORY] Error in getRelevantLearnings: ${error.message}`)\r\n        return []\r\n    }\r\n}\r\n\r\n/**\r\n * Guarda un nuevo aprendizaje\r\n */\r\nexport async function saveLearning(\r\n    supabase: SupabaseClient,\r\n    userId: string,\r\n    learningType: 'pattern' | 'objection' | 'product_insight' | 'best_practice',\r\n    content: string,\r\n    confidence: number = 0.5\r\n): Promise<void> {\r\n    console.log(`üíæ [MEMORY] Saving new learning: ${learningType}`)\r\n\r\n    try {\r\n        // 1. Generar embedding\r\n        const embedding = await generateEmbedding(content)\r\n\r\n        // 2. Guardar en base de datos\r\n        const { error } = await supabase.from('account_learnings').insert({\r\n            user_id: userId,\r\n            learning_type: learningType,\r\n            content,\r\n            confidence,\r\n            embedding,\r\n            usage_count: 0,\r\n            created_at: new Date().toISOString(),\r\n            updated_at: new Date().toISOString()\r\n        })\r\n\r\n        if (error) {\r\n            console.error(`‚ùå [MEMORY] Error saving learning: ${error.message}`)\r\n            throw error\r\n        }\r\n\r\n        console.log(`‚úÖ [MEMORY] Learning saved successfully`)\r\n    } catch (error) {\r\n        console.error(`‚ùå [MEMORY] Error in saveLearning: ${error.message}`)\r\n        throw error\r\n    }\r\n}\r\n\r\n/**\r\n * Actualiza la confianza de un aprendizaje\r\n */\r\nexport async function updateLearningConfidence(\r\n    supabase: SupabaseClient,\r\n    learningId: string,\r\n    newConfidence: number\r\n): Promise<void> {\r\n    const { error } = await supabase\r\n        .from('account_learnings')\r\n        .update({\r\n            confidence: Math.max(0, Math.min(1, newConfidence)), // Clamp between 0 and 1\r\n            updated_at: new Date().toISOString()\r\n        })\r\n        .eq('id', learningId)\r\n\r\n    if (error) {\r\n        console.error(`‚ùå [MEMORY] Error updating learning confidence: ${error.message}`)\r\n        throw error\r\n    }\r\n}\r\n\r\n/**\r\n * Elimina aprendizajes con baja confianza y poco uso\r\n */\r\nexport async function cleanupOldLearnings(\r\n    supabase: SupabaseClient,\r\n    userId: string,\r\n    minConfidence: number = 0.3,\r\n    minUsageCount: number = 1,\r\n    daysOld: number = 90\r\n): Promise<number> {\r\n    console.log(`üßπ [MEMORY] Cleaning up old learnings for user ${userId}`)\r\n\r\n    const cutoffDate = new Date()\r\n    cutoffDate.setDate(cutoffDate.getDate() - daysOld)\r\n\r\n    const { data, error } = await supabase\r\n        .from('account_learnings')\r\n        .delete()\r\n        .eq('user_id', userId)\r\n        .lt('confidence', minConfidence)\r\n        .lt('usage_count', minUsageCount)\r\n        .lt('created_at', cutoffDate.toISOString())\r\n        .select('id')\r\n\r\n    if (error) {\r\n        console.error(`‚ùå [MEMORY] Error cleaning up learnings: ${error.message}`)\r\n        return 0\r\n    }\r\n\r\n    const deletedCount = data?.length || 0\r\n    console.log(`‚úÖ [MEMORY] Cleaned up ${deletedCount} old learnings`)\r\n\r\n    return deletedCount\r\n}\r\n\r\n/**\r\n * Formatea aprendizajes para incluir en el prompt\r\n */\r\nexport function formatLearningsForPrompt(learnings: AccountLearning[]): string {\r\n    if (learnings.length === 0) {\r\n        return ''\r\n    }\r\n\r\n    let formatted = '## Aprendizajes Previos\\n'\r\n    formatted += 'Estos son patrones y mejores pr√°cticas que has aprendido con el tiempo:\\n\\n'\r\n\r\n    for (const learning of learnings) {\r\n        const emoji = {\r\n            pattern: 'üîÑ',\r\n            objection: 'üõ°Ô∏è',\r\n            product_insight: 'üí°',\r\n            best_practice: '‚≠ê'\r\n        }[learning.learningType] || 'üìù'\r\n\r\n        formatted += `${emoji} **${learning.learningType}**: ${learning.content}\\n`\r\n    }\r\n\r\n    return formatted\r\n}\r\n"},{"name":"utils/appointment-manager.ts","content":"// Appointment Management System for ELINA V5\r\n// Handles appointment scheduling, slot management, and reminders\r\n\r\nimport { SupabaseClient } from 'https://esm.sh/@supabase/supabase-js@2'\r\n\r\nexport interface AppointmentSettings {\r\n    is_enabled: boolean\r\n    buffer_minutes: number\r\n    max_days_ahead: number\r\n    working_hours?: any\r\n}\r\n\r\nexport interface AppointmentSlot {\r\n    start_time: string\r\n    end_time: string\r\n    service_id: number\r\n    service_name: string\r\n    duration_minutes: number\r\n}\r\n\r\nexport interface CreateAppointmentParams {\r\n    userId: string\r\n    contactId: number\r\n    serviceId: number\r\n    startTime: string\r\n    notes?: string\r\n}\r\n\r\nexport interface AppointmentResult {\r\n    success: boolean\r\n    appointmentId?: number\r\n    serviceName?: string\r\n    startTime?: string\r\n    error?: string\r\n}\r\n\r\n/**\r\n * Gets appointment settings for a user\r\n */\r\nexport async function getAppointmentSettings(\r\n    supabase: SupabaseClient,\r\n    userId: string\r\n): Promise<AppointmentSettings | null> {\r\n    try {\r\n        const { data, error } = await supabase\r\n            .from('appointment_settings')\r\n            .select('*')\r\n            .eq('user_id', userId)\r\n            .single()\r\n\r\n        if (error) {\r\n            console.error(`‚ùå [APPOINTMENT] Error fetching settings:`, error)\r\n            return null\r\n        }\r\n\r\n        return data as AppointmentSettings\r\n    } catch (error) {\r\n        console.error(`‚ùå [APPOINTMENT] Error:`, error)\r\n        return null\r\n    }\r\n}\r\n\r\n/**\r\n * Gets available appointment slots\r\n */\r\nexport async function getAvailableSlots(\r\n    userId: string,\r\n    daysAhead: number = 7\r\n): Promise<AppointmentSlot[]> {\r\n    try {\r\n        console.log(`üìÖ [APPOINTMENT] Fetching slots for next ${daysAhead} days...`)\r\n        const allSlots: AppointmentSlot[] = []\r\n        const slotsUrl = `${Deno.env.get('SUPABASE_URL')}/functions/v1/get-available-slots`\r\n        const anonKey = Deno.env.get('SUPABASE_ANON_KEY')\r\n\r\n        // Generate dates for the next N days\r\n        const dates: string[] = []\r\n        const today = new Date()\r\n\r\n        for (let i = 0; i < daysAhead; i++) {\r\n            const date = new Date(today)\r\n            date.setDate(today.getDate() + i)\r\n            dates.push(date.toISOString().split('T')[0])\r\n        }\r\n\r\n        // Fetch slots for each date in parallel (limited for performance)\r\n        const fetchPromises = dates.map(async (date) => {\r\n            try {\r\n                const response = await fetch(slotsUrl, {\r\n                    method: 'POST',\r\n                    headers: {\r\n                        'Authorization': `Bearer ${anonKey}`,\r\n                        'Content-Type': 'application/json'\r\n                    },\r\n                    body: JSON.stringify({\r\n                        user_id: userId,\r\n                        date: date\r\n                    })\r\n                })\r\n\r\n                if (!response.ok) {\r\n                    console.warn(`‚ö†Ô∏è [APPOINTMENT] Failed to fetch slots for ${date}: ${response.status}`)\r\n                    return []\r\n                }\r\n\r\n                const data = await response.json()\r\n\r\n                if (data.available_slots && Array.isArray(data.available_slots)) {\r\n                    // Map response format to AppointmentSlot format\r\n                    return data.available_slots.map((s: any) => ({\r\n                        start_time: `${date}T${s.start}:00`, // Ensure valid ISO format if strictly time\r\n                        end_time: `${date}T${s.end}:00`,\r\n                        service_id: 0, // Default or generic\r\n                        service_name: 'Cita General', // Default\r\n                        duration_minutes: s.duration_minutes || 60\r\n                    }))\r\n                }\r\n\r\n                return []\r\n            } catch (err) {\r\n                console.error(`‚ùå [APPOINTMENT] Error fetching date ${date}:`, err)\r\n                return []\r\n            }\r\n        })\r\n\r\n        const results = await Promise.all(fetchPromises)\r\n\r\n        // Flatten results\r\n        results.forEach(slots => {\r\n            allSlots.push(...slots)\r\n        })\r\n\r\n        return allSlots\r\n\r\n    } catch (error) {\r\n        console.error(`‚ùå [APPOINTMENT] Error fetching slots:`, error)\r\n        return []\r\n    }\r\n}\r\n\r\n/**\r\n * Formats appointment slots for AI context\r\n */\r\n/**\r\n * Formats appointment slots for AI context\r\n */\r\nexport function formatAppointmentContext(slots: AppointmentSlot[], slug?: string): string {\r\n    if (!slots || slots.length === 0) {\r\n        let noSlotsMsg = '[CITAS] No hay horarios disponibles en los pr√≥ximos d√≠as.'\r\n        if (slug) {\r\n            noSlotsMsg += `\\nPuedes revisar disponibilidad completa aqu√≠: [APPOINTMENT_CALENDAR_LINK]`\r\n        }\r\n        return noSlotsMsg\r\n    }\r\n\r\n    let context = 'üìÖ [HORARIOS DISPONIBLES PARA CITAS]\\n\\n'\r\n\r\n    // Agrupar por d√≠a\r\n    const slotsByDay: Record<string, AppointmentSlot[]> = {}\r\n\r\n    for (const slot of slots) {\r\n        const date = new Date(slot.start_time)\r\n        const dayKey = date.toLocaleDateString('es-MX', {\r\n            weekday: 'long',\r\n            day: 'numeric',\r\n            month: 'long'\r\n        })\r\n\r\n        // Capitalizar primer letra\r\n        const formattedDayKey = dayKey.charAt(0).toUpperCase() + dayKey.slice(1)\r\n\r\n        if (!slotsByDay[formattedDayKey]) {\r\n            slotsByDay[formattedDayKey] = []\r\n        }\r\n        slotsByDay[formattedDayKey].push(slot)\r\n    }\r\n\r\n    // Formatear por d√≠a con rangos\r\n    const dayEntries = Object.entries(slotsByDay)\r\n    // Limitar a los primeros 3 d√≠as para no saturar contexto\r\n    const daysToShow = dayEntries.slice(0, 3)\r\n\r\n    for (const [day, daySlots] of daysToShow) {\r\n        context += `üìÜ ${day}:\\n`\r\n\r\n        // Ordenar slots por hora\r\n        daySlots.sort((a, b) => new Date(a.start_time).getTime() - new Date(b.start_time).getTime())\r\n\r\n        if (daySlots.length === 0) continue\r\n\r\n        // Encontrar primer y √∫ltimo slot del d√≠a\r\n        const firstSlot = daySlots[0]\r\n        const lastSlot = daySlots[daySlots.length - 1]\r\n\r\n        const startTime = new Date(firstSlot.start_time).toLocaleTimeString('es-MX', {\r\n            hour: '2-digit', minute: '2-digit', hour12: true\r\n        })\r\n\r\n        const endTime = new Date(lastSlot.start_time).toLocaleTimeString('es-MX', {\r\n            hour: '2-digit', minute: '2-digit', hour12: true\r\n        })\r\n\r\n        if (daySlots.length === 1) {\r\n            context += `   ‚Ä¢ A las ${startTime}\\n`\r\n        } else {\r\n            context += `   ‚Ä¢ Entre las ${startTime} y las ${endTime}\\n`\r\n        }\r\n\r\n        context += '\\n'\r\n    }\r\n\r\n    if (slug) {\r\n        context += `üîó Puedes ver el calendario completo y agendar aqu√≠:\\n[APPOINTMENT_CALENDAR_LINK]\\n\\n`\r\n    }\r\n\r\n    context += 'üìå INSTRUCCI√ìN IMPORTANTE:\\n'\r\n    context += 'Ofrece los horarios como RANGOS (ej: \"tengo espacio entre las 10 y las 12\").\\n'\r\n    context += 'Si el usuario pide una hora espec√≠fica dentro del rango, verifica si est√° disponible o agenda al horario m√°s cercano.\\n'\r\n    context += 'SIEMPRE incluye el enlace al calendario completo al final.\\n'\r\n\r\n    return context\r\n}\r\n\r\n/**\r\n * Creates an appointment and automatic reminders\r\n */\r\nexport async function createAppointment(\r\n    supabase: SupabaseClient,\r\n    params: CreateAppointmentParams,\r\n    sendMessage: (remoteJid: string, text: string) => Promise<void>,\r\n    contactPhone: string\r\n): Promise<AppointmentResult> {\r\n    try {\r\n        console.log(`\\nüìÖ [APPOINTMENT] Creating appointment...`)\r\n        console.log(`   User: ${params.userId}`)\r\n        console.log(`   Contact: ${params.contactId}`)\r\n        console.log(`   Service: ${params.serviceId}`)\r\n        console.log(`   Time: ${params.startTime}`)\r\n\r\n        // ========================================================================\r\n        // 1. GET SERVICE INFO (duration + name)\r\n        // ========================================================================\r\n        const { data: serviceData } = await supabase\r\n            .from('products')\r\n            .select('service_duration_minutes, product_name')\r\n            .eq('id', params.serviceId)\r\n            .single()\r\n\r\n        const durationMinutes = serviceData?.service_duration_minutes || 60 // Default 60 min\r\n        const serviceName = serviceData?.product_name || 'Servicio'\r\n\r\n        // Calculate end_time\r\n        const startTime = new Date(params.startTime)\r\n        const endTime = new Date(startTime.getTime() + durationMinutes * 60 * 1000)\r\n\r\n        console.log(`‚è±Ô∏è [APPOINTMENT] Service: ${serviceName}`)\r\n        console.log(`   Duration: ${durationMinutes} minutes`)\r\n        console.log(`   Start: ${params.startTime}`)\r\n        console.log(`   End: ${endTime.toISOString()}`)\r\n\r\n        // ========================================================================\r\n        // 2. CREATE APPOINTMENT (with AI metadata)\r\n        // ========================================================================\r\n        const { data: appointment, error: createError } = await supabase\r\n            .from('meetings')\r\n            .insert({\r\n                user_id: params.userId,\r\n                contact_id: params.contactId,\r\n                product_id: params.serviceId,\r\n                start_time: params.startTime,\r\n                end_time: endTime.toISOString(),\r\n                status: 'confirmed',\r\n                summary: 'Cita Agendada por IA',  // AI marker\r\n                notes: params.notes ? `${params.notes} (Agendado autom√°ticamente: ${serviceName})` : `Agendado autom√°ticamente: ${serviceName}`,\r\n                confirmation_status: 'confirmed'\r\n            })\r\n            .select()\r\n            .single()\r\n\r\n        if (createError) {\r\n            console.error(`‚ùå [APPOINTMENT] Creation failed:`, createError)\r\n            throw createError\r\n        }\r\n\r\n        console.log(`‚úÖ [APPOINTMENT] Created appointment #${appointment.id}`)\r\n\r\n        // ========================================================================\r\n        // 2. CREATE AUTOMATIC REMINDERS\r\n        // ========================================================================\r\n        const appointmentTime = new Date(params.startTime)\r\n        const now = new Date()\r\n\r\n        // Recordatorio 24h antes (solo si la cita es en m√°s de 24h)\r\n        const twentyFourHoursBefore = new Date(appointmentTime.getTime() - 24 * 60 * 60 * 1000)\r\n        if (twentyFourHoursBefore > now) {\r\n            await supabase.from('appointment_reminders').insert({\r\n                meeting_id: appointment.id,\r\n                reminder_time: twentyFourHoursBefore.toISOString(),\r\n                reminder_type: '24h_before',\r\n                status: 'pending'\r\n            })\r\n            console.log(`‚úÖ [APPOINTMENT] 24h reminder scheduled`)\r\n        }\r\n\r\n        // Recordatorio 2h antes (solo si la cita es en m√°s de 2h)\r\n        const twoHoursBefore = new Date(appointmentTime.getTime() - 2 * 60 * 60 * 1000)\r\n        if (twoHoursBefore > now) {\r\n            await supabase.from('appointment_reminders').insert({\r\n                meeting_id: appointment.id,\r\n                reminder_time: twoHoursBefore.toISOString(),\r\n                reminder_type: '2h_before',\r\n                status: 'pending'\r\n            })\r\n            console.log(`‚úÖ [APPOINTMENT] 2h reminder scheduled`)\r\n        }\r\n\r\n        // ========================================================================\r\n        // 3. SEND CONFIRMATION TO CUSTOMER\r\n        // ========================================================================\r\n        const confirmationMsg =\r\n            `‚úÖ *Cita Confirmada*\\n\\n` +\r\n            `üìÖ Fecha: ${appointmentTime.toLocaleDateString('es-MX', { weekday: 'long', day: 'numeric', month: 'long', year: 'numeric' })}\\n` +\r\n            `üïê Hora: ${appointmentTime.toLocaleTimeString('es-MX', { hour: '2-digit', minute: '2-digit', hour12: true })}\\n` +\r\n            `üîπ Servicio: ${serviceName}\\n` +\r\n            `‚è±Ô∏è Duraci√≥n: ${durationMinutes} minutos\\n\\n` +\r\n            `Recibir√°s recordatorios antes de tu cita.\\n` +\r\n            `ID de cita: #${appointment.id}`\r\n\r\n        await sendMessage(contactPhone + '@s.whatsapp.net', confirmationMsg)\r\n        console.log(`‚úÖ [APPOINTMENT] Confirmation sent to customer`)\r\n\r\n        // ========================================================================\r\n        // 4. NOTIFY OWNER (OPTIONAL)\r\n        // ========================================================================\r\n        const { data: profile } = await supabase\r\n            .from('profiles')\r\n            .select('contact_phone')\r\n            .eq('id', params.userId)\r\n            .single()\r\n\r\n        if (profile?.contact_phone) {\r\n            const { data: contact } = await supabase\r\n                .from('contacts')\r\n                .select('full_name, phone_number')\r\n                .eq('id', params.contactId)\r\n                .single()\r\n\r\n            const ownerNotification =\r\n                `üìÖ *Nueva Cita Agendada*\\n\\n` +\r\n                `Cliente: ${contact?.full_name || contact?.phone_number}\\n` +\r\n                `Servicio: ${serviceName}\\n` +\r\n                `Fecha: ${appointmentTime.toLocaleDateString('es-MX', { day: 'numeric', month: 'long' })}\\n` +\r\n                `Hora: ${appointmentTime.toLocaleTimeString('es-MX', { hour: '2-digit', minute: '2-digit' })}\\n` +\r\n                `ID: #${appointment.id}`\r\n\r\n            await sendMessage(profile.contact_phone + '@s.whatsapp.net', ownerNotification)\r\n            console.log(`‚úÖ [APPOINTMENT] Owner notified`)\r\n        }\r\n\r\n        return {\r\n            success: true,\r\n            appointmentId: appointment.id,\r\n            serviceName: serviceName,  // Use the serviceName we fetched earlier\r\n            startTime: params.startTime\r\n        }\r\n\r\n    } catch (error) {\r\n        console.error(`‚ùå [APPOINTMENT] Error creating appointment:`, error)\r\n        return {\r\n            success: false,\r\n            error: error instanceof Error ? error.message : 'Unknown error'\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Detects if the message contains an appointment request\r\n */\r\nexport function detectAppointmentIntent(text: string, context?: any): boolean {\r\n    const lowerText = text.toLowerCase().trim()\r\n\r\n    // 1. Palabras clave expl√≠citas de cita\r\n    const appointmentKeywords = /(?:cita|agendar|reservar|horario|turno|disponibilidad|agenda|appointment|schedule|book)/i\r\n    if (appointmentKeywords.test(lowerText)) return true\r\n\r\n    // 2. Si ya estamos hablando de citas (contexto activo), palabras de confirmaci√≥n o fechas cuentan como intent\r\n    if (context?.appointmentContext || context?.lastIntent === 'appointment_request') {\r\n        const confirmationKeywords = /^(si|ok|va|dale|acepto|confirmo|claro|por favor|hazlo|que si|seguro)$/i\r\n        const timeKeywords = /(ma√±ana|hoy|lunes|martes|miercoles|jueves|viernes|sabado|domingo|enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|alas|a las)/i\r\n\r\n        if (confirmationKeywords.test(lowerText) || timeKeywords.test(lowerText)) {\r\n            return true\r\n        }\r\n\r\n        // Si menciona un servicio y estamos en contexto de cita\r\n        if (text.length < 50 && (lowerText.includes('corte') || lowerText.includes('color') || lowerText.includes('peinado'))) {\r\n            return true\r\n        }\r\n    }\r\n\r\n    return false\r\n}\r\n"},{"name":"utils/automation.ts","content":"\r\nimport { AccountConfig, AutoResponse } from '../config/types.ts'\r\n\r\n/**\r\n * Verifica si el mensaje coincide con alguna regla de autorespuesta\r\n */\r\nexport function checkAutoResponses(messageText: string, config: AccountConfig): AutoResponse | null {\r\n    if (!config.autoResponses || config.autoResponses.length === 0) return null\r\n\r\n    const lowerMessage = messageText.toLowerCase()\r\n\r\n    // Sort by specific criteria if needed (e.g. exact match first)\r\n    // For now, iterate in order\r\n    for (const rule of config.autoResponses) {\r\n        if (!rule.isActive) continue\r\n\r\n        const trigger = (rule.triggerText || '').toLowerCase()\r\n        const matchType = rule.matchType || 'contains'\r\n\r\n        let isMatch = false\r\n\r\n        if (matchType === 'exact') {\r\n            isMatch = lowerMessage === trigger\r\n        } else {\r\n            // contains\r\n            isMatch = lowerMessage.includes(trigger)\r\n        }\r\n\r\n        if (isMatch) {\r\n            console.log(`‚úÖ [AUTOMATION] Auto-response triggered: ${rule.id} (${trigger})`)\r\n            return rule\r\n        }\r\n    }\r\n\r\n    return null\r\n}\r\n"},{"name":"utils/context-filter.ts","content":"/**\r\n * ELINA V5 - Context Filter\r\n * \r\n * Filtra mensajes antiguos para evitar alucinaciones con precios/citas viejas\r\n */\r\n\r\nimport type { Message } from '../config/types.ts'\r\n\r\n/**\r\n * Detecta si el mensaje actual es una nueva solicitud transaccional\r\n * (precio, cita, info) que deber√≠a invalidar el contexto anterior.\r\n */\r\nexport function isNewTransactionalRequest(message: string, history: Message[]): boolean {\r\n    const text = message.toLowerCase()\r\n\r\n    // Palabras clave de intenci√≥n transaccional\r\n    const transactionalKeywords = [\r\n        'precio', 'costo', 'cuesta', 'cuanto', 'cu√°nto',\r\n        'cita', 'agenda', 'reservar', 'disponible', 'horario',\r\n        'info', 'informaci√≥n', 'detalles'\r\n    ]\r\n\r\n    const hasKeyword = transactionalKeywords.some(kw => text.includes(kw))\r\n\r\n    // Si no hay historial reciente, es una nueva solicitud\r\n    if (history.length === 0) return true\r\n\r\n    // Si pasaron m√°s de 2 horas desde el √∫ltimo mensaje, es nueva sesi√≥n\r\n    const lastMsgTime = new Date(history[0].timestamp).getTime()\r\n    const now = Date.now()\r\n    const isSessionExpired = (now - lastMsgTime) > (2 * 60 * 60 * 1000)\r\n\r\n    return hasKeyword || isSessionExpired\r\n}\r\n\r\n/**\r\n * Filtra el contexto hist√≥rico para eliminar \"ruido\" transaccional viejo\r\n */\r\nexport function filterTransactionalContext(history: Message[], isNewRequest: boolean): Message[] {\r\n    if (!isNewRequest) return history\r\n\r\n    // Si es una nueva solicitud, filtramos mensajes viejos que contienen precios o citas\r\n    // para que el bot no se confunda con datos antiguos.\r\n    return history.filter(msg => {\r\n        const text = msg.content.toLowerCase()\r\n        const isOldQuote = text.includes('subtotal:') || text.includes('total:') || text.includes('$')\r\n        const isOldAppointment = text.includes('cita confirmada') || text.includes('reserva')\r\n\r\n        // Mantenemos solo mensajes conversacionales, no transaccionales viejos\r\n        return !isOldQuote && !isOldAppointment\r\n    })\r\n}\r\n"},{"name":"utils/context.ts","content":"/**\r\n * ELINA V5 - Context Loader\r\n * \r\n * Carga todo el contexto necesario para la conversaci√≥n\r\n */\r\n\r\nimport type { SupabaseClient } from 'https://esm.sh/@supabase/supabase-js@2'\r\nimport type { AccountConfig, ConversationContext, Message, Contact, Product } from '../config/types.ts'\r\nimport { getRelevantLearnings } from '../memory/long-term.ts'\r\n\r\n/**\r\n * Obtiene el perfil por nombre de instancia\r\n */\r\nexport async function getProfileByInstance(\r\n    supabase: SupabaseClient,\r\n    instanceName: string\r\n) {\r\n    const { data, error } = await supabase\r\n        .from('profiles')\r\n        .select('*')\r\n        .eq('evolution_instance_name', instanceName)\r\n        .single()\r\n\r\n    if (error || !data) {\r\n        throw new Error(`Profile not found for instance: ${instanceName}`)\r\n    }\r\n\r\n    return data\r\n}\r\n\r\n/**\r\n * Asegura que el contacto existe en la base de datos\r\n */\r\nexport async function ensureContact(\r\n    supabase: SupabaseClient,\r\n    userId: string,\r\n    phoneNumber: string,\r\n    fullName?: string\r\n): Promise<Contact> {\r\n    // Buscar contacto existente\r\n    const { data: existing, error: searchError } = await supabase\r\n        .from('contacts')\r\n        .select('*')\r\n        .eq('user_id', userId)\r\n        .eq('phone_number', phoneNumber)\r\n        .maybeSingle()\r\n\r\n    if (existing) {\r\n        return existing as Contact\r\n    }\r\n\r\n    // Crear nuevo contacto\r\n    const { data: newContact, error: insertError } = await supabase\r\n        .from('contacts')\r\n        .insert({\r\n            user_id: userId,\r\n            phone_number: phoneNumber,\r\n            full_name: fullName || phoneNumber,\r\n            labels: [],\r\n            created_at: new Date().toISOString()\r\n        })\r\n        .select()\r\n        .single()\r\n\r\n    if (insertError || !newContact) {\r\n        throw new Error(`Failed to create contact: ${insertError?.message}`)\r\n    }\r\n\r\n    return newContact as Contact\r\n}\r\n\r\n/**\r\n * Obtiene el historial de chat reciente\r\n * \r\n * IMPORTANTE: Filtra datos transaccionales antiguos (> 30 min)\r\n * para evitar asumir cantidades/precios de cotizaciones pasadas\r\n */\r\nexport async function getChatHistory(\r\n    supabase: SupabaseClient,\r\n    userId: string,\r\n    contactId: number,\r\n    limit: number = 10\r\n): Promise<Message[]> {\r\n    // Calcular timestamp de hace 30 minutos\r\n    const thirtyMinutesAgo = new Date(Date.now() - 30 * 60 * 1000).toISOString();\r\n\r\n    const { data, error } = await supabase\r\n        .from('chat_history')\r\n        .select('message_type, content, created_at')\r\n        .eq('user_id', userId)\r\n        .eq('contact_id', contactId)\r\n        .gte('created_at', thirtyMinutesAgo) // FILTRO TEMPORAL: solo √∫ltimos 30 min\r\n        .order('created_at', { ascending: false })\r\n        .limit(limit)\r\n\r\n    if (error) {\r\n        console.error(`‚ùå [CONTEXT] Error fetching chat history: ${error.message}`)\r\n        return []\r\n    }\r\n\r\n    const messageCount = data?.length || 0;\r\n    console.log(`üìö [CONTEXT] Loaded ${messageCount} messages from last 30 minutes`);\r\n\r\n    // Convertir a formato Message y revertir orden (m√°s antiguo primero)\r\n    return (data || [])\r\n        .reverse()\r\n        .map(msg => ({\r\n            role: msg.message_type === 'user' ? 'user' : 'assistant',\r\n            content: msg.content,\r\n            timestamp: new Date(msg.created_at)\r\n        })) as Message[]\r\n}\r\n\r\n/**\r\n * Guarda un mensaje en el historial\r\n */\r\nexport async function saveChatHistory(\r\n    supabase: SupabaseClient,\r\n    userId: string,\r\n    contactId: number,\r\n    userMessage: string,\r\n    assistantMessage: string,\r\n    intent: any\r\n): Promise<void> {\r\n    // Guardar mensaje del usuario\r\n    await supabase.from('chat_history').insert({\r\n        user_id: userId,\r\n        contact_id: contactId,\r\n        message_type: 'user',\r\n        content: userMessage,\r\n        created_at: new Date().toISOString()\r\n    })\r\n\r\n    // Guardar respuesta del asistente\r\n    await supabase.from('chat_history').insert({\r\n        user_id: userId,\r\n        contact_id: contactId,\r\n        message_type: 'assistant',\r\n        content: assistantMessage,\r\n        metadata: {\r\n            intent: intent.primary,\r\n            sentiment: intent.sentiment.polarity\r\n        },\r\n        created_at: new Date().toISOString()\r\n    })\r\n}\r\n\r\n/**\r\n * Carga el contexto completo de la conversaci√≥n\r\n * \r\n * IMPORTANTE: Filtra datos transaccionales antiguos si detecta nueva solicitud\r\n */\r\nexport async function loadConversationContext(\r\n    supabase: SupabaseClient,\r\n    config: AccountConfig,\r\n    contact: Contact,\r\n    currentMessage: string,\r\n    intent: any\r\n): Promise<ConversationContext> {\r\n    console.log(`üìö [CONTEXT] Loading conversation context`)\r\n\r\n    // Importar din√°micamente para evitar dependencias circulares\r\n    const { loadConversationState } = await import('./conversation-state.ts')\r\n    const { isNewTransactionalRequest, filterTransactionalContext } = await import('./context-filter.ts')\r\n\r\n    // Cargar todo en paralelo\r\n    const [\r\n        recentMessages,\r\n        accountLearnings,\r\n        userPreferences,\r\n        topProducts,\r\n        conversationState\r\n    ] = await Promise.all([\r\n        getChatHistory(supabase, config.userId, contact.id, 10),\r\n        getRelevantLearnings(supabase, config.userId, currentMessage, 5),\r\n        getUserPreferences(supabase, contact.id),\r\n        config.hasProducts ? getTopProducts(supabase, config.userId, 5) : Promise.resolve([]),\r\n        loadConversationState(supabase, contact.id.toString())\r\n    ])\r\n\r\n    // Detectar si es nueva solicitud transaccional\r\n    const isNewRequest = isNewTransactionalRequest(currentMessage, recentMessages);\r\n\r\n    // Filtrar contexto si es nueva solicitud\r\n    const filteredMessages = filterTransactionalContext(recentMessages, isNewRequest);\r\n\r\n    if (isNewRequest && filteredMessages.length < recentMessages.length) {\r\n        console.log(`üßπ [CONTEXT] Filtered ${recentMessages.length - filteredMessages.length} old quote messages`);\r\n    }\r\n\r\n    return {\r\n        recentMessages: filteredMessages,\r\n        accountLearnings,\r\n        userPreferences,\r\n        topProducts,\r\n        conversationState: conversationState || null,\r\n        ragContext: undefined, // Set later in index.ts after RAG retrieval\r\n        activePromotions: [], // TODO: Cargar promociones activas\r\n        appointmentSlots: [] // TODO: Cargar slots si es necesario\r\n    }\r\n}\r\n\r\n/**\r\n * Obtiene las preferencias del usuario\r\n */\r\nasync function getUserPreferences(\r\n    supabase: SupabaseClient,\r\n    contactId: number\r\n) {\r\n    const { data, error } = await supabase\r\n        .from('user_preferences')\r\n        .select('*')\r\n        .eq('contact_id', contactId)\r\n\r\n    if (error) {\r\n        console.error(`‚ùå [CONTEXT] Error fetching preferences: ${error.message}`)\r\n        return []\r\n    }\r\n\r\n    return data || []\r\n}\r\n\r\n/**\r\n * Obtiene los productos m√°s populares\r\n */\r\nasync function getTopProducts(\r\n    supabase: SupabaseClient,\r\n    userId: string,\r\n    limit: number\r\n): Promise<Product[]> {\r\n    const { data, error } = await supabase\r\n        .from('products')\r\n        .select('*')\r\n        .eq('user_id', userId)\r\n        .limit(limit)\r\n\r\n    if (error) {\r\n        console.error(`‚ùå [CONTEXT] Error fetching products: ${error.message}`)\r\n        return []\r\n    }\r\n\r\n    return (data || []) as Product[]\r\n}\r\n"},{"name":"utils/conversation-state.ts","content":"import { SupabaseClient } from 'https://esm.sh/@supabase/supabase-js@2'\r\nimport type {\r\n    ConversationContextState,\r\n    MentionedProduct,\r\n    CartItem\r\n} from '../config/types.ts'\r\n\r\n/**\r\n * Loads conversation state for a contact\r\n */\r\nexport async function loadConversationState(\r\n    supabase: SupabaseClient,\r\n    contactId: string\r\n): Promise<ConversationContextState | null> {\r\n    try {\r\n        const { data, error } = await supabase\r\n            .from('conversation_contexts') // Changed from conversation_states\r\n            .select('state')\r\n            .eq('contact_id', contactId)\r\n            .single()\r\n\r\n        if (error || !data) {\r\n            return null\r\n        }\r\n\r\n        const state = typeof data.state === 'string'\r\n            ? JSON.parse(data.state)\r\n            : data.state\r\n\r\n        // Check if state is stale (older than 24 hours)\r\n        const updatedAt = new Date(state.updatedAt)\r\n        const hoursSince = (Date.now() - updatedAt.getTime()) / 3600000\r\n\r\n        if (hoursSince > 24) {\r\n            console.log(`‚è∞ [STATE] Conversation state is stale (${hoursSince.toFixed(1)}h old), ignoring`)\r\n            return null\r\n        }\r\n\r\n        console.log(`‚úÖ [STATE] Loaded conversation state: ${state.lastProductsMentioned?.length || 0} products mentioned`)\r\n        return state\r\n\r\n    } catch (error) {\r\n        console.error(`‚ùå [STATE] Error loading conversation state:`, error)\r\n        return null\r\n    }\r\n}\r\n\r\n/**\r\n * Saves conversation state for a contact\r\n */\r\nexport async function saveConversationState(\r\n    supabase: SupabaseClient,\r\n    contactId: string,\r\n    state: Partial<ConversationContextState>\r\n): Promise<void> {\r\n    try {\r\n        // Load existing state and merge\r\n        const existing = await loadConversationState(supabase, contactId)\r\n        const merged: ConversationContextState = {\r\n            lastProductsMentioned: state.lastProductsMentioned || existing?.lastProductsMentioned || [],\r\n            tentativeCart: state.tentativeCart || existing?.tentativeCart || [],\r\n            lastIntent: state.lastIntent || existing?.lastIntent || 'unknown',\r\n            lastAgentResponse: state.lastAgentResponse || existing?.lastAgentResponse,\r\n            appointmentContext: state.appointmentContext || existing?.appointmentContext,\r\n            potentialService: state.potentialService || existing?.potentialService,\r\n            updatedAt: new Date().toISOString()\r\n        }\r\n\r\n        await supabase.from('conversation_contexts').upsert({ // Changed from conversation_states\r\n            contact_id: contactId,\r\n            state: merged,\r\n            updated_at: merged.updatedAt\r\n        })\r\n\r\n        console.log(`‚úÖ [STATE] Saved conversation state for contact ${contactId}`)\r\n\r\n    } catch (error) {\r\n        console.error(`‚ùå [STATE] Error saving conversation state:`, error)\r\n    }\r\n}\r\n\r\n/**\r\n * Detects contextual references in user message\r\n * Examples: \"el primero\", \"el segundo\", \"ese\", \"esa\"\r\n */\r\nexport function detectContextualReference(message: string): {\r\n    hasReference: boolean\r\n    position?: number\r\n    type: 'positional' | 'demonstrative' | 'none'\r\n} {\r\n    const lowerMessage = message.toLowerCase()\r\n\r\n    // Positional references: \"el primero\", \"el segundo\", \"la tercera\"\r\n    const positionalPatterns = [\r\n        { pattern: /\\b(el|la)\\s+primer[oa]?\\b/i, position: 1 },\r\n        { pattern: /\\b(el|la)\\s+segund[oa]?\\b/i, position: 2 },\r\n        { pattern: /\\b(el|la)\\s+tercer[oa]?\\b/i, position: 3 },\r\n        { pattern: /\\b(el|la)\\s+cuart[oa]?\\b/i, position: 4 },\r\n        { pattern: /\\b(el|la)\\s+quint[oa]?\\b/i, position: 5 }\r\n    ]\r\n\r\n    for (const { pattern, position } of positionalPatterns) {\r\n        if (pattern.test(lowerMessage)) {\r\n            return { hasReference: true, position, type: 'positional' }\r\n        }\r\n    }\r\n\r\n    // Demonstrative references: \"ese\", \"esa\", \"esos\", \"aquel\"\r\n    if (/\\b(ese|esa|esos|esas|aquel|aquella|aquellos|aquellas)\\b/i.test(lowerMessage)) {\r\n        // Assume they mean the last one mentioned (position 1)\r\n        return { hasReference: true, position: 1, type: 'demonstrative' }\r\n    }\r\n\r\n    return { hasReference: false, type: 'none' }\r\n}\r\n\r\n/**\r\n * Resolves a contextual reference to a product ID\r\n */\r\nexport function resolveReference(\r\n    reference: ReturnType<typeof detectContextualReference>,\r\n    state: ConversationContextState | null\r\n): number | null {\r\n    if (!reference.hasReference || !state || !state.lastProductsMentioned.length) {\r\n        return null\r\n    }\r\n\r\n    const product = state.lastProductsMentioned.find(p => p.position === reference.position)\r\n    return product?.id || null\r\n}\r\n\r\n/**\r\n * Extracts product IDs from agent response (for tracking what was shown)\r\n */\r\nexport function extractMentionedProducts(\r\n    responseText: string,\r\n    productMap: Record<string, any>\r\n): MentionedProduct[] {\r\n    const mentioned: MentionedProduct[] = []\r\n    const productIdRegex = /\\[PRODUCT_(?:CARD|NAME|PRICE|MEDIA):(\\d+)\\]/g\r\n    const foundIds = new Set<number>()\r\n\r\n    let match\r\n    let position = 1\r\n    while ((match = productIdRegex.exec(responseText)) !== null) {\r\n        const id = parseInt(match[1], 10)\r\n        if (!foundIds.has(id) && productMap[id]) {\r\n            foundIds.add(id)\r\n            mentioned.push({\r\n                id,\r\n                position: position++,\r\n                name: productMap[id].productName,\r\n                price: productMap[id].price,\r\n                mentionedAt: new Date().toISOString()\r\n            })\r\n        }\r\n    }\r\n\r\n    return mentioned\r\n}\r\n"},{"name":"utils/cors.ts","content":"/**\r\n * ELINA V5 - CORS Headers\r\n */\r\n\r\nexport const corsHeaders = {\r\n    'Access-Control-Allow-Origin': '*',\r\n    'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',\r\n    'Access-Control-Allow-Methods': 'POST, GET, OPTIONS, PUT, DELETE'\r\n}\r\n"},{"name":"utils/evolution.ts","content":"/**\r\n * ELINA V5 - Evolution API Client\r\n * \r\n * Cliente para interactuar con Evolution API (WhatsApp)\r\n */\r\n\r\nimport type { AccountConfig } from '../config/types.ts'\r\n\r\n/**\r\n * Env√≠a un mensaje de texto\r\n */\r\nexport async function sendMessage(\r\n    config: AccountConfig,\r\n    remoteJid: string,\r\n    text: string,\r\n    enableDelay: boolean = true\r\n): Promise<void> {\r\n    console.log(`üì§ [EVOLUTION] Sending message to ${remoteJid}`)\r\n\r\n    const url = `${config.evolutionApiUrl}/message/sendText/${config.instanceName}`\r\n\r\n    // Calcular delay aleatorio entre 1000-2000ms\r\n    const delayMs = enableDelay ? Math.floor(Math.random() * 1000) + 1000 : 0\r\n\r\n    const payload = {\r\n        number: remoteJid,\r\n        text: text,\r\n        ...(enableDelay && { delay: delayMs })\r\n    }\r\n\r\n    console.log(`üì§ [EVOLUTION] URL: ${url}`)\r\n    console.log(`üì§ [EVOLUTION] Payload:`, JSON.stringify(payload, null, 2))\r\n\r\n    try {\r\n        const response = await fetch(url, {\r\n            method: 'POST',\r\n            headers: {\r\n                'Content-Type': 'application/json',\r\n                'apikey': config.evolutionApiKey\r\n            },\r\n            body: JSON.stringify(payload)\r\n        })\r\n\r\n        if (!response.ok) {\r\n            const errorText = await response.text()\r\n            throw new Error(`Evolution API error: ${response.status} - ${errorText}`)\r\n        }\r\n\r\n        console.log(`‚úÖ [EVOLUTION] Message sent successfully`)\r\n    } catch (error) {\r\n        console.error(`‚ùå [EVOLUTION] Error sending message: ${error.message}`)\r\n        throw error\r\n    }\r\n}\r\n\r\n/**\r\n * Env√≠a una imagen\r\n */\r\nexport async function sendImage(\r\n    config: AccountConfig,\r\n    remoteJid: string,\r\n    imageUrl: string,\r\n    caption?: string\r\n): Promise<void> {\r\n    console.log(`üì§ [EVOLUTION] Sending image to ${remoteJid}`)\r\n\r\n    const url = `${config.evolutionApiUrl}/message/sendMedia/${config.instanceName}`\r\n\r\n    // Limpiar n√∫mero (remover @s.whatsapp.net si existe)\r\n    const cleanNumber = remoteJid.replace('@s.whatsapp.net', '')\r\n\r\n    // Extraer extensi√≥n de la URL para mimetype\r\n    const extension = imageUrl.split('.').pop()?.toLowerCase() || 'jpg'\r\n    const mimetypes: Record<string, string> = {\r\n        'jpg': 'image/jpeg',\r\n        'jpeg': 'image/jpeg',\r\n        'png': 'image/png',\r\n        'gif': 'image/gif',\r\n        'webp': 'image/webp'\r\n    }\r\n    const mimetype = mimetypes[extension] || 'image/jpeg'\r\n\r\n    // Delay aleatorio entre 1000-2000ms\r\n    const delayMs = Math.floor(Math.random() * 1000) + 1000\r\n\r\n    const payload = {\r\n        number: cleanNumber,\r\n        mediatype: 'image',\r\n        mimetype: mimetype,\r\n        caption: caption || '',\r\n        media: imageUrl,\r\n        fileName: `image.${extension}`,\r\n        delay: delayMs\r\n    }\r\n\r\n    console.log(`üì§ [EVOLUTION] Payload:`, JSON.stringify(payload, null, 2))\r\n\r\n    try {\r\n        const response = await fetch(url, {\r\n            method: 'POST',\r\n            headers: {\r\n                'Content-Type': 'application/json',\r\n                'apikey': config.evolutionApiKey\r\n            },\r\n            body: JSON.stringify(payload)\r\n        })\r\n\r\n        if (!response.ok) {\r\n            const errorText = await response.text()\r\n            throw new Error(`Evolution API error: ${response.status} - ${errorText}`)\r\n        }\r\n\r\n        console.log(`‚úÖ [EVOLUTION] Image sent successfully`)\r\n    } catch (error) {\r\n        console.error(`‚ùå [EVOLUTION] Error sending image: ${error.message}`)\r\n        throw error\r\n    }\r\n}\r\n\r\n/**\r\n * Env√≠a un audio\r\n */\r\nexport async function sendAudio(\r\n    config: AccountConfig,\r\n    remoteJid: string,\r\n    audioUrl: string\r\n): Promise<void> {\r\n    console.log(`üì§ [EVOLUTION] Sending audio to ${remoteJid}`)\r\n\r\n    const url = `${config.evolutionApiUrl}/message/sendMedia/${config.instanceName}`\r\n\r\n    try {\r\n        const response = await fetch(url, {\r\n            method: 'POST',\r\n            headers: {\r\n                'Content-Type': 'application/json',\r\n                'apikey': config.evolutionApiKey\r\n            },\r\n            body: JSON.stringify({\r\n                number: remoteJid,\r\n                mediatype: 'audio',\r\n                media: audioUrl\r\n            })\r\n        })\r\n\r\n        if (!response.ok) {\r\n            throw new Error(`Evolution API error: ${response.status}`)\r\n        }\r\n\r\n        console.log(`‚úÖ [EVOLUTION] Audio sent successfully`)\r\n    } catch (error) {\r\n        console.error(`‚ùå [EVOLUTION] Error sending audio: ${error.message}`)\r\n        throw error\r\n    }\r\n}\r\n\r\n/**\r\n * Env√≠a un video\r\n */\r\nexport async function sendVideo(\r\n    config: AccountConfig,\r\n    remoteJid: string,\r\n    videoUrl: string,\r\n    caption?: string\r\n): Promise<void> {\r\n    console.log(`üì§ [EVOLUTION] Sending video to ${remoteJid}`)\r\n\r\n    const url = `${config.evolutionApiUrl}/message/sendMedia/${config.instanceName}`\r\n\r\n    // Limpiar n√∫mero (remover @s.whatsapp.net si existe)\r\n    const cleanNumber = remoteJid.replace('@s.whatsapp.net', '')\r\n\r\n    // Extraer extensi√≥n para mimetype\r\n    const extension = videoUrl.split('.').pop()?.toLowerCase() || 'mp4'\r\n    const mimetypes: Record<string, string> = {\r\n        'mp4': 'video/mp4',\r\n        'mov': 'video/quicktime',\r\n        'avi': 'video/x-msvideo',\r\n        'webm': 'video/webm'\r\n    }\r\n    const mimetype = mimetypes[extension] || 'video/mp4'\r\n\r\n    // Delay aleatorio entre 1000-2000ms\r\n    const delayMs = Math.floor(Math.random() * 1000) + 1000\r\n\r\n    const payload = {\r\n        number: cleanNumber,\r\n        mediatype: 'video',\r\n        mimetype: mimetype,\r\n        caption: caption || '',\r\n        media: videoUrl,\r\n        fileName: `video.${extension}`,\r\n        delay: delayMs\r\n    }\r\n\r\n    console.log(`üì§ [EVOLUTION] Payload:`, JSON.stringify(payload, null, 2))\r\n\r\n    try {\r\n        const response = await fetch(url, {\r\n            method: 'POST',\r\n            headers: {\r\n                'Content-Type': 'application/json',\r\n                'apikey': config.evolutionApiKey\r\n            },\r\n            body: JSON.stringify(payload)\r\n        })\r\n\r\n        if (!response.ok) {\r\n            const errorText = await response.text()\r\n            throw new Error(`Evolution API error: ${response.status} - ${errorText}`)\r\n        }\r\n\r\n        console.log(`‚úÖ [EVOLUTION] Video sent successfully`)\r\n    } catch (error) {\r\n        console.error(`‚ùå [EVOLUTION] Error sending video: ${error.message}`)\r\n        throw error\r\n    }\r\n}\r\n\r\n"},{"name":"utils/message-buffer.ts","content":"/**\r\n * ELINA V5 - Message Buffer (Supabase Table)\r\n *\r\n * Agrupa m√∫ltiples mensajes consecutivos del mismo usuario en una sola respuesta.\r\n * Usa tabla message_buffer en Supabase para coordinar entre requests independientes.\r\n *\r\n * Flujo:\r\n * 1. Llega mensaje ‚Üí INSERT en message_buffer\r\n * 2. Esperar BUFFER_WINDOW_MS\r\n * 3. Consultar si mi mensaje es el m√°s reciente para este contacto\r\n *    - S√≠ ‚Üí Tomar todos, DELETE, devolver texto combinado\r\n *    - No ‚Üí Otro mensaje lleg√≥ despu√©s, retornar shouldProcess: false\r\n */\r\n\r\nconst BUFFER_WINDOW_MS = 4000 // 4 segundos para agrupar mensajes\r\n\r\nfunction sleep(ms: number): Promise<void> {\r\n    return new Promise(resolve => setTimeout(resolve, ms))\r\n}\r\n\r\n/**\r\n * Agrega un mensaje al buffer y decide si procesar o esperar\r\n */\r\nexport async function bufferMessage(\r\n    supabase: any,\r\n    accountId: string,\r\n    contactId: number,\r\n    messageText: string\r\n): Promise<{ shouldProcess: boolean; combinedText: string }> {\r\n\r\n    // 1. Insertar mensaje en el buffer\r\n    const { data: inserted, error: insertError } = await supabase\r\n        .from('message_buffer')\r\n        .insert({\r\n            account_id: accountId,\r\n            contact_id: contactId,\r\n            message_text: messageText\r\n        })\r\n        .select('id, created_at')\r\n        .single()\r\n\r\n    if (insertError || !inserted) {\r\n        console.error('‚ùå [BUFFER] Error inserting into buffer:', insertError)\r\n        // Fallback: procesar el mensaje solo sin buffering\r\n        return { shouldProcess: true, combinedText: messageText }\r\n    }\r\n\r\n    const myId = inserted.id\r\n    console.log(`üì• [BUFFER] Message buffered (id: ${myId}), waiting ${BUFFER_WINDOW_MS}ms...`)\r\n\r\n    // 2. Esperar la ventana de buffer\r\n    await sleep(BUFFER_WINDOW_MS)\r\n\r\n    // 3. Verificar si llegaron mensajes m√°s recientes para este contacto\r\n    const { data: latest, error: latestError } = await supabase\r\n        .from('message_buffer')\r\n        .select('id')\r\n        .eq('account_id', accountId)\r\n        .eq('contact_id', contactId)\r\n        .order('id', { ascending: false })\r\n        .limit(1)\r\n        .single()\r\n\r\n    if (latestError || !latest) {\r\n        // Buffer fue limpiado por otro request, no procesar\r\n        console.log(`‚è≠Ô∏è [BUFFER] Buffer already consumed by another request`)\r\n        return { shouldProcess: false, combinedText: '' }\r\n    }\r\n\r\n    // Si mi mensaje NO es el m√°s reciente, otro lleg√≥ despu√©s ‚Üí no procesar\r\n    if (latest.id !== myId) {\r\n        console.log(`‚è≠Ô∏è [BUFFER] Newer message exists (my: ${myId}, latest: ${latest.id}), skipping`)\r\n        return { shouldProcess: false, combinedText: '' }\r\n    }\r\n\r\n    // 4. Soy el m√°s reciente ‚Üí tomar todos los mensajes y procesarlos\r\n    const { data: allMessages, error: fetchError } = await supabase\r\n        .from('message_buffer')\r\n        .select('id, message_text, created_at')\r\n        .eq('account_id', accountId)\r\n        .eq('contact_id', contactId)\r\n        .order('created_at', { ascending: true })\r\n\r\n    if (fetchError || !allMessages || allMessages.length === 0) {\r\n        console.error('‚ùå [BUFFER] Error fetching buffered messages:', fetchError)\r\n        return { shouldProcess: true, combinedText: messageText }\r\n    }\r\n\r\n    // 5. Combinar todos los mensajes\r\n    const combinedText = allMessages\r\n        .map((m: any) => m.message_text)\r\n        .join('\\n')\r\n\r\n    // 6. Limpiar el buffer para este contacto\r\n    const ids = allMessages.map((m: any) => m.id)\r\n    const { error: deleteError } = await supabase\r\n        .from('message_buffer')\r\n        .delete()\r\n        .in('id', ids)\r\n\r\n    if (deleteError) {\r\n        console.error('‚ö†Ô∏è [BUFFER] Error cleaning buffer (non-critical):', deleteError)\r\n    }\r\n\r\n    console.log(`‚úÖ [BUFFER] Combined ${allMessages.length} messages into one`)\r\n    return { shouldProcess: true, combinedText }\r\n}\r\n\r\n/**\r\n * Limpia mensajes viejos del buffer (seguridad, llamar peri√≥dicamente)\r\n */\r\nexport async function cleanOldBuffers(supabase: any): Promise<number> {\r\n    const cutoff = new Date(Date.now() - 60000).toISOString() // 60 segundos\r\n    const { data, error } = await supabase\r\n        .from('message_buffer')\r\n        .delete()\r\n        .lt('created_at', cutoff)\r\n        .select('id')\r\n\r\n    if (error) {\r\n        console.error('‚ö†Ô∏è [BUFFER] Error cleaning old buffers:', error)\r\n        return 0\r\n    }\r\n    return data?.length || 0\r\n}\r\n"},{"name":"utils/placeholders.ts","content":"/**\r\n * ELINA V5 - Product Placeholders System\r\n * \r\n * Maneja el reemplazo de placeholders de productos y generaci√≥n de cotizaciones\r\n * Basado en la l√≥gica original de n8n V4\r\n */\r\n\r\nimport type { SupabaseClient } from 'https://esm.sh/@supabase/supabase-js@2'\r\nimport type { Product, QuoteItem, PlaceholderResult } from '../config/types.ts'\r\n\r\n/**\r\n * Procesa el texto del agente para reemplazar placeholders y detectar cotizaciones\r\n */\r\nexport async function processPlaceholders(\r\n    supabase: SupabaseClient,\r\n    userId: string,\r\n    text: string\r\n): Promise<PlaceholderResult> {\r\n    let finalText = text\r\n\r\n    // 1. Extraer IDs de productos\r\n    // Regex: Busca [CUALQUIER_COSA:NUMERO]\r\n    const placeholderRegex = /\\[[^\\]]*?(\\d+)\\]/g\r\n    const matches = [...text.matchAll(placeholderRegex)]\r\n    const productIds = [...new Set(matches.map(m => parseInt(m[1], 10)))].filter(id => !isNaN(id))\r\n\r\n    if (productIds.length === 0) {\r\n        return {\r\n            finalText,\r\n            productIds: [],\r\n            productsMap: {},\r\n            shouldGenerateQuote: false,\r\n            quoteItems: [],\r\n            productMedia: []\r\n        }\r\n    }\r\n\r\n    // 2. Obtener productos de la DB\r\n    const { data: products, error } = await supabase\r\n        .rpc('get_products_by_ids', {\r\n            p_user_id: userId,\r\n            p_product_ids: productIds\r\n        })\r\n\r\n    if (error || !products) {\r\n        console.error(`‚ùå [PLACEHOLDERS] Error fetching products: ${error?.message}`)\r\n        return {\r\n            finalText, // Devolver texto original si falla\r\n            productIds,\r\n            productsMap: {},\r\n            shouldGenerateQuote: false,\r\n            quoteItems: [],\r\n            productMedia: []\r\n        }\r\n    }\r\n\r\n    // Crear mapa de productos para b√∫squeda r√°pida\r\n    const productMap: Record<string, Product> = {}\r\n    products.forEach((p: any) => {\r\n        productMap[String(p.id)] = {\r\n            id: p.id,\r\n            productName: p.product_name,\r\n            price: Number(p.price),\r\n            stock: p.stock,\r\n            description: p.description,\r\n            mediaUrl: p.media_url,\r\n            productType: p.product_type\r\n        }\r\n    })\r\n\r\n    // 3. Reemplazar Placeholders T√©cnicos\r\n    const techRegex = /\\[PRODUCT_(\\w+):(\\d+)\\]/g\r\n    finalText = finalText.replace(techRegex, (fullMatch, field, idStr) => {\r\n        const product = productMap[idStr]\r\n        if (!product) return fullMatch\r\n\r\n        switch (field.toUpperCase()) {\r\n            case 'NAME': return product.productName\r\n            case 'PRICE': return `$${product.price.toFixed(2)}`\r\n            case 'URL': return '' // No mostrar URL en texto, se env√≠a como media autom√°ticamente\r\n            case 'MEDIA': return '' // No mostrar URL en texto, se env√≠a como media autom√°ticamente\r\n            case 'STOCK': return String(product.stock)\r\n            case 'DESC': return product.description || ''\r\n            default: return fullMatch\r\n        }\r\n    })\r\n\r\n    // 4. Limpiar Placeholders \"Sucios\" (IA hallucination: [105X:7305])\r\n    // Reemplaza [CUALQUIER_TEXTO:ID] por el nombre real del producto\r\n    const messRegex = /\\[([^\\]]+):(\\d+)\\]/g\r\n    finalText = finalText.replace(messRegex, (fullMatch, content, idStr) => {\r\n        const product = productMap[idStr]\r\n        if (!product) return fullMatch\r\n\r\n        // Si es un placeholder t√©cnico ya procesado (o que parezca uno), ignorarlo\r\n        if (content.startsWith('PRODUCT_')) return fullMatch\r\n\r\n        return product.productName\r\n    })\r\n\r\n    // 5. Detectar necesidad de cotizaci√≥n\r\n    const shouldGenerateQuote = detectQuoteNeed(text, productIds.length)\r\n\r\n    // 6. Generar items de cotizaci√≥n si es necesario\r\n    const quoteItems: QuoteItem[] = []\r\n    if (shouldGenerateQuote) {\r\n        // Extraer cantidades del texto (simple heuristic)\r\n        // Busca patrones como \"2 unidades de [PROD:123]\" o \"x3 [PROD:123]\"\r\n        // Esta es una simplificaci√≥n, la l√≥gica real puede ser m√°s compleja\r\n        productIds.forEach(id => {\r\n            const product = productMap[String(id)]\r\n            if (product) {\r\n                quoteItems.push({\r\n                    product_id: product.id,\r\n                    product_name: product.productName,\r\n                    quantity: 1, // Default a 1 por ahora\r\n                    price: product.price,\r\n                    subtotal: product.price\r\n                })\r\n            }\r\n        })\r\n    }\r\n\r\n    // 7. Recopilar media de productos procesados\r\n    // Regla: Si el producto fue mencionado (productIds) Y tiene mediaUrl, agregarlo\r\n    const productMedia: Array<{ productId: number; url: string; type: 'image' | 'video' }> = []\r\n\r\n    productIds.forEach(id => {\r\n        const product = productMap[String(id)]\r\n        if (product && product.mediaUrl) {\r\n            // Detectar tipo por extensi√≥n\r\n            const isVideo = /\\.(mp4|mov|avi|webm)$/i.test(product.mediaUrl)\r\n            productMedia.push({\r\n                productId: product.id,\r\n                url: product.mediaUrl,\r\n                type: isVideo ? 'video' : 'image'\r\n            })\r\n        }\r\n    })\r\n\r\n    console.log(`   - Found ${productMedia.length} product media from ${productIds.length} products`)\r\n\r\n    return {\r\n        finalText,\r\n        productIds,\r\n        productsMap: productMap,\r\n        shouldGenerateQuote,\r\n        quoteItems,\r\n        productMedia\r\n    }\r\n}\r\n\r\n/**\r\n * Detecta si se debe generar una cotizaci√≥n basado en reglas\r\n */\r\nfunction detectQuoteNeed(text: string, productCount: number): boolean {\r\n    const lowerText = text.toLowerCase()\r\n\r\n    // Keywords positivas\r\n    const quoteKeywords = [\r\n        'cotizaci√≥n', 'cotizacion', 'presupuesto',\r\n        'generar pdf', 'enviar pdf', 'formalizar', 'documento'\r\n    ]\r\n    const hasKeyword = quoteKeywords.some(k => lowerText.includes(k))\r\n\r\n    // Keywords negativas\r\n    const negativeKeywords = [\r\n        'no quiero', 'no necesito', 'solo ver',\r\n        'consultar', 'solo pregunto'\r\n    ]\r\n    const hasNegative = negativeKeywords.some(k => lowerText.includes(k))\r\n\r\n    if (hasNegative) return false\r\n\r\n    // Regla 1: Muchos productos (>= 3) -> Asumir cotizaci√≥n\r\n    if (productCount >= 3) return true\r\n\r\n    // Regla 2: Petici√≥n expl√≠cita\r\n    if (productCount > 0 && hasKeyword) return true\r\n\r\n    return false\r\n}\r\n"},{"name":"utils/product-cache.ts","content":"/**\r\n * ELINA V5 - Product Cache Manager\r\n *\r\n * Gestiona el cache de productos mencionados en conversaciones\r\n * para mantener FAQs y contexto disponible en follow-up questions\r\n */\r\n\r\nimport type { SupabaseClient } from 'https://esm.sh/@supabase/supabase-js@2'\r\nimport type { ProductWithFAQs } from '../config/types.ts'\r\n\r\n/**\r\n * Cachea productos mencionados en una conversaci√≥n\r\n */\r\nexport async function cacheProductsMentioned(\r\n    supabase: SupabaseClient,\r\n    userId: string,\r\n    contactId: number,\r\n    products: any[] // Productos retornados por buscar_productos\r\n): Promise<void> {\r\n    if (!products || products.length === 0) {\r\n        return\r\n    }\r\n\r\n    console.log(`üíæ [CACHE] Caching ${products.length} mentioned products for contact ${contactId}`)\r\n\r\n    try {\r\n        // Preparar datos para insertar\r\n        const cacheRecords = products.map(p => ({\r\n            user_id: userId,\r\n            contact_id: contactId,\r\n            product_id: p.id,\r\n            product_snapshot: {\r\n                id: p.id,\r\n                product_name: p.product_name,\r\n                price: p.price,\r\n                description: p.description,\r\n                enhanced_description: p.enhanced_description,\r\n                media_url: p.media_url,\r\n                faq: p.faq,\r\n                benefits: p.benefits,\r\n                usage_instructions: p.usage_instructions\r\n            },\r\n            mentioned_at: new Date().toISOString(),\r\n            last_accessed_at: new Date().toISOString()\r\n        }))\r\n\r\n        // Upsert: Si ya existe (user_id + contact_id + product_id), actualizar last_accessed_at\r\n        const { error } = await supabase\r\n            .from('conversation_product_cache')\r\n            .upsert(cacheRecords, {\r\n                onConflict: 'user_id,contact_id,product_id',\r\n                ignoreDuplicates: false\r\n            })\r\n\r\n        if (error) {\r\n            console.error(`‚ùå [CACHE] Error caching products: ${error.message}`)\r\n            // No lanzar error, esto no debe bloquear la conversaci√≥n\r\n        } else {\r\n            console.log(`‚úÖ [CACHE] Products cached successfully`)\r\n        }\r\n\r\n    } catch (error) {\r\n        console.error(`‚ùå [CACHE] Exception caching products: ${error.message}`)\r\n        // No lanzar error\r\n    }\r\n}\r\n\r\n/**\r\n * Obtiene productos mencionados recientemente en una conversaci√≥n\r\n */\r\nexport async function getRecentlyMentionedProducts(\r\n    supabase: SupabaseClient,\r\n    userId: string,\r\n    contactId: number,\r\n    limit: number = 5\r\n): Promise<ProductWithFAQs[]> {\r\n    console.log(`üì¶ [CACHE] Fetching recently mentioned products for contact ${contactId}`)\r\n\r\n    try {\r\n        const { data, error } = await supabase\r\n            .from('conversation_product_cache')\r\n            .select('product_snapshot, mentioned_at, last_accessed_at')\r\n            .eq('user_id', userId)\r\n            .eq('contact_id', contactId)\r\n            .order('last_accessed_at', { ascending: false })\r\n            .limit(limit)\r\n\r\n        if (error) {\r\n            console.error(`‚ùå [CACHE] Error fetching cached products: ${error.message}`)\r\n            return []\r\n        }\r\n\r\n        if (!data || data.length === 0) {\r\n            console.log(`   - No cached products found`)\r\n            return []\r\n        }\r\n\r\n        // Mapear snapshots a ProductWithFAQs\r\n        const products: ProductWithFAQs[] = data.map((record: any) => {\r\n            const snapshot = record.product_snapshot\r\n\r\n            return {\r\n                id: snapshot.id,\r\n                productName: snapshot.product_name,\r\n                price: parseFloat(snapshot.price) || 0,\r\n                description: snapshot.description,\r\n                enhanced_description: snapshot.enhanced_description,\r\n                faq: snapshot.faq,\r\n                benefits: snapshot.benefits,\r\n                usage_instructions: snapshot.usage_instructions,\r\n                mentionedAt: new Date(record.mentioned_at)\r\n            }\r\n        })\r\n\r\n        console.log(`‚úÖ [CACHE] Found ${products.length} cached products`)\r\n        return products\r\n\r\n    } catch (error) {\r\n        console.error(`‚ùå [CACHE] Exception fetching cached products: ${error.message}`)\r\n        return []\r\n    }\r\n}\r\n\r\n/**\r\n * Formatea productos cacheados para incluir en el prompt del sistema\r\n */\r\nexport function formatCachedProductsForPrompt(products: ProductWithFAQs[]): string {\r\n    if (!products || products.length === 0) {\r\n        return ''\r\n    }\r\n\r\n    let formatted = `\\n## üì¶ Productos Mencionados Recientemente en esta Conversaci√≥n\\n`\r\n    formatted += `(√ösalos para responder preguntas de seguimiento sin necesidad de buscar de nuevo)\\n\\n`\r\n\r\n    for (const product of products) {\r\n        formatted += `### ${product.productName} (ID: ${product.id})\\n`\r\n        formatted += `- Precio: $${product.price}\\n`\r\n\r\n        // Usar enhanced_description si existe\r\n        const desc = product.enhanced_description || product.description\r\n        if (desc) {\r\n            formatted += `- Descripci√≥n: ${desc}\\n`\r\n        }\r\n\r\n        // Incluir benefits si existen\r\n        if (product.benefits) {\r\n            formatted += `- Beneficios: ${product.benefits}\\n`\r\n        }\r\n\r\n        // Incluir FAQs si existen\r\n        if (product.faq && Array.isArray(product.faq) && product.faq.length > 0) {\r\n            formatted += `- FAQs:\\n`\r\n            product.faq.forEach((item, idx) => {\r\n                formatted += `  ${idx + 1}. ${item.question}\\n`\r\n                formatted += `     ‚Üí ${item.answer}\\n`\r\n            })\r\n        }\r\n\r\n        formatted += `\\n`\r\n    }\r\n\r\n    return formatted\r\n}\r\n\r\n/**\r\n * Limpia cache antiguo (llamar peri√≥dicamente o en cron job)\r\n */\r\nexport async function cleanupOldCache(supabase: SupabaseClient): Promise<number> {\r\n    console.log(`üßπ [CACHE] Cleaning up old product cache`)\r\n\r\n    try {\r\n        const { error } = await supabase.rpc('cleanup_old_product_cache')\r\n\r\n        if (error) {\r\n            console.error(`‚ùå [CACHE] Error cleaning up cache: ${error.message}`)\r\n            return 0\r\n        }\r\n\r\n        console.log(`‚úÖ [CACHE] Old cache cleaned up successfully`)\r\n        return 1\r\n\r\n    } catch (error) {\r\n        console.error(`‚ùå [CACHE] Exception cleaning up cache: ${error.message}`)\r\n        return 0\r\n    }\r\n}\r\n"},{"name":"utils/rag-system.ts","content":"/**\r\n * RAG System with Semantic Embeddings\r\n * Retrieval-Augmented Generation for context-aware responses\r\n */\r\n\r\nimport { SupabaseClient } from 'https://esm.sh/@supabase/supabase-js@2'\r\n\r\n\r\nconst OPENAI_API_KEY = Deno.env.get('OPENAI_API_KEY')!\r\nconst EMBEDDING_MODEL = 'text-embedding-3-small'\r\nconst SIMILARITY_THRESHOLD = 0.35\r\nconst MAX_CONTEXT_MESSAGES = 5\r\nconst MAX_PRODUCT_RESULTS = 3\r\n\r\nexport interface RAGContext {\r\n    relevantMessages: Array<{\r\n        content: string\r\n        type: string\r\n        similarity: number\r\n        created_at: string\r\n    }>\r\n    relevantProducts: Array<{\r\n        product_name: string\r\n        description: string\r\n        price: number\r\n        similarity: number\r\n    }>\r\n    contextSummary: string\r\n    relevantKnowledge: Array<{\r\n        content: string\r\n        similarity: number\r\n        metadata: any\r\n    }>\r\n}\r\n\r\n/**\r\n * Generates embedding for text using OpenAI API with caching\r\n * @param supabase Supabase client\r\n * @param text Text to generate embedding for\r\n * @param userId Optional user ID for tracking\r\n * @returns Embedding vector\r\n */\r\nasync function generateEmbedding(\r\n    supabase: SupabaseClient,\r\n    text: string,\r\n    userId?: string\r\n): Promise<number[]> {\r\n    try {\r\n        // Generate hash for cache lookup using Web Crypto API\r\n        const encoder = new TextEncoder()\r\n        const textData = encoder.encode(text)\r\n        const hashBuffer = await crypto.subtle.digest('SHA-256', textData)\r\n        const hashArray = Array.from(new Uint8Array(hashBuffer))\r\n        const textHash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('')\r\n\r\n\r\n        // Check cache first\r\n        const { data: cached } = await supabase\r\n            .from('embedding_cache')\r\n            .select('embedding')\r\n            .eq('text_hash', textHash)\r\n            .eq('model', EMBEDDING_MODEL)\r\n            .single()\r\n\r\n        if (cached?.embedding) {\r\n            // console.log(`‚úÖ [RAG] Using cached embedding`)\r\n\r\n            // Update usage stats\r\n            await supabase\r\n                .from('embedding_cache')\r\n                .update({\r\n                    last_used_at: new Date().toISOString(),\r\n                    usage_count: supabase.rpc('increment', { row_id: textHash })\r\n                })\r\n                .eq('text_hash', textHash)\r\n\r\n            return cached.embedding\r\n        }\r\n\r\n        // console.log(`üîÑ [RAG] Generating new embedding...`)\r\n\r\n        // Generate new embedding\r\n        const response = await fetch('https://api.openai.com/v1/embeddings', {\r\n            method: 'POST',\r\n            headers: {\r\n                'Authorization': `Bearer ${OPENAI_API_KEY}`,\r\n                'Content-Type': 'application/json'\r\n            },\r\n            body: JSON.stringify({\r\n                model: EMBEDDING_MODEL,\r\n                input: text\r\n            })\r\n        })\r\n\r\n        if (!response.ok) {\r\n            const error = await response.text()\r\n            throw new Error(`OpenAI API error: ${error}`)\r\n        }\r\n\r\n        const data = await response.json()\r\n        const embedding = data.data[0].embedding\r\n\r\n        // Cache the embedding\r\n        await supabase\r\n            .from('embedding_cache')\r\n            .insert({\r\n                text_hash: textHash,\r\n                text_content: text,\r\n                embedding,\r\n                model: EMBEDDING_MODEL,\r\n                user_id: userId\r\n            })\r\n            .select()\r\n\r\n        // console.log(`‚úÖ [RAG] Embedding generated and cached`)\r\n        return embedding\r\n\r\n    } catch (error) {\r\n        console.error(`‚ùå [RAG] Error generating embedding:`, error)\r\n        throw error\r\n    }\r\n}\r\n\r\n/**\r\n * Searches for relevant messages in chat history using semantic similarity\r\n * @param supabase Supabase client\r\n * @param userId User ID\r\n * @param contactId Contact ID\r\n * @param queryEmbedding Query embedding vector\r\n * @returns Relevant messages\r\n */\r\nasync function searchRelevantMessages(\r\n    supabase: SupabaseClient,\r\n    userId: string,\r\n    contactId: number,\r\n    queryEmbedding: number[]\r\n): Promise<RAGContext['relevantMessages']> {\r\n    try {\r\n        // console.log(`üîç [RAG] Searching relevant messages...`)\r\n\r\n        // Use pgvector similarity search\r\n        const { data: messages, error } = await supabase.rpc('search_similar_messages', {\r\n            query_embedding: queryEmbedding,\r\n            match_threshold: SIMILARITY_THRESHOLD,\r\n            match_count: MAX_CONTEXT_MESSAGES,\r\n            p_user_id: userId,\r\n            p_contact_id: contactId.toString()\r\n        })\r\n\r\n        if (error) {\r\n            console.error(`‚ùå [RAG] Error searching messages:`, error)\r\n            return []\r\n        }\r\n\r\n        if (!messages || messages.length === 0) {\r\n            // console.log(`‚ÑπÔ∏è [RAG] No relevant messages found`)\r\n            return []\r\n        }\r\n\r\n        // console.log(`‚úÖ [RAG] Found ${messages.length} relevant messages`)\r\n        return messages.map((msg: any) => ({\r\n            content: msg.content,\r\n            type: msg.message_type,\r\n            similarity: msg.similarity,\r\n            created_at: msg.created_at\r\n        }))\r\n\r\n    } catch (error) {\r\n        console.error(`‚ùå [RAG] Error in message search:`, error)\r\n        return []\r\n    }\r\n}\r\n\r\n/**\r\n * Searches for relevant products using semantic similarity\r\n * @param supabase Supabase client\r\n * @param userId User ID\r\n * @param queryEmbedding Query embedding vector\r\n * @returns Relevant products\r\n */\r\nasync function searchRelevantProducts(\r\n    supabase: SupabaseClient,\r\n    userId: string,\r\n    queryEmbedding: number[]\r\n): Promise<RAGContext['relevantProducts']> {\r\n    try {\r\n        // console.log(`üîç [RAG] Searching relevant products...`)\r\n\r\n        // Use pgvector similarity search on products\r\n        const { data: products, error } = await supabase.rpc('search_similar_products', {\r\n            query_embedding: queryEmbedding,\r\n            match_threshold: SIMILARITY_THRESHOLD,\r\n            match_count: MAX_PRODUCT_RESULTS,\r\n            p_user_id: userId\r\n        })\r\n\r\n        if (error) {\r\n            console.error(`‚ùå [RAG] Error searching products:`, error)\r\n            return []\r\n        }\r\n\r\n        if (!products || products.length === 0) {\r\n            // console.log(`‚ÑπÔ∏è [RAG] No relevant products found`)\r\n            return []\r\n        }\r\n\r\n        // console.log(`‚úÖ [RAG] Found ${products.length} relevant products`)\r\n        return products.map((prod: any) => ({\r\n            product_name: prod.product_name,\r\n            description: prod.description,\r\n            price: prod.price,\r\n            similarity: prod.similarity\r\n        }))\r\n\r\n    } catch (error) {\r\n        console.error(`‚ùå [RAG] Error in product search:`, error)\r\n        return []\r\n    }\r\n}\r\n\r\n/**\r\n * Searches for relevant knowledge base entries using semantic similarity\r\n * @param supabase Supabase client\r\n * @param userId User ID\r\n * @param queryEmbedding Query embedding vector\r\n * @returns Relevant knowledge entries\r\n */\r\nasync function searchKnowledgeBase(\r\n    supabase: SupabaseClient,\r\n    userId: string,\r\n    queryEmbedding: number[]\r\n): Promise<RAGContext['relevantKnowledge']> {\r\n    try {\r\n        // console.log(`üîç [RAG] Searching knowledge base for user: ${userId}`)\r\n        // console.log(`üîç [RAG] Query embedding length: ${queryEmbedding.length}`)\r\n        // console.log(`üîç [RAG] Threshold: ${SIMILARITY_THRESHOLD}, Match count: 3`)\r\n\r\n        const { data: knowledge, error } = await supabase.rpc('search_knowledge_base', {\r\n            query_embedding: queryEmbedding,\r\n            match_threshold: SIMILARITY_THRESHOLD,\r\n            match_count: 3,\r\n            p_user_id: userId\r\n        })\r\n\r\n        // console.log(`üîç [RAG] RPC call completed. Error:`, error, `Data:`, knowledge)\r\n\r\n        if (error) {\r\n            console.error(`‚ùå [RAG] RPC Error: ${error.message} (Code: ${error.code})`)\r\n            return []\r\n        }\r\n\r\n        if (!knowledge || knowledge.length === 0) {\r\n            console.log(`‚ÑπÔ∏è [RAG] No knowledge found with threshold ${SIMILARITY_THRESHOLD} for user ${userId}`)\r\n            return []\r\n        }\r\n\r\n        console.error(`üîç [RAG] Found ${knowledge.length} knowledge chunks`)\r\n        if (knowledge.length > 0) {\r\n            console.error(`üìÑ [RAG] First chunk: \"${knowledge[0]?.content?.substring(0, 100)}...\" (similarity: ${knowledge[0]?.similarity})`)\r\n        }\r\n        // console.log(`‚úÖ [RAG] Found ${knowledge.length} relevant knowledge chunks`)\r\n        // console.log(`‚úÖ [RAG] First chunk similarity: ${knowledge[0]?.similarity}`)\r\n        return knowledge.map((item: any) => ({\r\n            content: item.content,\r\n            similarity: item.similarity,\r\n            metadata: item.metadata\r\n        }))\r\n\r\n    } catch (error) {\r\n        console.error(`‚ùå [RAG] Error in knowledge base search:`, error)\r\n        return []\r\n    }\r\n}\r\n\r\n/**\r\n * Retrieves relevant context for a user message using RAG\r\n * @param supabase Supabase client\r\n * @param userId User ID\r\n * @param contactId Contact ID\r\n * @param messageText User message text\r\n * @returns RAG context with relevant messages and products\r\n */\r\nexport async function retrieveContext(\r\n    supabase: SupabaseClient,\r\n    userId: string,\r\n    contactId: number,\r\n    messageText: string\r\n): Promise<RAGContext> {\r\n    try {\r\n        // console.log(`\\nüß† [RAG] Retrieving context for message...`)\r\n\r\n        // Generate embedding for the query\r\n        const queryEmbedding = await generateEmbedding(supabase, messageText, userId)\r\n\r\n        // Search in parallel\r\n        const [relevantMessages, relevantProducts, relevantKnowledge] = await Promise.all([\r\n            searchRelevantMessages(supabase, userId, contactId, queryEmbedding),\r\n            searchRelevantProducts(supabase, userId, queryEmbedding),\r\n            searchKnowledgeBase(supabase, userId, queryEmbedding)\r\n        ])\r\n\r\n        // Build context summary\r\n        let contextSummary = ''\r\n\r\n        if (relevantMessages.length > 0) {\r\n            contextSummary += `\\n### Conversaciones Relevantes Anteriores:\\n`\r\n            relevantMessages.forEach((msg, idx) => {\r\n                contextSummary += `${idx + 1}. [${msg.type}] ${msg.content.substring(0, 150)}...\\n`\r\n            })\r\n        }\r\n\r\n        if (relevantProducts.length > 0) {\r\n            contextSummary += `\\n### Productos Relevantes:\\n`\r\n            relevantProducts.forEach((prod, idx) => {\r\n                contextSummary += `${idx + 1}. ${prod.product_name} - $${prod.price}\\n   ${prod.description.substring(0, 100)}...\\n`\r\n            })\r\n        }\r\n\r\n        if (relevantKnowledge.length > 0) {\r\n            contextSummary += `\\n### Base de Conocimiento:\\n`\r\n            relevantKnowledge.forEach((item, idx) => {\r\n                contextSummary += `${idx + 1}. ${item.content}\\n`\r\n            })\r\n        }\r\n\r\n        if (!contextSummary) {\r\n            contextSummary = 'No se encontr√≥ contexto relevante previo.'\r\n        }\r\n\r\n        // console.log(`‚úÖ [RAG] Context retrieved successfully`)\r\n        // console.log(`   - Messages: ${relevantMessages.length}`)\r\n        // console.log(`   - Products: ${relevantProducts.length}`)\r\n        // console.log(`   - Knowledge: ${relevantKnowledge.length}`)\r\n\r\n        return {\r\n            relevantMessages,\r\n            relevantProducts,\r\n            relevantKnowledge,\r\n            contextSummary\r\n        }\r\n\r\n    } catch (error) {\r\n        console.error(`‚ùå [RAG] Error retrieving context:`, error)\r\n        return {\r\n            relevantMessages: [],\r\n            relevantProducts: [],\r\n            relevantKnowledge: [],\r\n            contextSummary: 'Error al recuperar contexto.'\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Formats RAG context for inclusion in AI prompt\r\n * @param context RAG context\r\n * @returns Formatted context string\r\n */\r\nexport function formatContextForPrompt(context: RAGContext): string {\r\n    if (!context.relevantMessages.length && !context.relevantProducts.length && !context.relevantKnowledge.length) {\r\n        return ''\r\n    }\r\n\r\n    let formattedContext = '\\n\\n--- CONTEXTO RELEVANTE ---\\n'\r\n    formattedContext += context.contextSummary\r\n    formattedContext += '\\n--- FIN DEL CONTEXTO ---\\n\\n'\r\n\r\n    return formattedContext\r\n}\r\n"},{"name":"utils/supabase.ts","content":"/**\r\n * ELINA V5 - Supabase Client\r\n */\r\n\r\nimport { createClient } from 'https://esm.sh/@supabase/supabase-js@2'\r\n\r\nexport function createSupabaseAdminClient() {\r\n    const supabaseUrl = Deno.env.get('SUPABASE_URL')\r\n    const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')\r\n\r\n    if (!supabaseUrl || !supabaseServiceKey) {\r\n        throw new Error('Missing Supabase environment variables')\r\n    }\r\n\r\n    return createClient(supabaseUrl, supabaseServiceKey, {\r\n        auth: {\r\n            autoRefreshToken: false,\r\n            persistSession: false\r\n        }\r\n    })\r\n}\r\n"},{"name":"utils/text-formatter.ts","content":"/**\r\n * ELINA V5 - Text Formatter\r\n * \r\n * Formatea texto para WhatsApp con estructura clara y saltos de l√≠nea apropiados\r\n */\r\n\r\n/**\r\n * Formatea texto para que sea m√°s legible en WhatsApp\r\n * - Asegura saltos de l√≠nea apropiados\r\n * - Estructura listas y p√°rrafos\r\n * - Limpia espacios excesivos\r\n */\r\nexport function formatTextForWhatsApp(text: string): string {\r\n    if (!text) return ''\r\n\r\n    let formatted = text\r\n        // Limpiar markdown residual\r\n        .replace(/\\*\\*([^*]+)\\*\\*/g, '*$1*') // ** a *\r\n        .replace(/\\[([^\\]]+)\\]\\([^)]+\\)/g, '$1') // Links [text](url) a text\r\n\r\n        // Asegurar espacio despu√©s de puntos seguidos de letra\r\n        .replace(/\\.([A-Z√Å√â√ç√ì√ö√ë])/g, '. $1')\r\n\r\n        // üé® NUEVO: Asegurar salto de l√≠nea antes de emojis de vi√±eta (üîπ, üî∏, ‚ú®, etc.)\r\n        .replace(/([^\\n])\\s*(üîπ|üî∏|‚ú®|üì¶|üíé|‚≠ê|üéØ|üî•|üí°|üìç|üí∞|üèÜ|üéÅ|‚ö°)/g, '$1\\n$2')\r\n\r\n        // üé® NUEVO: Asegurar salto de l√≠nea despu√©s de precio (formato $XXX.XX o $XXX)\r\n        .replace(/(\\$[\\d,]+\\.?\\d*)\\s+(?=[üîπüî∏‚ú®üì¶üíé‚≠êüéØüî•üí°üìçüí∞üèÜüéÅ‚ö°¬ø?A-Z])/g, '$1\\n')\r\n\r\n        // Asegurar salto de l√≠nea despu√©s de dos puntos si sigue lista\r\n        .replace(/:(\\s*)-/g, ':\\n-')\r\n        .replace(/:(\\s*)\\d+\\./g, ':\\n$1$2.')\r\n\r\n        // Asegurar salto antes de vi√±etas si no lo hay\r\n        .replace(/([^\\n])\\n?-\\s/g, '$1\\n- ')\r\n        .replace(/([^\\n])\\n?‚Ä¢\\s/g, '$1\\n‚Ä¢ ')\r\n\r\n        // Asegurar salto antes de n√∫meros de lista\r\n        .replace(/([^\\n])\\n?(\\d+)\\.\\s/g, '$1\\n$2. ')\r\n\r\n        // üé® NUEVO: Asegurar salto antes de preguntas (¬ø...?)\r\n        .replace(/([^\\n])\\s*(¬ø[^?]+\\?)/g, '$1\\n$2')\r\n\r\n        // Limpiar espacios m√∫ltiples\r\n        .replace(/[ \\t]{2,}/g, ' ')\r\n\r\n        // Normalizar saltos de l√≠nea (m√°ximo 2 seguidos)\r\n        .replace(/\\n{3,}/g, '\\n\\n')\r\n\r\n        // Limpiar espacios al inicio/fin de l√≠neas\r\n        .split('\\n')\r\n        .map(line => line.trim())\r\n        .join('\\n')\r\n\r\n        .trim()\r\n\r\n    return formatted\r\n}\r\n\r\n/**\r\n * Distribuye texto entre m√∫ltiples items de media (como n8n)\r\n * Retorna array de objetos con media_url y caption\r\n */\r\nexport interface MediaWithCaption {\r\n    type: 'image' | 'video'\r\n    url: string\r\n    caption: string\r\n}\r\n\r\nexport function distributeTextAcrossMedia(\r\n    fullText: string,\r\n    mediaUrls: Array<{ type: 'image' | 'video', url: string }>,\r\n    maxMedia: number = 3\r\n): MediaWithCaption[] {\r\n    if (mediaUrls.length === 0) {\r\n        return []\r\n    }\r\n\r\n    // ============================================================================\r\n    // EXACT n8n V4 LOGIC: Extract URLs from text with regex, not from list\r\n    // ============================================================================\r\n\r\n    // 1. Find ALL URLs in the text using regex (like n8n V4)\r\n    const mediaRegex = /https?:\\/\\/[^\\s\"'<>]+\\.(?:png|jpg|jpeg|gif|webp|mp4)/gi\r\n    const matches = [...fullText.matchAll(mediaRegex)]\r\n\r\n    // If no URLs found in text, return empty\r\n    if (matches.length === 0) {\r\n        return []\r\n    }\r\n\r\n    // 2. Limit to max 3 media\r\n    const maxMediaCount = Math.min(matches.length, maxMedia)\r\n    const results: MediaWithCaption[] = []\r\n    let lastIndex = 0\r\n\r\n    // 3. For each URL found in text:\r\n    for (let i = 0; i < maxMediaCount; i++) {\r\n        const match = matches[i]\r\n        const url = match[0]\r\n        const isVideo = url.toLowerCase().endsWith('.mp4')\r\n\r\n        // Get text BEFORE this URL\r\n        let textBefore = fullText.substring(lastIndex, match.index)\r\n            .replace(/Imagen:\\s*$/i, \"\")  // Remove \"Imagen:\" label\r\n            .replace(/Video:\\s*$/i, \"\")   // Remove \"Video:\" label\r\n            .trim()\r\n\r\n        // CRITICAL: If this is the LAST media we're sending (e.g., 3rd)\r\n        if (i === maxMediaCount - 1) {\r\n            // Get ALL remaining text after this URL\r\n            let restOfText = fullText.substring(match.index + url.length)\r\n\r\n            // CLEAN IT: Remove any remaining URLs and labels\r\n            restOfText = restOfText\r\n                .replace(mediaRegex, \"\")           // Remove all URLs\r\n                .replace(/Imagen:\\s*/gi, \"\")       // Remove \"Imagen:\" labels\r\n                .replace(/Video:\\s*/gi, \"\")        // Remove \"Video:\" labels\r\n                .replace(/\\n{3,}/g, \"\\n\\n\")        // Clean extra newlines\r\n                .trim()\r\n\r\n            // APPEND remaining text to this caption\r\n            if (restOfText) {\r\n                textBefore = (textBefore + \"\\n\\n\" + restOfText).trim()\r\n            }\r\n        }\r\n\r\n        results.push({\r\n            type: isVideo ? 'video' : 'image',\r\n            url: url,\r\n            caption: formatTextForWhatsApp(textBefore)\r\n        })\r\n\r\n        lastIndex = match.index + url.length\r\n    }\r\n\r\n    return results\r\n}\r\n\r\n/**\r\n * EXACT n8n V4 CODE: \"IMG - Split a 3 env√≠os\"\r\n * Splits text with media URLs into multiple messages (max 3)\r\n * Each message has a media_url and its corresponding caption\r\n */\r\nexport interface MediaMessage {\r\n    type: 'image' | 'video' | 'text'\r\n    media_url: string\r\n    url_imagen?: string\r\n    caption: string\r\n    'mensaje texto '?: string\r\n}\r\n\r\nexport function splitMediaIntoMessages(\r\n    textoCompleto: string,\r\n    mediaType: 'image' | 'video' = 'image'\r\n): MediaMessage[] {\r\n    // REGEX EXACTO de n8n V4\r\n    const mediaRegex = /https?:\\/\\/[^\\s\"'<>]+\\.(?:png|jpg|jpeg|gif|webp|mp4)/gi\r\n    const matches = [...textoCompleto.matchAll(mediaRegex)]\r\n\r\n    // Si no hay multimedia, enviamos el texto tal cual\r\n    if (matches.length === 0) {\r\n        return [{\r\n            type: 'text',\r\n            media_url: '',\r\n            caption: textoCompleto,\r\n            'mensaje texto ': textoCompleto\r\n        }]\r\n    }\r\n\r\n    const results: MediaMessage[] = []\r\n    let lastIndex = 0\r\n    const maxMedia = Math.min(matches.length, 3)\r\n\r\n    for (let i = 0; i < maxMedia; i++) {\r\n        const match = matches[i]\r\n        const url = match[0]\r\n        const isVideo = url.toLowerCase().endsWith('.mp4')\r\n\r\n        // Extraemos el texto previo a la imagen actual y limpiamos etiquetas\r\n        let textBefore = textoCompleto.substring(lastIndex, match.index)\r\n            .replace(/Imagen:\\s*$/i, \"\") // Quitar \"Imagen:\" si est√° justo antes\r\n            .trim()\r\n\r\n        // Si es la √∫ltima imagen que vamos a mandar (ej. la 3¬™)\r\n        if (i === maxMedia - 1) {\r\n            // Tomamos el resto del mensaje que queda despu√©s de esta URL\r\n            let restOfText = textoCompleto.substring(match.index + url.length)\r\n\r\n            // LIMPIEZA CR√çTICA: Borramos CUALQUIER otra URL de imagen/video que haya sobrado\r\n            // Tambi√©n limpiamos las palabras \"Imagen:\" residuales que queden solas\r\n            restOfText = restOfText\r\n                .replace(mediaRegex, \"\")\r\n                .replace(/Imagen:\\s*/gi, \"\")\r\n                .replace(/\\n{3,}/g, \"\\n\\n\") // Evitar demasiados saltos de l√≠nea vac√≠os\r\n                .trim()\r\n\r\n            if (restOfText) {\r\n                textBefore = (textBefore + \"\\n\\n\" + restOfText).trim()\r\n            }\r\n        }\r\n\r\n        results.push({\r\n            type: isVideo ? 'video' : 'image',\r\n            media_url: url,\r\n            url_imagen: url,\r\n            caption: textBefore,\r\n            'mensaje texto ': textBefore\r\n        })\r\n\r\n        lastIndex = match.index + url.length\r\n    }\r\n\r\n    return results\r\n}\r\n\r\n"},{"name":"utils/tool-executor.ts","content":"/**\r\n * ELINA V5 - Tool Executor\r\n * \r\n * Ejecuta las llamadas a herramientas (tool calls) del LLM\r\n */\r\n\r\nimport type { SupabaseClient } from 'https://esm.sh/@supabase/supabase-js@2'\r\nimport type { AccountConfig, ToolCall, ToolResult } from '../config/types.ts'\r\nimport { buscarProductos, agendarCita, consultarDisponibilidad } from './tools.ts'\r\n\r\n/**\r\n * Ejecuta una lista de tool calls y devuelve los resultados\r\n */\r\nexport async function executeToolCalls(\r\n    supabase: SupabaseClient,\r\n    config: AccountConfig,\r\n    contactId: number,\r\n    toolCalls: ToolCall[],\r\n    conversationState?: any,  // ‚Üê Par√°metro para estado conversacional\r\n    userMessage?: string      // ‚Üê Nuevo: mensaje original del usuario para detecci√≥n inteligente\r\n): Promise<ToolResult[]> {\r\n    console.log(`üîß [TOOLS] Executing ${toolCalls.length} tool call(s)`)\r\n\r\n    const results: ToolResult[] = []\r\n\r\n    for (const toolCall of toolCalls) {\r\n        const functionName = toolCall.function.name\r\n        const functionArgs = JSON.parse(toolCall.function.arguments)\r\n\r\n        console.log(`   - Calling: ${functionName}`, functionArgs)\r\n\r\n        try {\r\n            let result: any\r\n\r\n            switch (functionName) {\r\n                case 'buscar_productos':\r\n                    const searchResult = await buscarProductos(\r\n                        supabase,\r\n                        config.userId,\r\n                        functionArgs.query,\r\n                        functionArgs.limit || 5,\r\n                        userMessage // ‚Üê Pasar mensaje original para detecci√≥n autom√°tica\r\n                    )\r\n\r\n                    // Handle new structured response format\r\n                    if (searchResult.status === 'ERROR' || searchResult.status === 'NOT_FOUND') {\r\n                        result = {\r\n                            status: searchResult.status,\r\n                            message: searchResult.message,\r\n                            products: []\r\n                        }\r\n                    } else {\r\n                        // SUCCESS case - combine exact matches and alternatives\r\n                        const allProducts = [\r\n                            ...(searchResult.exact_matches || []),\r\n                            ...(searchResult.suggested_alternatives || [])\r\n                        ]\r\n\r\n                        // Separate services for special formatting\r\n                        const services = allProducts.filter(p => p.product_type === 'service')\r\n                        const physicalProducts = allProducts.filter(p => p.product_type !== 'service')\r\n\r\n                        result = {\r\n                            status: searchResult.status,\r\n                            message: searchResult.message,\r\n                            exact_match_found: searchResult.exact_match_found,\r\n                            has_alternatives: searchResult.has_alternatives,\r\n                            products: allProducts,\r\n                            services: services,  // Store for code-based formatting\r\n                            physicalProducts: physicalProducts,\r\n                            // Pass formatting hints to agent\r\n                            formatting_hint: searchResult.exact_matches?.map(p => p.formatting_hint).join('\\n') || ''\r\n                        }\r\n                    }\r\n                    break\r\n\r\n                    break\r\n\r\n                case 'consultar_disponibilidad':\r\n                    result = await consultarDisponibilidad(\r\n                        supabase,\r\n                        config.userId,\r\n                        functionArgs.date,\r\n                        config.slug // Pasar el slug para generar link\r\n                    )\r\n                    break\r\n\r\n                case 'agendar_cita':\r\n                    result = await agendarCita(\r\n                        supabase,\r\n                        config.userId,\r\n                        contactId,\r\n                        functionArgs.date,\r\n                        functionArgs.time,\r\n                        functionArgs.service_id,\r\n                        functionArgs.notes,\r\n                        conversationState  // ‚Üê Pasar el estado\r\n                    )\r\n                    break\r\n\r\n                case 'consultar_mis_citas':\r\n                    const { consultarMisCitas } = await import('./tools.ts')\r\n                    result = await consultarMisCitas(\r\n                        supabase,\r\n                        config.userId,\r\n                        contactId\r\n                    )\r\n                    break\r\n\r\n                case 'modificar_cita':\r\n                    const { modificarCita } = await import('./tools.ts')\r\n                    result = await modificarCita(\r\n                        supabase,\r\n                        config.userId,\r\n                        contactId,\r\n                        functionArgs.appointment_id,\r\n                        functionArgs.new_date,\r\n                        functionArgs.new_time\r\n                    )\r\n                    break\r\n\r\n                case 'consultar_promociones':\r\n                    const { consultarPromociones } = await import('./tools.ts')\r\n                    result = await consultarPromociones(\r\n                        supabase,\r\n                        config.userId\r\n                    )\r\n                    break\r\n\r\n                default:\r\n                    console.warn(`‚ö†Ô∏è [TOOLS] Unknown tool: ${functionName}`)\r\n                    result = { error: `Unknown tool: ${functionName}` }\r\n            }\r\n\r\n            results.push({\r\n                tool_call_id: toolCall.id,\r\n                role: 'tool',\r\n                name: functionName,\r\n                content: JSON.stringify(result)\r\n            })\r\n\r\n            console.log(`   ‚úÖ ${functionName} completed`)\r\n\r\n        } catch (error) {\r\n            console.error(`   ‚ùå Error executing ${functionName}:`, error)\r\n            results.push({\r\n                tool_call_id: toolCall.id,\r\n                role: 'tool',\r\n                name: functionName,\r\n                content: JSON.stringify({\r\n                    error: error instanceof Error ? error.message : String(error)\r\n                })\r\n            })\r\n        }\r\n    }\r\n\r\n    return results\r\n}\r\n"},{"name":"utils/tools.ts","content":"/**\r\n * ELINA V5 - Tools Implementation\r\n * \r\n * Implementaci√≥n de las herramientas disponibles para el agente\r\n */\r\n\r\nimport type { SupabaseClient } from 'https://esm.sh/@supabase/supabase-js@2'\r\n\r\n/**\r\n * Genera respuesta de proceso de compra usando LLM con datos disponibles\r\n */\r\nasync function generatePurchaseResponse(\r\n    companyName: string,\r\n    contactData: string\r\n): Promise<string> {\r\n    try {\r\n        const prompt = `Genera una respuesta BREVE (m√°ximo 2-3 l√≠neas) sobre c√≥mo un cliente puede contratar/comprar.\r\n\r\nEmpresa: ${companyName}\r\nCanales disponibles:\r\n${contactData}\r\n\r\nREGLAS CR√çTICAS:\r\n1. M√°ximo 2-3 l√≠neas\r\n2. Incluye SOLO los canales mencionados arriba\r\n3. Tono amigable para WhatsApp\r\n4. NO inventes canales que no existen\r\n5. Formato simple, sin markdown complejo`\r\n\r\n        const response = await fetch('https://api.openai.com/v1/chat/completions', {\r\n            method: 'POST',\r\n            headers: {\r\n                'Authorization': `Bearer ${Deno.env.get('OPENAI_API_KEY')}`,\r\n                'Content-Type': 'application/json'\r\n            },\r\n            body: JSON.stringify({\r\n                model: 'gpt-4o-mini',\r\n                messages: [{ role: 'user', content: prompt }],\r\n                temperature: 0.7,\r\n                max_tokens: 100\r\n            })\r\n        })\r\n\r\n        if (!response.ok) throw new Error('LLM failed')\r\n\r\n        const data = await response.json()\r\n        return data.choices[0]?.message?.content?.trim() || `Cont√°ctanos:\\n${contactData}`\r\n\r\n    } catch (error) {\r\n        console.error('‚ùå [TOOL] Error generating response:', error)\r\n        return `Puedes contactarnos:\\n${contactData}`\r\n    }\r\n}\r\n\r\n/**\r\n * Sistema de cascada inteligente para obtener info de proceso de compra\r\n * Nivel 1: B√∫squeda sem√°ntica en FAQs (RAG)\r\n * Nivel 2: Generaci√≥n din√°mica con LLM usando datos del perfil\r\n * Nivel 3: Formato simple de datos disponibles\r\n * Nivel 4: Mensaje gen√©rico profesional\r\n */\r\nasync function fetchPurchaseProcessInfo(\r\n    supabase: SupabaseClient,\r\n    userId: string\r\n): Promise<string | null> {\r\n    try {\r\n        // NIVEL 1: B√∫squeda sem√°ntica en knowledge_base usando RAG\r\n        console.log(`üîç [PURCHASE_INFO] Nivel 1: Buscando en FAQs con RAG...`)\r\n\r\n        const { retrieveContext } = await import('./rag-system.ts')\r\n        const purchaseQuery = \"¬øC√≥mo puedo contratar, comprar o adquirir este producto o servicio? ¬øD√≥nde lo compro?\"\r\n\r\n        const ragContext = await retrieveContext(supabase, userId, 0, purchaseQuery)\r\n\r\n        if (ragContext.relevantKnowledge && ragContext.relevantKnowledge.length > 0) {\r\n            const topMatch = ragContext.relevantKnowledge[0]\r\n            // Umbral de confianza: 0.35 es suficientemente similar\r\n            if (topMatch.similarity >= 0.35) {\r\n                console.log(`‚úÖ [PURCHASE_INFO] FAQ encontrada (similarity: ${topMatch.similarity})`)\r\n                return `\\n\\nüìã **INFORMACI√ìN IMPORTANTE:**\\n${topMatch.content}`\r\n            }\r\n            console.log(`‚ö†Ô∏è [PURCHASE_INFO] FAQ similarity baja (${topMatch.similarity}), continuando...`)\r\n        }\r\n\r\n        // NIVEL 2: No hay FAQs relevantes - Buscar datos del perfil\r\n        console.log(`üîç [PURCHASE_INFO] Nivel 2: Obteniendo datos del perfil...`)\r\n\r\n        const { data: profile } = await supabase\r\n            .from('profiles')\r\n            .select('website, business_phone, business_address, social_media, company_name')\r\n            .eq('id', userId)\r\n            .single()\r\n\r\n        if (!profile) {\r\n            console.log(`‚ö†Ô∏è [PURCHASE_INFO] No se encontr√≥ perfil`)\r\n            return null\r\n        }\r\n\r\n        // Construir informaci√≥n de contacto disponible\r\n        const contactChannels: string[] = []\r\n        if (profile.website) contactChannels.push(`üåê Sitio web: ${profile.website}`)\r\n        if (profile.business_phone) contactChannels.push(`üìû Tel√©fono: ${profile.business_phone}`)\r\n        if (profile.business_address) contactChannels.push(`üìç Direcci√≥n: ${profile.business_address}`)\r\n        if (profile.social_media?.whatsapp) contactChannels.push(`üí¨ WhatsApp: ${profile.social_media.whatsapp}`)\r\n        if (profile.social_media?.instagram) contactChannels.push(`üì± Instagram: @${profile.social_media.instagram}`)\r\n        if (profile.social_media?.facebook) contactChannels.push(`üë• Facebook: ${profile.social_media.facebook}`)\r\n\r\n        if (contactChannels.length === 0) {\r\n            // NIVEL 4: No hay datos - Mensaje gen√©rico profesional\r\n            console.log(`‚ö†Ô∏è [PURCHASE_INFO] Nivel 4: Sin datos de contacto, mensaje gen√©rico`)\r\n            return '\\n\\nüìã Cont√°ctanos directamente para m√°s informaci√≥n sobre c√≥mo adquirir este producto o servicio.'\r\n        }\r\n\r\n        // NIVEL 2B: Generar respuesta inteligente con LLM\r\n        console.log(`ü§ñ [PURCHASE_INFO] Nivel 2B: Generando respuesta con LLM...`)\r\n        const contactData = contactChannels.join('\\n')\r\n        const companyName = profile.company_name || 'nuestra empresa'\r\n\r\n        const generatedResponse = await generatePurchaseResponse(companyName, contactData)\r\n        console.log(`‚úÖ [PURCHASE_INFO] Respuesta generada exitosamente`)\r\n\r\n        return `\\n\\nüìã **INFORMACI√ìN IMPORTANTE:**\\n${generatedResponse}`\r\n\r\n    } catch (error) {\r\n        console.error(`‚ùå [TOOL] Error fetching purchase info:`, error)\r\n        // NIVEL 3: Fallback en caso de error\r\n        return '\\n\\nüìã Para adquirir este producto, cont√°ctanos directamente.'\r\n    }\r\n}\r\n\r\n/**\r\n * Busca productos por query\r\n */\r\nexport async function buscarProductos(\r\n    supabase: SupabaseClient,\r\n    userId: string,\r\n    query: string,\r\n    limit: number = 5,\r\n    originalMessage?: string // Nuevo par√°metro para detectar intent de compra\r\n): Promise<any> {\r\n    console.log(`üîç [TOOL] Searching products: \"${query}\"`)\r\n\r\n    // Normalizaci√≥n de queries gen√©ricos (con posibles typos o caracteres extra)\r\n    // Si el usuario pone \"que vendes_\", \"catalogo\", \"lista\", lo tratamos como vac√≠o para mostrar todo.\r\n    const genericKeywords = ['que vendes', 'qu√© vendes', 'que tienes', 'qu√© tienes', 'catalogo', 'cat√°logo', 'productos', 'lista', 'precio', 'precios']\r\n    const normalizedQuery = query.toLowerCase().replace(/[^\\w\\s√±√°√©√≠√≥√∫]/g, '').trim() // Quitar caracteres raros como \"_\"\r\n\r\n    // Detectar si el usuario pregunta espec√≠ficamente por SERVICIOS\r\n    const serviceKeywords = ['servicio', 'servicios', 'cita', 'citas', 'que servicios', 'qu√© servicios']\r\n    const isAskingForServices = serviceKeywords.some(k => normalizedQuery.includes(k))\r\n\r\n    let effectiveQuery = query\r\n    if (genericKeywords.some(k => normalizedQuery.includes(k)) || normalizedQuery.length < 3 || isAskingForServices) {\r\n        effectiveQuery = '' // Forzar modo \"ver todo\" para keywords gen√©ricos O servicios\r\n    }\r\n\r\n    // CASO 1: Query vac√≠o -> Mostrar cat√°logo general (sin clasificar)\r\n    if (!effectiveQuery || effectiveQuery.trim() === '') {\r\n        // Si pregunta por servicios, filtrar solo servicios\r\n        if (isAskingForServices) {\r\n            const { data, error } = await supabase\r\n                .from('products')\r\n                .select('id, product_name, sku, price, stock, description, media_url, product_type, benefits, usage_instructions, faq')\r\n                .eq('user_id', userId)\r\n                .eq('product_type', 'service')\r\n                .order('created_at', { ascending: false })\r\n                .limit(limit)\r\n\r\n            if (error) {\r\n                console.error(`‚ùå [TOOL] Error fetching services:`, error)\r\n                return { status: \"ERROR\", message: \"Error consultando servicios.\" }\r\n            }\r\n\r\n            return {\r\n                status: \"SUCCESS\",\r\n                message: \"Aqu√≠ est√°n los servicios disponibles.\",\r\n                exact_match_found: true,\r\n                exact_matches: data?.map(p => {\r\n                    const benefits = p.benefits ? `\\n‚ú® Benefits: ${p.benefits}` : '';\r\n                    const usage = p.usage_instructions ? `\\nüìù Usage: ${p.usage_instructions}` : '';\r\n                    const faqContent = p.faq?.content ? `\\n‚ùì FAQ: ${p.faq.content}` : '';\r\n                    return {\r\n                        ...p,\r\n                        formatting_hint: `üõçÔ∏è *${p.product_name}* ‚Äî $${p.price}\\nüîπ ${p.description || ''}${benefits}${usage}${faqContent}\\n\\n`\r\n                    }\r\n                }) || [],\r\n                has_alternatives: false,\r\n                suggested_alternatives: []\r\n            }\r\n        } else {\r\n            // Modo MIXTO: Traer productos y servicios por separado para mostrar variedad\r\n            // 1. Productos F√≠sicos\r\n            const { data: products } = await supabase\r\n                .from('products')\r\n                .select('id, product_name, sku, price, stock, description, media_url, product_type, benefits, usage_instructions, faq')\r\n                .eq('user_id', userId)\r\n                .neq('product_type', 'service') // Excluir servicios\r\n                .order('created_at', { ascending: false })\r\n                .limit(3)\r\n\r\n            // 2. Servicios\r\n            const { data: services } = await supabase\r\n                .from('products')\r\n                .select('id, product_name, sku, price, stock, description, media_url, product_type, benefits, usage_instructions, faq')\r\n                .eq('user_id', userId)\r\n                .eq('product_type', 'service') // Solo servicios\r\n                .order('created_at', { ascending: false })\r\n                .limit(3)\r\n\r\n            const mixedData = [...(products || []), ...(services || [])]\r\n\r\n            return {\r\n                status: \"SUCCESS\",\r\n                message: \"Aqu√≠ tienes una selecci√≥n de nuestros productos y servicios.\",\r\n                exact_match_found: true,\r\n                exact_matches: mixedData.map(p => {\r\n                    const benefits = p.benefits ? `\\n‚ú® Benefits: ${p.benefits}` : '';\r\n                    const usage = p.usage_instructions ? `\\nüìù Usage: ${p.usage_instructions}` : '';\r\n                    const faqContent = p.faq?.content ? `\\n‚ùì FAQ: ${p.faq.content}` : '';\r\n\r\n                    return {\r\n                        ...p,\r\n                        formatting_hint: p.product_type === 'service'\r\n                            ? `üõçÔ∏è *${p.product_name}* ‚Äî $${p.price}\\nüîπ ${p.description || ''}${benefits}${usage}${faqContent}\\n\\n`\r\n                            : `üõçÔ∏è *${p.product_name}* ‚Äî $${p.price}\\nüîπ ${p.description || ''}\\n\\n` // Use same format for physical products\r\n                    }\r\n                }),\r\n                has_alternatives: false,\r\n                suggested_alternatives: []\r\n            }\r\n        }\r\n    }\r\n\r\n    // CASO 2: B√∫squeda Vectorial / Fulltext\r\n    const { data, error } = await supabase.rpc('search_products_fulltext', {\r\n        p_user_id: userId,\r\n        p_query: effectiveQuery, // Usar la query normalizada/efectiva\r\n        p_limit: limit\r\n    })\r\n\r\n    if (error) {\r\n        console.error(`‚ùå [TOOL] Error searching products:`, error)\r\n        return { status: \"ERROR\", message: \"Error en la b√∫squeda.\" }\r\n    }\r\n\r\n    const results = data || []\r\n\r\n    // Clasificaci√≥n por fidelidad (L√≥gica Proactiva de n8n)\r\n    const highConfidence = results\r\n\r\n    if (highConfidence.length === 0) {\r\n        // üìä Log b√∫squeda fallida para analytics (non-blocking)\r\n        supabase.from('product_search_misses').insert({\r\n            user_id: userId,\r\n            query: query,\r\n            original_message: originalMessage,\r\n            timestamp: new Date().toISOString()\r\n        }).then(() => {\r\n            console.log(`üìä [ANALYTICS] Search miss logged: \"${query}\"`)\r\n        }).catch((err: any) => {\r\n            console.error(`‚ùå [ANALYTICS] Failed to log search miss:`, err)\r\n        })\r\n\r\n        return {\r\n            status: \"NOT_FOUND\",\r\n            message: `No encontr√© productos que coincidan con '${query}'.`\r\n        }\r\n    }\r\n\r\n    // üéØ DETECCI√ìN AUTOM√ÅTICA: Si el mensaje original contiene palabras de compra/contrataci√≥n\r\n    // autom√°ticamente buscamos y agregamos info del proceso de compra\r\n    let purchaseInfo = null\r\n    if (originalMessage) {\r\n        const purchaseKeywords = ['contratar', 'comprar', 'adquirir', 'obtener', 'conseguir', 'me ayuda']\r\n        const hasPurchaseIntent = purchaseKeywords.some(kw =>\r\n            originalMessage.toLowerCase().includes(kw)\r\n        )\r\n\r\n        if (hasPurchaseIntent) {\r\n            console.log(`üõí [TOOL] Purchase intent detected, fetching process info...`)\r\n            purchaseInfo = await fetchPurchaseProcessInfo(supabase, userId)\r\n            if (purchaseInfo) {\r\n                console.log(`‚úÖ [TOOL] Purchase process info added automatically`)\r\n            }\r\n        }\r\n    }\r\n\r\n    // Estructura \"Anti-Alucinaci√≥n\" con Urgencia/Escasez\r\n    const result: any = {\r\n        status: \"SUCCESS\",\r\n        message: `Encontr√© ${highConfidence.length} coincidencias para '${query}'.`,\r\n        exact_match_found: highConfidence.length > 0,\r\n        exact_matches: highConfidence.map(r => {\r\n            let urgencyNote = ''\r\n\r\n            // üî• URGENCIA: Stock bajo (√∫ltimas unidades)\r\n            if (r.stock !== null && r.stock > 0 && r.stock <= 5) {\r\n                urgencyNote = `\\n‚ö†Ô∏è ¬°√öltimas ${r.stock} unidades disponibles!`\r\n            }\r\n\r\n            // üî• URGENCIA: Sin stock (agotado)\r\n            if (r.stock !== null && r.stock === 0) {\r\n                urgencyNote = `\\n‚ùå Agotado temporalmente`\r\n            }\r\n\r\n            return {\r\n                id: r.id,\r\n                name: r.product_name,\r\n                price: r.price,\r\n                stock: r.stock,\r\n                description: r.description,\r\n                media_url: r.media_url, // ‚úÖ ADDED: Include media_url for automatic media sending\r\n                enhanced_description: r.enhanced_description,\r\n                faq: r.faq,\r\n                benefits: r.benefits,\r\n                usage_instructions: r.usage_instructions,\r\n                formatting_hint: `üõçÔ∏è *${r.product_name}* ‚Äî $${r.price}${urgencyNote}\\nüîπ ${r.description || ''}\\n\\n`\r\n            }\r\n        }),\r\n        has_alternatives: false,\r\n        suggested_alternatives: []\r\n    }\r\n\r\n    // Si encontramos info de proceso de compra, agregarla al resultado\r\n    if (purchaseInfo) {\r\n        result.purchase_process_info = purchaseInfo\r\n        result.message += ' ' + purchaseInfo\r\n    }\r\n\r\n    return result\r\n}\r\n\r\n/**\r\n * Consulta disponibilidad de citas\r\n */\r\nexport async function consultarDisponibilidad(\r\n    supabase: SupabaseClient,\r\n    userId: string,\r\n    date?: string,\r\n    slug?: string // Propiedad opcional para link\r\n): Promise<any> {\r\n    console.log(`üìÖ [TOOL] Checking availability for date: ${date || 'next 7 days'}`)\r\n\r\n    const { getAvailableSlots, formatAppointmentContext } = await import('./appointment-manager.ts')\r\n    const slots = await getAvailableSlots(userId, 7)\r\n\r\n    return {\r\n        available: slots.length > 0,\r\n        // Proporcionar contexto formateado para que el LLM lo use directamente\r\n        formatted_response: formatAppointmentContext(slots, slug),\r\n        // Mantener slots crudos por si el LLM necesita datos estructurados precisos\r\n        raw_slots: slots.map(slot => ({\r\n            start_time: slot.start_time,\r\n            service_name: slot.service_name,\r\n            duration_minutes: slot.duration_minutes\r\n        }))\r\n    }\r\n}\r\n\r\n/**\r\n * Agenda una cita\r\n */\r\nexport async function agendarCita(\r\n    supabase: SupabaseClient,\r\n    userId: string,\r\n    contactId: number,\r\n    date: string,\r\n    time: string,\r\n    serviceId?: number,\r\n    notes?: string,\r\n    conversationState?: any  // ‚Üê Nuevo par√°metro para acceder al estado\r\n): Promise<any> {\r\n    console.log(`üìÖ [TOOL] Creating appointment...`)\r\n\r\n    // Si no se proporciona serviceId, intentar detectarlo del contexto\r\n    let finalServiceId = serviceId\r\n\r\n    if (!finalServiceId) {\r\n        console.log(`üîç [TOOL] No service_id provided, searching conversation context...`)\r\n\r\n        // 1. Revisar si hay un servicio en el estado de conversaci√≥n\r\n        if (conversationState?.potentialService?.id) {\r\n            finalServiceId = conversationState.potentialService.id\r\n            console.log(`‚úÖ [TOOL] Found service in conversation state: ${conversationState.potentialService.name} (${finalServiceId})`)\r\n        }\r\n\r\n        // 2. Si no hay en el estado, buscar en mensajes recientes (√∫ltimas 24h)\r\n        if (!finalServiceId) {\r\n            const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString()\r\n            const { data: recentMessages } = await supabase\r\n                .from('chat_history')\r\n                .select('message_text')\r\n                .eq('contact_id', contactId)\r\n                .gt('created_at', oneDayAgo)\r\n                .order('created_at', { ascending: false })\r\n                .limit(10)\r\n\r\n            if (recentMessages && recentMessages.length > 0) {\r\n                // Buscar menciones de servicios en los mensajes\r\n                const { data: services } = await supabase\r\n                    .from('products')\r\n                    .select('id, product_name')\r\n                    .eq('user_id', userId)\r\n                    .eq('product_type', 'service')\r\n\r\n                if (services) {\r\n                    // Buscar si alg√∫n servicio fue mencionado\r\n                    for (const service of services) {\r\n                        const serviceName = service.product_name.toLowerCase()\r\n                        const mentioned = recentMessages.some(msg =>\r\n                            msg.message_text?.toLowerCase().includes(serviceName)\r\n                        )\r\n                        if (mentioned) {\r\n                            finalServiceId = service.id\r\n                            console.log(`‚úÖ [TOOL] Found service mentioned in history: ${service.product_name} (${finalServiceId})`)\r\n                            break\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // 3. Si a√∫n no hay, usar el primer servicio disponible\r\n        if (!finalServiceId) {\r\n            console.log(`üîç [TOOL] No service found in context, fetching default service...`)\r\n            const { data: services } = await supabase\r\n                .from('products')\r\n                .select('id')\r\n                .eq('user_id', userId)\r\n                .eq('product_type', 'service')\r\n                .limit(1)\r\n                .single()\r\n\r\n            if (services) {\r\n                finalServiceId = services.id\r\n                console.log(`‚úÖ [TOOL] Using default service: ${finalServiceId}`)\r\n            } else {\r\n                return {\r\n                    success: false,\r\n                    error: 'No hay servicios disponibles para agendar'\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Combinar fecha y hora en ISO 8601\r\n    // IMPORTANTE: La fecha y hora que recibimos (ej: \"2026-02-12\", \"15:00\")\r\n    // son en la ZONA HORARIA DEL USUARIO/EMPRESA.\r\n    // Supabase espera UTC. Debemos convertir.\r\n\r\n    // 1. Obtener configuraci√≥n para saber timezone\r\n    const { getAppointmentSettings } = await import('./appointment-manager.ts')\r\n    const settings = await getAppointmentSettings(supabase, userId)\r\n    const timezone = settings?.working_hours?.timezone || 'America/Mexico_City'\r\n\r\n    // 2. Crear fecha en esa zona horaria\r\n    // \"2026-02-12T15:00:00\" -> Interpretar como hora CDMX\r\n    // NOTA: Deno deploy no siempre tiene feriados o timezones complejos nativos,\r\n    // pero podemos usar un hack simple si asumimos offsets fijos o usamos una librer√≠a si est√° disponible.\r\n    // Por ahora, asumiremos que el servidor corre en UTC y haremos el offset manual\r\n    // para America/Mexico_City (UTC-6 en invierno, UTC-5 en verano - aunque MX ya no cambia horario en la mayor√≠a)\r\n    // Asumiremos UTC-6 fijo para CDMX por simplicidad si no hay librer√≠a, \r\n    // PERO lo ideal es dejar que la base de datos maneje la inserci√≥n si pudi√©ramos pasar \"AT TOP TIME ZONE\".\r\n    // \r\n    // Mejor enfoque: Construir la fecha con el offset expl√≠cito.\r\n    // CDMX es UTC-6.\r\n\r\n    const targetTime = new Date(`${date}T${time}:00`)\r\n    // Asumiendo que targetTime se cre√≥ en UTC (por defecto en Deno Deploy)\r\n    // Le sumamos 6 horas para \"cancelar\" el hecho de que era local y convertirlo a UTC real\r\n    // Ejemplo: Usuario quiere 15:00 CDMX.\r\n    // UTC equivalente: 21:00 UTC.\r\n    // new Date(\"2026-02-12T15:00:00\") -> crea 15:00 UTC (incorrecto, esto ser√≠a 9:00 AM CDMX)\r\n    // Queremos enviar 21:00 UTC.\r\n\r\n    // Soluci√≥n robusta sin librer√≠as externas pesadas:\r\n    // Usar el offset manual temporalmente.\r\n    const offsetHours = 6 // UTC-6 para M√©xico Central (Est√°ndar)\r\n    const utcDate = new Date(targetTime.getTime() + (offsetHours * 60 * 60 * 1000))\r\n    const startTime = utcDate.toISOString()\r\n\r\n    console.log(`‚è∞ [TOOL] Time conversion:`)\r\n    console.log(`   Input (Local): ${date} ${time}`)\r\n    console.log(`   Timezone: ${timezone} (Assuming UTC-6)`)\r\n    console.log(`   Output (UTC): ${startTime}`)\r\n\r\n    const { createAppointment } = await import('./appointment-manager.ts')\r\n    const { sendMessage } = await import('./evolution.ts')\r\n\r\n    // Obtener tel√©fono del contacto\r\n    const { data: contact } = await supabase\r\n        .from('contacts')\r\n        .select('phone_number')\r\n        .eq('id', contactId)\r\n        .single()\r\n\r\n    if (!contact) {\r\n        throw new Error('Contact not found')\r\n    }\r\n\r\n    // Crear funci√≥n de env√≠o de mensajes\r\n    const sendMessageFn = async (remoteJid: string, text: string) => {\r\n        // Esta funci√≥n ser√° proporcionada por el contexto\r\n        console.log(`üì§ [TOOL] Would send message to ${remoteJid}`)\r\n    }\r\n\r\n    const result = await createAppointment(\r\n        supabase,\r\n        {\r\n            userId,\r\n            contactId,\r\n            serviceId: finalServiceId!, // Non-null assertion: ya verificamos arriba\r\n            startTime,\r\n            notes\r\n        },\r\n        sendMessageFn,\r\n        contact.phone_number\r\n    )\r\n\r\n\r\n    return result\r\n}\r\n\r\n/**\r\n * Consulta las citas del usuario\r\n */\r\nexport async function consultarMisCitas(\r\n    supabase: SupabaseClient,\r\n    userId: string,\r\n    contactId: number\r\n): Promise<any> {\r\n    console.log(`üìÖ [TOOL] Fetching appointments for contact ${contactId}`)\r\n\r\n    const now = new Date().toISOString()\r\n\r\n    const { data: appointments, error } = await supabase\r\n        .from('meetings')\r\n        .select(`\r\n            id,\r\n            start_time,\r\n            end_time,\r\n            status,\r\n            notes,\r\n            summary,\r\n            products:product_id (\r\n                product_name,\r\n                service_duration_minutes\r\n            )\r\n        `)\r\n        .eq('user_id', userId)\r\n        .eq('contact_id', contactId)\r\n        .gte('start_time', now)  // Solo citas futuras\r\n        .order('start_time', { ascending: true })\r\n        .limit(10)\r\n\r\n    if (error) {\r\n        console.error(`‚ùå [TOOL] Error fetching appointments:`, error)\r\n        return {\r\n            success: false,\r\n            error: error.message\r\n        }\r\n    }\r\n\r\n    if (!appointments || appointments.length === 0) {\r\n        return {\r\n            success: true,\r\n            appointments: [],\r\n            message: 'No tienes citas programadas'\r\n        }\r\n    }\r\n\r\n    console.log(`‚úÖ [TOOL] Found ${appointments.length} appointment(s)`)\r\n\r\n    return {\r\n        success: true,\r\n        appointments: appointments.map(apt => {\r\n            const date = new Date(apt.start_time)\r\n            const formattedTime = date.toLocaleString('es-MX', {\r\n                timeZone: 'America/Mexico_City',\r\n                weekday: 'long',\r\n                year: 'numeric',\r\n                month: 'long',\r\n                day: 'numeric',\r\n                hour: '2-digit',\r\n                minute: '2-digit',\r\n                hour12: true\r\n            })\r\n\r\n            return {\r\n                id: apt.id,\r\n                serviceName: apt.products?.product_name || 'Servicio',\r\n                startTime: apt.start_time, // Keep ISO for debugging\r\n                formattedTime: formattedTime, // For LLM to read correct local time\r\n                endTime: apt.end_time,\r\n                status: apt.status,\r\n                notes: apt.notes,\r\n                isAIBooked: apt.summary === 'Cita Agendada por IA'\r\n            }\r\n        })\r\n    }\r\n}\r\n\r\n/**\r\n * Modifica/reprograma una cita existente\r\n */\r\nexport async function modificarCita(\r\n    supabase: SupabaseClient,\r\n    userId: string,\r\n    contactId: number,\r\n    appointmentId: number,\r\n    newDate?: string,\r\n    newTime?: string\r\n): Promise<any> {\r\n    const id = Number(appointmentId)\r\n    console.log(`üìÖ [TOOL] Modifying appointment #${id}`)\r\n\r\n    // Obtener la cita actual\r\n    const { data: currentAppointment, error: fetchError } = await supabase\r\n        .from('meetings')\r\n        .select('*, products:product_id(service_duration_minutes)')\r\n        .eq('id', id)\r\n        .eq('user_id', userId)\r\n        .eq('contact_id', contactId)\r\n        .single()\r\n\r\n    if (fetchError || !currentAppointment) {\r\n        console.error(`‚ùå [TOOL] Appointment not found:`, fetchError)\r\n        return {\r\n            success: false,\r\n            error: 'No se encontr√≥ la cita'\r\n        }\r\n    }\r\n\r\n    // Calcular nuevo start_time\r\n    let newStartTime: string\r\n    const offsetHours = 6 // UTC-6 para M√©xico\r\n\r\n    if (newDate && newTime) {\r\n        // Ambos proporcionados\r\n        const targetTime = new Date(`${newDate}T${newTime}:00`)\r\n        const utcDate = new Date(targetTime.getTime() + (offsetHours * 60 * 60 * 1000))\r\n        newStartTime = utcDate.toISOString()\r\n    } else if (newDate) {\r\n        // Solo fecha nueva, mantener hora original\r\n        const currentStart = new Date(currentAppointment.start_time)\r\n        // Adjust back to local to extract time components accurately\r\n        const localCurrent = new Date(currentStart.getTime() - (offsetHours * 60 * 60 * 1000))\r\n        const h = localCurrent.getUTCHours().toString().padStart(2, '0')\r\n        const m = localCurrent.getUTCMinutes().toString().padStart(2, '0')\r\n\r\n        const targetTime = new Date(`${newDate}T${h}:${m}:00`)\r\n        const utcDate = new Date(targetTime.getTime() + (offsetHours * 60 * 60 * 1000))\r\n        newStartTime = utcDate.toISOString()\r\n    } else if (newTime) {\r\n        // Solo hora nueva, mantener fecha original\r\n        const currentStart = new Date(currentAppointment.start_time)\r\n        const localCurrent = new Date(currentStart.getTime() - (offsetHours * 60 * 60 * 1000))\r\n        const y = localCurrent.getUTCFullYear()\r\n        const mo = (localCurrent.getUTCMonth() + 1).toString().padStart(2, '0')\r\n        const d = localCurrent.getUTCDate().toString().padStart(2, '0')\r\n\r\n        const targetTime = new Date(`${y}-${mo}-${d}T${newTime}:00`)\r\n        const utcDate = new Date(targetTime.getTime() + (offsetHours * 60 * 60 * 1000))\r\n        newStartTime = utcDate.toISOString()\r\n    } else {\r\n        return {\r\n            success: false,\r\n            error: 'Debes proporcionar al menos una nueva fecha o hora'\r\n        }\r\n    }\r\n\r\n    // Calcular nuevo end_time\r\n    const durationMinutes = currentAppointment.products?.service_duration_minutes || 60\r\n    const newEndTime = new Date(new Date(newStartTime).getTime() + durationMinutes * 60 * 1000).toISOString()\r\n\r\n    // Actualizar la cita\r\n    const { data: updatedAppointment, error: updateError } = await supabase\r\n        .from('meetings')\r\n        .update({\r\n            start_time: newStartTime,\r\n            end_time: newEndTime,\r\n            notes: currentAppointment.notes ? `${currentAppointment.notes} (Reprogramada)` : 'Reprogramada'\r\n        })\r\n        .eq('id', appointmentId)\r\n        .select()\r\n        .single()\r\n\r\n    if (updateError) {\r\n        console.error(`‚ùå [TOOL] Error updating appointment:`, updateError)\r\n        return {\r\n            success: false,\r\n            error: updateError.message\r\n        }\r\n    }\r\n\r\n    console.log(`‚úÖ [TOOL] Appointment #${appointmentId} rescheduled`)\r\n\r\n    // Format times for LLM response\r\n    const formatTime = (isoString: string) => {\r\n        return new Date(isoString).toLocaleString('es-MX', {\r\n            timeZone: 'America/Mexico_City',\r\n            weekday: 'long',\r\n            year: 'numeric',\r\n            month: 'long',\r\n            day: 'numeric',\r\n            hour: '2-digit',\r\n            minute: '2-digit',\r\n            hour12: true\r\n        })\r\n    }\r\n\r\n    return {\r\n        success: true,\r\n        appointmentId: updatedAppointment.id,\r\n        newStartTime: newStartTime,\r\n        newEndTime: newEndTime,\r\n        formattedStartTime: formatTime(newStartTime),\r\n        formattedEndTime: formatTime(newEndTime)\r\n    }\r\n}\r\n\r\n/**\r\n * Consulta promociones activas\r\n * Si no hay promociones, sugiere productos destacados de manera inteligente\r\n */\r\nexport async function consultarPromociones(\r\n    supabase: SupabaseClient,\r\n    userId: string\r\n): Promise<any> {\r\n    console.log(`üéÅ [TOOL] Consulting active promotions...`)\r\n\r\n    try {\r\n        // 1. Buscar promociones activas\r\n        const now = new Date().toISOString()\r\n\r\n        const { data: promotions, error: promoError } = await supabase\r\n            .from('smart_promotions')\r\n            .select('id, title, description, benefits, call_to_action, discount, image_urls')\r\n            .eq('user_id', userId)\r\n            .eq('is_active', true)\r\n            .or(`no_schedule.eq.true,and(start_at.lte.${now},end_at.gte.${now})`)\r\n            .limit(5)\r\n\r\n        if (promoError) {\r\n            console.error(`‚ùå [TOOL] Error fetching promotions:`, promoError)\r\n        }\r\n\r\n        // 2. Si HAY promociones, devolverlas\r\n        if (promotions && promotions.length > 0) {\r\n            console.log(`‚úÖ [TOOL] Found ${promotions.length} active promotion(s)`)\r\n\r\n            const formattedPromos = promotions.map((p: any) => ({\r\n                title: p.title,\r\n                description: p.description,\r\n                benefits: p.benefits,\r\n                callToAction: p.call_to_action,\r\n                discount: p.discount,\r\n                imageUrls: p.image_urls\r\n            }))\r\n\r\n            return {\r\n                hasPromotions: true,\r\n                promotions: formattedPromos,\r\n                message: `Tenemos ${promotions.length} promoci√≥n${promotions.length > 1 ? 'es' : ''} activa${promotions.length > 1 ? 's' : ''} en este momento.`\r\n            }\r\n        }\r\n\r\n        // 3. NO HAY PROMOCIONES - Buscar productos para sugerir\r\n        console.log(`‚ÑπÔ∏è [TOOL] No active promotions found - fetching featured products...`)\r\n\r\n        const productSearch = await buscarProductos(supabase, userId, '', 3) // Buscar 3 productos cualquiera\r\n\r\n        // 4. Si hay productos, sugerirlos como alternativa\r\n        if (productSearch.status === 'SUCCESS' && productSearch.exact_matches && productSearch.exact_matches.length > 0) {\r\n            console.log(`‚úÖ [TOOL] Suggesting ${productSearch.exact_matches.length} products as alternative`)\r\n\r\n            const products = productSearch.exact_matches.slice(0, 3)\r\n\r\n            return {\r\n                hasPromotions: false,\r\n                promotions: [],\r\n                hasSuggestedProducts: true,\r\n                suggestedProducts: products,\r\n                message: `En este momento no tenemos promociones activas, pero aqu√≠ te muestro algunos de nuestros productos que podr√≠an interesarte:`\r\n            }\r\n        }\r\n\r\n        // 5. No hay ni promociones ni productos\r\n        console.log(`‚ö†Ô∏è [TOOL] No promotions or products available`)\r\n\r\n        return {\r\n            hasPromotions: false,\r\n            promotions: [],\r\n            hasSuggestedProducts: false,\r\n            suggestedProducts: [],\r\n            message: `En este momento no tenemos promociones activas. Si necesitas algo espec√≠fico, con gusto te ayudo a buscarlo.`\r\n        }\r\n\r\n    } catch (error) {\r\n        console.error(`‚ùå [TOOL] Error in consultarPromociones:`, error)\r\n        return {\r\n            hasPromotions: false,\r\n            promotions: [],\r\n            error: error instanceof Error ? error.message : 'Error consultando promociones'\r\n        }\r\n    }\r\n}\r\n"}]